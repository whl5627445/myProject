# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_modelicacasadi_wrapper', [dirname(__file__)])
        except ImportError:
            import _modelicacasadi_wrapper
            return _modelicacasadi_wrapper
        if fp is not None:
            try:
                _mod = imp.load_module('_modelicacasadi_wrapper', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _modelicacasadi_wrapper = swig_import_helper()
    del swig_import_helper
else:
    import _modelicacasadi_wrapper
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _modelicacasadi_wrapper.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _modelicacasadi_wrapper.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _modelicacasadi_wrapper.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _modelicacasadi_wrapper.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _modelicacasadi_wrapper.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _modelicacasadi_wrapper.SwigPyIterator_equal(self, x)

    def copy(self):
        return _modelicacasadi_wrapper.SwigPyIterator_copy(self)

    def next(self):
        return _modelicacasadi_wrapper.SwigPyIterator_next(self)

    def __next__(self):
        return _modelicacasadi_wrapper.SwigPyIterator___next__(self)

    def previous(self):
        return _modelicacasadi_wrapper.SwigPyIterator_previous(self)

    def advance(self, n):
        return _modelicacasadi_wrapper.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _modelicacasadi_wrapper.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _modelicacasadi_wrapper.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _modelicacasadi_wrapper.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _modelicacasadi_wrapper.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _modelicacasadi_wrapper.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _modelicacasadi_wrapper.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _modelicacasadi_wrapper.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import casadi.casadi_core
class Printable(_object):
    """Proxy of C++ ModelicaCasADi::Printable class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Printable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Printable, name)
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Printable
    __del__ = lambda self: None

    def print_(self, *args):
        """print_(Printable self, std::ostream & os)"""
        return _modelicacasadi_wrapper.Printable_print_(self, *args)


    def __str__(self, *args):
        """__str__(Printable self) -> std::string"""
        return _modelicacasadi_wrapper.Printable___str__(self, *args)


    def __repr__(self, *args):
        """__repr__(Printable self) -> std::string"""
        return _modelicacasadi_wrapper.Printable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Printable self) -> Printable
        __init__(ModelicaCasADi::Printable self, Printable other) -> Printable
        """
        this = _modelicacasadi_wrapper.new_Printable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
Printable_swigregister = _modelicacasadi_wrapper.Printable_swigregister
Printable_swigregister(Printable)


def __lshift__(*args):
    """__lshift__(std::ostream & os, Printable p) -> std::ostream &"""
    return _modelicacasadi_wrapper.__lshift__(*args)

def normalizeMXRespresentation(*args):
    """normalizeMXRespresentation(MX a) -> std::string"""
    return _modelicacasadi_wrapper.normalizeMXRespresentation(*args)
class SharedNode(Printable):
    """Proxy of C++ ModelicaCasADi::SharedNode class."""

    __swig_setmethods__ = {}
    for _s in [Printable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SharedNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Printable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SharedNode, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _modelicacasadi_wrapper.delete_SharedNode
    __del__ = lambda self: None

    def __eq__(self, *args):
        """
        __eq__(SharedNode self, SharedNode node) -> bool
        __eq__(SharedNode self, PyObject * obj) -> bool
        """
        return _modelicacasadi_wrapper.SharedNode___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(SharedNode self, SharedNode node) -> bool
        __ne__(SharedNode self, PyObject * obj) -> bool
        """
        return _modelicacasadi_wrapper.SharedNode___ne__(self, *args)


    def __hash__(self, *args):
        """__hash__(SharedNode self) -> size_t"""
        return _modelicacasadi_wrapper.SharedNode___hash__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::SharedNode self) -> SharedNode
        __init__(ModelicaCasADi::SharedNode self, SharedNode other) -> SharedNode
        """
        this = _modelicacasadi_wrapper.new_SharedNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
SharedNode_swigregister = _modelicacasadi_wrapper.SharedNode_swigregister
SharedNode_swigregister(SharedNode)

class RefCountedNode(SharedNode):
    """Proxy of C++ ModelicaCasADi::RefCountedNode class."""

    __swig_setmethods__ = {}
    for _s in [SharedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RefCountedNode, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RefCountedNode, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _modelicacasadi_wrapper.delete_RefCountedNode
    __del__ = lambda self: None

    def getCount(self, *args):
        """getCount(RefCountedNode self) -> int"""
        return _modelicacasadi_wrapper.RefCountedNode_getCount(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::RefCountedNode self) -> RefCountedNode
        __init__(ModelicaCasADi::RefCountedNode self, RefCountedNode other) -> RefCountedNode
        """
        this = _modelicacasadi_wrapper.new_RefCountedNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
RefCountedNode_swigregister = _modelicacasadi_wrapper.RefCountedNode_swigregister
RefCountedNode_swigregister(RefCountedNode)

class OwnedNode(SharedNode):
    """Proxy of C++ ModelicaCasADi::OwnedNode class."""

    __swig_setmethods__ = {}
    for _s in [SharedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OwnedNode, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OwnedNode, name)
    __repr__ = _swig_repr

    def isOwnedBy(self, *args):
        """isOwnedBy(OwnedNode self, RefCountedNode owner) -> bool"""
        return _modelicacasadi_wrapper.OwnedNode_isOwnedBy(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::OwnedNode self, RefCountedNode owner) -> OwnedNode
        __init__(ModelicaCasADi::OwnedNode self, OwnedNode other) -> OwnedNode
        """
        this = _modelicacasadi_wrapper.new_OwnedNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_OwnedNode
    __del__ = lambda self: None
OwnedNode_swigregister = _modelicacasadi_wrapper.OwnedNode_swigregister
OwnedNode_swigregister(OwnedNode)

class Equation(RefCountedNode):
    """

    Equation represents an equation in Modelica, and it
    keeps MX expressions for the right and left-hand-side.
    """

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Equation, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Equation, name)

    def getLhs(self, *args):
        """
        getLhs(Equation self) -> MX


        Returns the left hand side expression

        Returns::

            MX --
                MX expression for left hand side


        """
        return _modelicacasadi_wrapper.Equation_getLhs(self, *args)


    def getRhs(self, *args):
        """
        getRhs(Equation self) -> MX


        Returns the right hand side expression

        Returns::

            MX --
                MX expression for right hand side


        """
        return _modelicacasadi_wrapper.Equation_getRhs(self, *args)


    def setLhs(self, *args):
        """setLhs(Equation self, MX nlhs)"""
        return _modelicacasadi_wrapper.Equation_setLhs(self, *args)


    def setRhs(self, *args):
        """setRhs(Equation self, MX nrhs)"""
        return _modelicacasadi_wrapper.Equation_setRhs(self, *args)


    def getResidual(self, *args):
        """
        getResidual(Equation self) -> MX


        Returns the residual on the form: left-hand-side - right-hand-side

        Returns::

            MX --
                The residual expression


        """
        return _modelicacasadi_wrapper.Equation_getResidual(self, *args)


    def print_(self, *args):
        """print_(Equation self, std::ostream & os)"""
        return _modelicacasadi_wrapper.Equation_print_(self, *args)


    def setTearing(self, *args):
        """setTearing(Equation self, bool arg2)"""
        return _modelicacasadi_wrapper.Equation_setTearing(self, *args)


    def getTearing(self, *args):
        """getTearing(Equation self) -> bool"""
        return _modelicacasadi_wrapper.Equation_getTearing(self, *args)


    def __repr__(self, *args):
        """__repr__(Equation self) -> std::string"""
        return _modelicacasadi_wrapper.Equation___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Equation self, MX lhs, MX rhs) -> Equation
        __init__(ModelicaCasADi::Equation self, Equation other) -> Equation


        Creates an Equation, with a MX expressions for the left and right hand side.

        Parameters::

            MX --
                MX expression for left hand side
            MX --
                MX expression for right hand side


        """
        this = _modelicacasadi_wrapper.new_Equation(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Equation
    __del__ = lambda self: None
Equation_swigregister = _modelicacasadi_wrapper.Equation_swigregister
Equation_swigregister(Equation)

class Constraint(RefCountedNode):
    """

    Constraint represents an optimica constraint. Constraint
    keeps MX for its left and right-hand-side, as well as a constraint
    type (i.e. equal, less than or equal, greater than or equal). 
    """

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)
    EQ = _modelicacasadi_wrapper.Constraint_EQ
    LEQ = _modelicacasadi_wrapper.Constraint_LEQ
    GEQ = _modelicacasadi_wrapper.Constraint_GEQ

    def getLhs(self, *args):
        """
        getLhs(Constraint self) -> MX


        Return the MX expression for the left hand side. 

        Returns::

            MX --
                A MX expression for the left hand side


        """
        return _modelicacasadi_wrapper.Constraint_getLhs(self, *args)


    def getRhs(self, *args):
        """
        getRhs(Constraint self) -> MX


        Return the MX expression for the right hand side. 

        Returns::

            MX --
                A MX expression for the right hand side


        """
        return _modelicacasadi_wrapper.Constraint_getRhs(self, *args)


    def setLhs(self, *args):
        """setLhs(Constraint self, MX nLhs)"""
        return _modelicacasadi_wrapper.Constraint_setLhs(self, *args)


    def setRhs(self, *args):
        """setRhs(Constraint self, MX nRhs)"""
        return _modelicacasadi_wrapper.Constraint_setRhs(self, *args)


    def getResidual(self, *args):
        """
        getResidual(Constraint self) -> MX


        Returns the residual of the constraint as: left-hand-side - right-hand-side.

        Returns::

            MX --
                A MX expression for the residual


        """
        return _modelicacasadi_wrapper.Constraint_getResidual(self, *args)


    def getType(self, *args):
        """
        getType(Constraint self) -> ModelicaCasADi::Constraint::Type


        Returns the type of the relation type for this Constraint.

        Returns::

            Type --
                A relation type, e.g. Constraint.LEQ


        """
        return _modelicacasadi_wrapper.Constraint_getType(self, *args)


    def print_(self, *args):
        """print_(Constraint self, std::ostream & os)"""
        return _modelicacasadi_wrapper.Constraint_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(Constraint self) -> std::string"""
        return _modelicacasadi_wrapper.Constraint___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Constraint self) -> Constraint
        __init__(ModelicaCasADi::Constraint self, MX lhs, MX rhs, ModelicaCasADi::Constraint::Type ct) -> Constraint
        __init__(ModelicaCasADi::Constraint self, Constraint other) -> Constraint


        Create a constraint from MX for the left and right hand side, 
        and a relation type (i.e. less than, greateer than and equal).

        Parameters::

            MX --
                A MX expression for the left hand side

            MX --
                A MX expression for the right hand side

            Type --
                A relation type, e.g. Constraint.LEQ


        """
        this = _modelicacasadi_wrapper.new_Constraint(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Constraint
    __del__ = lambda self: None
Constraint_swigregister = _modelicacasadi_wrapper.Constraint_swigregister
Constraint_swigregister(Constraint)

class ModelFunction(RefCountedNode):
    """

    ModelFunction is a wrapper around a Modelica function. CasADi
    provides the class MXFunction which is used to represent Modelica function,
    and calls using these functions are present in the MX the equations keeps. 
    ModelFunction provides a way to call the MXFunction using a MXVector 
    as arguments to the function.
    """

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelFunction, name)

    def getFunc(self, *args):
        """
        getFunc(ModelFunction self) -> MXFunction



        Returns::

            MXFunction --
                The underlying MXFunction


        """
        return _modelicacasadi_wrapper.ModelFunction_getFunc(self, *args)


    def getName(self, *args):
        """
        getName(ModelFunction self) -> std::string



        Returns::

            string --
                The name of the function.


        """
        return _modelicacasadi_wrapper.ModelFunction_getName(self, *args)


    def print_(self, *args):
        """print_(ModelFunction self, std::ostream & os)"""
        return _modelicacasadi_wrapper.ModelFunction_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(ModelFunction self) -> std::string"""
        return _modelicacasadi_wrapper.ModelFunction___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::ModelFunction self, MXFunction myFunction) -> ModelFunction
        __init__(ModelicaCasADi::ModelFunction self, ModelFunction other) -> ModelFunction


        Create a ModelFunction, which is basically a wrapper around an MXFunction 
        that may be called and printed. 

        Parameters::

            MXFunction --
                A MXFunction


        """
        this = _modelicacasadi_wrapper.new_ModelFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_ModelFunction
    __del__ = lambda self: None
ModelFunction_swigregister = _modelicacasadi_wrapper.ModelFunction_swigregister
ModelFunction_swigregister(ModelFunction)

class VariableType(RefCountedNode):
    """Proxy of C++ ModelicaCasADi::VariableType class."""

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableType, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def getAttribute(self, *args):
        """getAttribute(VariableType self, ModelicaCasADi::VariableType::AttributeKey const key) -> MX"""
        return _modelicacasadi_wrapper.VariableType_getAttribute(self, *args)


    def getName(self, *args):
        """getName(VariableType self) -> std::string const"""
        return _modelicacasadi_wrapper.VariableType_getName(self, *args)


    def hasAttribute(self, *args):
        """hasAttribute(VariableType self, ModelicaCasADi::VariableType::AttributeKey const key) -> bool"""
        return _modelicacasadi_wrapper.VariableType_hasAttribute(self, *args)


    def print_(self, *args):
        """print_(VariableType self, std::ostream & os)"""
        return _modelicacasadi_wrapper.VariableType_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(VariableType self) -> std::string"""
        return _modelicacasadi_wrapper.VariableType___repr__(self, *args)

    __swig_destroy__ = _modelicacasadi_wrapper.delete_VariableType
    __del__ = lambda self: None
VariableType_swigregister = _modelicacasadi_wrapper.VariableType_swigregister
VariableType_swigregister(VariableType)

class PrimitiveType(VariableType):
    """Proxy of C++ ModelicaCasADi::PrimitiveType class."""

    __swig_setmethods__ = {}
    for _s in [VariableType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrimitiveType, name, value)
    __swig_getmethods__ = {}
    for _s in [VariableType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrimitiveType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def __repr__(self, *args):
        """__repr__(PrimitiveType self) -> std::string"""
        return _modelicacasadi_wrapper.PrimitiveType___repr__(self, *args)

    __swig_destroy__ = _modelicacasadi_wrapper.delete_PrimitiveType
    __del__ = lambda self: None
PrimitiveType_swigregister = _modelicacasadi_wrapper.PrimitiveType_swigregister
PrimitiveType_swigregister(PrimitiveType)

class BooleanType(PrimitiveType):
    """Proxy of C++ ModelicaCasADi::BooleanType class."""

    __swig_setmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BooleanType, name, value)
    __swig_getmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BooleanType, name)

    def getName(self, *args):
        """getName(BooleanType self) -> std::string const"""
        return _modelicacasadi_wrapper.BooleanType_getName(self, *args)


    def getAttribute(self, *args):
        """getAttribute(BooleanType self, ModelicaCasADi::VariableType::AttributeKey const key) -> MX"""
        return _modelicacasadi_wrapper.BooleanType_getAttribute(self, *args)


    def hasAttribute(self, *args):
        """hasAttribute(BooleanType self, ModelicaCasADi::VariableType::AttributeKey const key) -> bool"""
        return _modelicacasadi_wrapper.BooleanType_hasAttribute(self, *args)


    def __repr__(self, *args):
        """__repr__(BooleanType self) -> std::string"""
        return _modelicacasadi_wrapper.BooleanType___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::BooleanType self) -> BooleanType
        __init__(ModelicaCasADi::BooleanType self, BooleanType other) -> BooleanType
        """
        this = _modelicacasadi_wrapper.new_BooleanType(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_BooleanType
    __del__ = lambda self: None
BooleanType_swigregister = _modelicacasadi_wrapper.BooleanType_swigregister
BooleanType_swigregister(BooleanType)

class IntegerType(PrimitiveType):
    """Proxy of C++ ModelicaCasADi::IntegerType class."""

    __swig_setmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerType, name, value)
    __swig_getmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerType, name)

    def getName(self, *args):
        """getName(IntegerType self) -> std::string const"""
        return _modelicacasadi_wrapper.IntegerType_getName(self, *args)


    def getAttribute(self, *args):
        """getAttribute(IntegerType self, ModelicaCasADi::VariableType::AttributeKey const key) -> MX"""
        return _modelicacasadi_wrapper.IntegerType_getAttribute(self, *args)


    def hasAttribute(self, *args):
        """hasAttribute(IntegerType self, ModelicaCasADi::VariableType::AttributeKey const key) -> bool"""
        return _modelicacasadi_wrapper.IntegerType_hasAttribute(self, *args)


    def __repr__(self, *args):
        """__repr__(IntegerType self) -> std::string"""
        return _modelicacasadi_wrapper.IntegerType___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::IntegerType self) -> IntegerType
        __init__(ModelicaCasADi::IntegerType self, IntegerType other) -> IntegerType
        """
        this = _modelicacasadi_wrapper.new_IntegerType(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_IntegerType
    __del__ = lambda self: None
IntegerType_swigregister = _modelicacasadi_wrapper.IntegerType_swigregister
IntegerType_swigregister(IntegerType)

class RealType(PrimitiveType):
    """Proxy of C++ ModelicaCasADi::RealType class."""

    __swig_setmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealType, name, value)
    __swig_getmethods__ = {}
    for _s in [PrimitiveType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealType, name)

    def getName(self, *args):
        """getName(RealType self) -> std::string const"""
        return _modelicacasadi_wrapper.RealType_getName(self, *args)


    def getAttribute(self, *args):
        """getAttribute(RealType self, ModelicaCasADi::VariableType::AttributeKey const key) -> MX"""
        return _modelicacasadi_wrapper.RealType_getAttribute(self, *args)


    def hasAttribute(self, *args):
        """hasAttribute(RealType self, ModelicaCasADi::VariableType::AttributeKey const key) -> bool"""
        return _modelicacasadi_wrapper.RealType_hasAttribute(self, *args)


    def __repr__(self, *args):
        """__repr__(RealType self) -> std::string"""
        return _modelicacasadi_wrapper.RealType___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::RealType self) -> RealType
        __init__(ModelicaCasADi::RealType self, RealType other) -> RealType
        """
        this = _modelicacasadi_wrapper.new_RealType(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_RealType
    __del__ = lambda self: None
RealType_swigregister = _modelicacasadi_wrapper.RealType_swigregister
RealType_swigregister(RealType)

class UserType(VariableType):
    """Proxy of C++ ModelicaCasADi::UserType class."""

    __swig_setmethods__ = {}
    for _s in [VariableType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserType, name, value)
    __swig_getmethods__ = {}
    for _s in [VariableType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserType, name)

    def getName(self, *args):
        """getName(UserType self) -> std::string const"""
        return _modelicacasadi_wrapper.UserType_getName(self, *args)


    def setAttribute(self, *args):
        """setAttribute(UserType self, ModelicaCasADi::VariableType::AttributeKey key, MX val)"""
        return _modelicacasadi_wrapper.UserType_setAttribute(self, *args)


    def getAttribute(self, *args):
        """getAttribute(UserType self, ModelicaCasADi::VariableType::AttributeKey const key) -> MX"""
        return _modelicacasadi_wrapper.UserType_getAttribute(self, *args)


    def hasAttribute(self, *args):
        """hasAttribute(UserType self, ModelicaCasADi::VariableType::AttributeKey const key) -> bool"""
        return _modelicacasadi_wrapper.UserType_hasAttribute(self, *args)


    def print_(self, *args):
        """print_(UserType self, std::ostream & os)"""
        return _modelicacasadi_wrapper.UserType_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(UserType self) -> std::string"""
        return _modelicacasadi_wrapper.UserType___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::UserType self, std::string name, ModelicaCasADi::Ref< ModelicaCasADi::PrimitiveType > baseType) -> UserType
        __init__(ModelicaCasADi::UserType self, UserType other) -> UserType
        """
        this = _modelicacasadi_wrapper.new_UserType(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_UserType
    __del__ = lambda self: None
UserType_swigregister = _modelicacasadi_wrapper.UserType_swigregister
UserType_swigregister(UserType)

class Variable(OwnedNode):
    """

    Abstract class for Variables, using symolic MX. A variable holds data 
    so that it can represent a Modelica or Optimica variable. This data
    consists of attributes and enum variables that tells the variable's
    primitive data type and its causality and variability. 

    A variable can also hold a VariableType that contains information about 
    its default attributes or the attributes of its user defined type. 
    """

    __swig_setmethods__ = {}
    for _s in [OwnedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    for _s in [OwnedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    REAL = _modelicacasadi_wrapper.Variable_REAL
    INTEGER = _modelicacasadi_wrapper.Variable_INTEGER
    BOOLEAN = _modelicacasadi_wrapper.Variable_BOOLEAN
    STRING = _modelicacasadi_wrapper.Variable_STRING
    INPUT = _modelicacasadi_wrapper.Variable_INPUT
    OUTPUT = _modelicacasadi_wrapper.Variable_OUTPUT
    INTERNAL = _modelicacasadi_wrapper.Variable_INTERNAL
    CONSTANT = _modelicacasadi_wrapper.Variable_CONSTANT
    PARAMETER = _modelicacasadi_wrapper.Variable_PARAMETER
    TIMED = _modelicacasadi_wrapper.Variable_TIMED
    DISCRETE = _modelicacasadi_wrapper.Variable_DISCRETE
    CONTINUOUS = _modelicacasadi_wrapper.Variable_CONTINUOUS

    def isAlias(self, *args):
        """
        isAlias(Variable self) -> bool


        Is this Variable an alias variable or not. 

        Returns::

            bool --


        """
        return _modelicacasadi_wrapper.Variable_isAlias(self, *args)


    def isNegated(self, *args):
        """
        isNegated(Variable self) -> bool


        Is this variable negated. 

        Returns::

            bool --


        """
        return _modelicacasadi_wrapper.Variable_isNegated(self, *args)


    def getTearing(self, *args):
        """getTearing(Variable self) -> bool"""
        return _modelicacasadi_wrapper.Variable_getTearing(self, *args)


    def isEliminable(self, *args):
        """isEliminable(Variable self) -> bool"""
        return _modelicacasadi_wrapper.Variable_isEliminable(self, *args)


    def wasEliminated(self, *args):
        """wasEliminated(Variable self) -> bool"""
        return _modelicacasadi_wrapper.Variable_wasEliminated(self, *args)


    def setNegated(self, *args):
        """
        setNegated(Variable self, bool negated)


        Only alias variables may be negated. 

        Params::

            bool --


        """
        return _modelicacasadi_wrapper.Variable_setNegated(self, *args)


    def setTearing(self, *args):
        """setTearing(Variable self, bool arg2)"""
        return _modelicacasadi_wrapper.Variable_setTearing(self, *args)


    def setAsEliminable(self, *args):
        """setAsEliminable(Variable self)"""
        return _modelicacasadi_wrapper.Variable_setAsEliminable(self, *args)


    def setAsEliminated(self, *args):
        """setAsEliminated(Variable self)"""
        return _modelicacasadi_wrapper.Variable_setAsEliminated(self, *args)


    def setAlias(self, *args):
        """
        setAlias(Variable self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var)


        Sets an alias for this variable, making it an alias variable

        Params::

            Variable --


        """
        return _modelicacasadi_wrapper.Variable_setAlias(self, *args)


    def getModelVariable(self, *args):
        """
        getModelVariable(Variable self) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable >


        If this Variable is an alias, return it's Model variable; otherwise return itself.

        Params::

            Variable --


        """
        return _modelicacasadi_wrapper.Variable_getModelVariable(self, *args)


    def setQuantity(self, *args):
        """
        setQuantity(Variable self, std::string quantity)
        setQuantity(Variable self, MX quantity)
        """
        return _modelicacasadi_wrapper.Variable_setQuantity(self, *args)


    def getQuantity(self, *args):
        """getQuantity(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getQuantity(self, *args)


    def setNominal(self, *args):
        """
        setNominal(Variable self, double nominal)
        setNominal(Variable self, MX nominal)
        """
        return _modelicacasadi_wrapper.Variable_setNominal(self, *args)


    def getNominal(self, *args):
        """getNominal(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getNominal(self, *args)


    def setUnit(self, *args):
        """
        setUnit(Variable self, std::string unit)
        setUnit(Variable self, MX unit)
        """
        return _modelicacasadi_wrapper.Variable_setUnit(self, *args)


    def getUnit(self, *args):
        """getUnit(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getUnit(self, *args)


    def setDisplayUnit(self, *args):
        """
        setDisplayUnit(Variable self, std::string displayUnit)
        setDisplayUnit(Variable self, MX displayUnit)
        """
        return _modelicacasadi_wrapper.Variable_setDisplayUnit(self, *args)


    def getDisplayUnit(self, *args):
        """getDisplayUnit(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getDisplayUnit(self, *args)


    def setMin(self, *args):
        """
        setMin(Variable self, double min)
        setMin(Variable self, MX min)
        """
        return _modelicacasadi_wrapper.Variable_setMin(self, *args)


    def getMin(self, *args):
        """getMin(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getMin(self, *args)


    def setMax(self, *args):
        """
        setMax(Variable self, double max)
        setMax(Variable self, MX max)
        """
        return _modelicacasadi_wrapper.Variable_setMax(self, *args)


    def getMax(self, *args):
        """getMax(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getMax(self, *args)


    def setStart(self, *args):
        """
        setStart(Variable self, double start)
        setStart(Variable self, MX start)
        """
        return _modelicacasadi_wrapper.Variable_setStart(self, *args)


    def getStart(self, *args):
        """getStart(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getStart(self, *args)


    def setFixed(self, *args):
        """
        setFixed(Variable self, bool fixed)
        setFixed(Variable self, MX fixed)
        """
        return _modelicacasadi_wrapper.Variable_setFixed(self, *args)


    def getFixed(self, *args):
        """getFixed(Variable self) -> MX"""
        return _modelicacasadi_wrapper.Variable_getFixed(self, *args)


    def getName(self, *args):
        """
        getName(Variable self) -> std::string


        Returns the name of this variable

        Returns::

            string --
                This variable's name. 

        """
        return _modelicacasadi_wrapper.Variable_getName(self, *args)


    def getVar(self, *args):
        """
        getVar(Variable self) -> MX


        Returns the symbolic MX for this Variable

        Returns::

            MX --
                A symbolic MX

        """
        return _modelicacasadi_wrapper.Variable_getVar(self, *args)


    def getType(self, *args):
        """
        getType(Variable self) -> ModelicaCasADi::Variable::Type const


        Returns the primitive Type for this Variable, e.g. Variable.REAL

        Returns::

            Type --
                A Type

        """
        return _modelicacasadi_wrapper.Variable_getType(self, *args)


    def getCausality(self, *args):
        """
        getCausality(Variable self) -> ModelicaCasADi::Variable::Causality const


        Returns the Causality for this Variable, e.g. Variable.INPUT

        Returns::

            Causality --
                A Causality

        """
        return _modelicacasadi_wrapper.Variable_getCausality(self, *args)


    def getVariability(self, *args):
        """
        getVariability(Variable self) -> ModelicaCasADi::Variable::Variability const


        Returns the Variability for this Variable, e.g. Variable.CONTINUOUS

        Returns::

            Variability --
                A Variability


        """
        return _modelicacasadi_wrapper.Variable_getVariability(self, *args)


    def getDeclaredType(self, *args):
        """
        getDeclaredType(Variable self) -> ModelicaCasADi::Ref< ModelicaCasADi::VariableType >


        Returns this Variable's declared type, if it has one. This may be
        one of Modelica's built in types such as Real, and then it will
        contain the Real types default attributes, or it may be a user
        defined type. 

        Returns::

            VariableType --
                A VariableType or None


        """
        return _modelicacasadi_wrapper.Variable_getDeclaredType(self, *args)


    def setDeclaredType(self, *args):
        """
        setDeclaredType(Variable self, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType)


        Sets this Variable's declared type. 

        Parameters::

            VariableType --
                A VariableType


        """
        return _modelicacasadi_wrapper.Variable_setDeclaredType(self, *args)


    def getAttribute(self, *args):
        """
        getAttribute(Variable self, ModelicaCasADi::Variable::AttributeKey key) -> MX


        Returns the value of the attribute with the specified name. Looks at
        the local attributes then at its declared type, OR at its alias if 
        this is an alias variable (whether this is a negated alias
        variable or not is considered for the start, min, max and nominal attributes). 


        Parameters::

            AttributeKey --
                A string name

        Returns::

            AttributeValue --
                An AttributeValue, e.g. an MX expression


        """
        return _modelicacasadi_wrapper.Variable_getAttribute(self, *args)


    def hasAttributeSet(self, *args):
        """
        hasAttributeSet(Variable self, ModelicaCasADi::Variable::AttributeKey key) -> bool


        A check whether the variable has a certain attribute set, OR if 
        its alias has a certain attribute set if this is an alias variable

        Parameters::

            AttributeKey --
                A string name

        Returns::

            Bool --


        """
        return _modelicacasadi_wrapper.Variable_hasAttributeSet(self, *args)


    def setAttribute(self, *args):
        """
        setAttribute(Variable self, ModelicaCasADi::Variable::AttributeKey key, MX val)
        setAttribute(Variable self, ModelicaCasADi::Variable::AttributeKey key, double val)


        Sets an attribute in this variable, OR if this is an alias variable
        the attribute is propagated to its alias (whether this is a negated alias
        variable or not is considered for the start, min, max and nominal attributes). 

        Parameters::

            AttributeKey --
                A string name

            AttributeValue --
                An AttributeValue, a double or a MX.


        """
        return _modelicacasadi_wrapper.Variable_setAttribute(self, *args)


    def print_(self, *args):
        """print_(Variable self, std::ostream & os)"""
        return _modelicacasadi_wrapper.Variable_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(Variable self) -> std::string"""
        return _modelicacasadi_wrapper.Variable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Variable self, Model owner) -> Variable
        __init__(ModelicaCasADi::Variable self, Model owner, MX var, ModelicaCasADi::Variable::Causality causality, ModelicaCasADi::Variable::Variability variability, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType) -> Variable
        __init__(ModelicaCasADi::Variable self, Variable other) -> Variable


        Creates a Variable with the symbolic MX, Causality and Variability provided.
        Note that Variable should not be used directly, instead subclasses such 
        as RealVariable should be used. 

        Parameters::

            MX --
                A symbolic MX

            Causality --
                A Causality, e.g. Variable.INPUT

            Variability --
                A Variability, e.g. Variable.CONTINUOUS

            VariableType --
                A VariableType, default is None. 

        """
        this = _modelicacasadi_wrapper.new_Variable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Variable
    __del__ = lambda self: None
Variable_swigregister = _modelicacasadi_wrapper.Variable_swigregister
Variable_swigregister(Variable)

class TimedVariable(Variable):
    """

    Represents a variable at a given time, as supported in Optimica constraints. 
    A timed variable keeps a reference to its base variable
     (e.g. a refernce to X for X(1)), and a time point (e.g. 1). 
    """

    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimedVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimedVariable, name)

    def getTimePoint(self, *args):
        """getTimePoint(TimedVariable self) -> MX"""
        return _modelicacasadi_wrapper.TimedVariable_getTimePoint(self, *args)


    def getBaseVariable(self, *args):
        """
        getBaseVariable(TimedVariable self) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable > const


        The base variable for this timed variable, e.g. X if this is timed variable X(1).

        Returns::

            Variable --


        """
        return _modelicacasadi_wrapper.TimedVariable_getBaseVariable(self, *args)


    def getType(self, *args):
        """
        getType(TimedVariable self) -> ModelicaCasADi::Variable::Type const


        Returns the Type Real

        Returns::

            Type --


        """
        return _modelicacasadi_wrapper.TimedVariable_getType(self, *args)


    def __repr__(self, *args):
        """__repr__(TimedVariable self) -> std::string"""
        return _modelicacasadi_wrapper.TimedVariable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::TimedVariable self, Model owner, MX var, ModelicaCasADi::Ref< ModelicaCasADi::Variable > baseVariable, MX timePoint) -> TimedVariable
        __init__(ModelicaCasADi::TimedVariable self, TimedVariable other) -> TimedVariable


        A timed variable keeps a reference to its base variable (e.g. a refernce 
        to X for X(1)), and a time point (e.g. 1). Is used in constraints, and is
        only supported for real variables. 

        Parameters::

            MX --
                A symbolic MX

            Variable --
                The base variable for this timed variable, e.g. X if this is timed variable X(1).

            MX --
                A MX expression for the time point, e.g. 1 or finalTime/2.

        """
        this = _modelicacasadi_wrapper.new_TimedVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_TimedVariable
    __del__ = lambda self: None
TimedVariable_swigregister = _modelicacasadi_wrapper.TimedVariable_swigregister
TimedVariable_swigregister(TimedVariable)

class RealVariable(Variable):
    """

    Represent a real Modelica variable. Can keep a reference to
    a DerivativeVariable.
    """

    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealVariable, name)

    def getType(self, *args):
        """
        getType(RealVariable self) -> ModelicaCasADi::Variable::Type const


        Returns the Type Real

        Returns::

            Type --
                The Type Real


        """
        return _modelicacasadi_wrapper.RealVariable_getType(self, *args)


    def setMyDerivativeVariable(self, *args):
        """
        setMyDerivativeVariable(RealVariable self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > derVar)


        Sets the derivative variable associated with this variable, 

        Parameters::

            Variable --
                A Variable to be set as derivative variable. It must be a DerivativeVariable.


        """
        return _modelicacasadi_wrapper.RealVariable_setMyDerivativeVariable(self, *args)


    def getMyDerivativeVariable(self, *args):
        """
        getMyDerivativeVariable(RealVariable self) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable > const


        Retrieves the derivative variable associated with this variable.

        Returns::

            Variable --
                A Variable, or None if not present. 


        """
        return _modelicacasadi_wrapper.RealVariable_getMyDerivativeVariable(self, *args)


    def isDerivative(self, *args):
        """
        isDerivative(RealVariable self) -> bool


        Check whether this variable is a derivative. Since it is not a 
        DerivativeVariable it is not a derivative. 

        Returns::

            Bool --
                False


        """
        return _modelicacasadi_wrapper.RealVariable_isDerivative(self, *args)


    def __repr__(self, *args):
        """__repr__(RealVariable self) -> std::string"""
        return _modelicacasadi_wrapper.RealVariable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::RealVariable self, Model owner, MX var, ModelicaCasADi::Variable::Causality causality, ModelicaCasADi::Variable::Variability variability, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType) -> RealVariable
        __init__(ModelicaCasADi::RealVariable self, RealVariable other) -> RealVariable


        Create a RealVariable.

        Parameters::

            MX --
                A symbolic MX.

            Causality --
                A Causality, e.g. RealVariable.INPUT

            Variability --
                A Variability, e.g. RealVariable.CONTINUOUS

            VariableType --
                A VariableType, default is None. 


        """
        this = _modelicacasadi_wrapper.new_RealVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_RealVariable
    __del__ = lambda self: None
RealVariable_swigregister = _modelicacasadi_wrapper.RealVariable_swigregister
RealVariable_swigregister(RealVariable)

class DerivativeVariable(RealVariable):
    """

    Represent a derivate variable, e.g. a variable that represents
    der(variable). Keeps a reference to its corresponding non-derivate variable.
    """

    __swig_setmethods__ = {}
    for _s in [RealVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DerivativeVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [RealVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DerivativeVariable, name)

    def getMyDifferentiatedVariable(self, *args):
        """
        getMyDifferentiatedVariable(DerivativeVariable self) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable > const


        Returns the state variable associated with this variable

        Returns::

            Variable --



        """
        return _modelicacasadi_wrapper.DerivativeVariable_getMyDifferentiatedVariable(self, *args)


    def isDerivative(self, *args):
        """
        isDerivative(DerivativeVariable self) -> bool


        Returns True

        Returns::

            Bool --
                True 


        """
        return _modelicacasadi_wrapper.DerivativeVariable_isDerivative(self, *args)


    def __repr__(self, *args):
        """__repr__(DerivativeVariable self) -> std::string"""
        return _modelicacasadi_wrapper.DerivativeVariable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::DerivativeVariable self, Model owner, MX var, ModelicaCasADi::Ref< ModelicaCasADi::Variable > diffVar, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType) -> DerivativeVariable
        __init__(ModelicaCasADi::DerivativeVariable self, DerivativeVariable other) -> DerivativeVariable


        Create a derivative variable. A derivative variable takes its 
        corresponding state variable as argument. Note that a state variable
        must have real type and continuous variability. 

        Parameters::

            MX --
                A symbolic MX

            Variable --
                This variable's state variable

            VariableType --
                A VariableType, default is None. 


        """
        this = _modelicacasadi_wrapper.new_DerivativeVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_DerivativeVariable
    __del__ = lambda self: None
DerivativeVariable_swigregister = _modelicacasadi_wrapper.DerivativeVariable_swigregister
DerivativeVariable_swigregister(DerivativeVariable)

class BooleanVariable(Variable):
    """


    A boolean Modelica variable.

    """

    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BooleanVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BooleanVariable, name)

    def getType(self, *args):
        """
        getType(BooleanVariable self) -> ModelicaCasADi::Variable::Type const


        Returns the Type Boolean

        Returns::

            Type --
                The Type Boolean


        """
        return _modelicacasadi_wrapper.BooleanVariable_getType(self, *args)


    def __repr__(self, *args):
        """__repr__(BooleanVariable self) -> std::string"""
        return _modelicacasadi_wrapper.BooleanVariable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::BooleanVariable self, Model owner, MX var, ModelicaCasADi::Variable::Causality causality, ModelicaCasADi::Variable::Variability variability, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType) -> BooleanVariable
        __init__(ModelicaCasADi::BooleanVariable self, BooleanVariable other) -> BooleanVariable


        Create a Boolean variable. Boolean variables may not have
        continuous variability. 

        Parameters::

            MX --
                A symbolic MX

            Causality --
                A Causality, e.g. BooleanVariable.INPUT

            Variability --
                A Variability, e.g. BooleanVariable.DISCRETE

            VariableType --
                A VariableType, default is None. 

        """
        this = _modelicacasadi_wrapper.new_BooleanVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_BooleanVariable
    __del__ = lambda self: None
BooleanVariable_swigregister = _modelicacasadi_wrapper.BooleanVariable_swigregister
BooleanVariable_swigregister(BooleanVariable)

class IntegerVariable(Variable):
    """


    An integer Modelica variable.


    """

    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerVariable, name)

    def getType(self, *args):
        """
        getType(IntegerVariable self) -> ModelicaCasADi::Variable::Type const


        Returns the Type Integer

        Returns::

            Type --
                The Type Integer


        """
        return _modelicacasadi_wrapper.IntegerVariable_getType(self, *args)


    def __repr__(self, *args):
        """__repr__(IntegerVariable self) -> std::string"""
        return _modelicacasadi_wrapper.IntegerVariable___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::IntegerVariable self, Model owner, MX var, ModelicaCasADi::Variable::Causality causality, ModelicaCasADi::Variable::Variability variability, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > declaredType) -> IntegerVariable
        __init__(ModelicaCasADi::IntegerVariable self, IntegerVariable other) -> IntegerVariable


        Create an Integer Variable. An integer Variable may not have 
        continuous variability. 

        Parameters::

            MX --
                A symbolic MX

            Causality --
                A Causality, e.g. IntegerVariable.INPUT

            Variability --
                A Variability, e.g. IntegerVariable.DISCRETE

            VariableType --
                A VariableType, default is None. 

        """
        this = _modelicacasadi_wrapper.new_IntegerVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_IntegerVariable
    __del__ = lambda self: None
IntegerVariable_swigregister = _modelicacasadi_wrapper.IntegerVariable_swigregister
IntegerVariable_swigregister(IntegerVariable)

class Block(RefCountedNode):
    """Proxy of C++ ModelicaCasADi::Block class."""

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Block, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Block, name)
    __repr__ = _swig_repr

    def variablesVector(self, *args):
        """variablesVector(Block self) -> MXVector"""
        return _modelicacasadi_wrapper.Block_variablesVector(self, *args)


    def markTearingResiduals(self, *args):
        """markTearingResiduals(Block self)"""
        return _modelicacasadi_wrapper.Block_markTearingResiduals(self, *args)


    def moveAllEquationsToUnsolvable(self, *args):
        """moveAllEquationsToUnsolvable(Block self)"""
        return _modelicacasadi_wrapper.Block_moveAllEquationsToUnsolvable(self, *args)


    def getNumVariables(self, *args):
        """getNumVariables(Block self) -> int"""
        return _modelicacasadi_wrapper.Block_getNumVariables(self, *args)


    def getNumUnsolvedVariables(self, *args):
        """getNumUnsolvedVariables(Block self) -> int"""
        return _modelicacasadi_wrapper.Block_getNumUnsolvedVariables(self, *args)


    def getNumExternalVariables(self, *args):
        """getNumExternalVariables(Block self) -> int"""
        return _modelicacasadi_wrapper.Block_getNumExternalVariables(self, *args)


    def getVariableIndex(self, *args):
        """getVariableIndex(Block self, Variable var) -> int"""
        return _modelicacasadi_wrapper.Block_getVariableIndex(self, *args)


    def variables(self, *args):
        """variables(Block self) -> std::set< ModelicaCasADi::Variable const * > const &"""
        return _modelicacasadi_wrapper.Block_variables(self, *args)


    def unsolvedVariables(self, *args):
        """unsolvedVariables(Block self) -> std::set< ModelicaCasADi::Variable const * > const &"""
        return _modelicacasadi_wrapper.Block_unsolvedVariables(self, *args)


    def externalVariables(self, *args):
        """externalVariables(Block self) -> std::set< ModelicaCasADi::Variable const * > const &"""
        return _modelicacasadi_wrapper.Block_externalVariables(self, *args)


    def isExternal(self, *args):
        """isExternal(Block self, Variable var) -> bool"""
        return _modelicacasadi_wrapper.Block_isExternal(self, *args)


    def isBlockVariable(self, *args):
        """isBlockVariable(Block self, Variable var) -> bool"""
        return _modelicacasadi_wrapper.Block_isBlockVariable(self, *args)


    def removeSolutionOfVariable(self, *args):
        """removeSolutionOfVariable(Block self, Variable var) -> bool"""
        return _modelicacasadi_wrapper.Block_removeSolutionOfVariable(self, *args)


    def getSolutionMap(self, *args):
        """getSolutionMap(Block self) -> std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > >"""
        return _modelicacasadi_wrapper.Block_getSolutionMap(self, *args)


    def getSolutionOfVariable(self, *args):
        """getSolutionOfVariable(Block self, Variable var) -> MX"""
        return _modelicacasadi_wrapper.Block_getSolutionOfVariable(self, *args)


    def hasSolution(self, *args):
        """hasSolution(Block self, Variable arg2) -> bool"""
        return _modelicacasadi_wrapper.Block_hasSolution(self, *args)


    def addVariable(self, *args):
        """addVariable(Block self, Variable var, bool solvable)"""
        return _modelicacasadi_wrapper.Block_addVariable(self, *args)


    def addExternalVariable(self, *args):
        """addExternalVariable(Block self, Variable var)"""
        return _modelicacasadi_wrapper.Block_addExternalVariable(self, *args)


    def eliminableVariables(self, *args):
        """eliminableVariables(Block self) -> std::set< ModelicaCasADi::Variable const * >"""
        return _modelicacasadi_wrapper.Block_eliminableVariables(self, *args)


    def addSolutionToVariable(self, *args):
        """addSolutionToVariable(Block self, Variable var, MX sol)"""
        return _modelicacasadi_wrapper.Block_addSolutionToVariable(self, *args)


    def getNumEquations(self, *args):
        """getNumEquations(Block self) -> int"""
        return _modelicacasadi_wrapper.Block_getNumEquations(self, *args)


    def getNumUnsolvedEquations(self, *args):
        """getNumUnsolvedEquations(Block self) -> int"""
        return _modelicacasadi_wrapper.Block_getNumUnsolvedEquations(self, *args)


    def allEquations(self, *args):
        """allEquations(Block self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.Block_allEquations(self, *args)


    def notSolvedEquations(self, *args):
        """notSolvedEquations(Block self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.Block_notSolvedEquations(self, *args)


    def addEquation(self, *args):
        """addEquation(Block self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq, bool solvable)"""
        return _modelicacasadi_wrapper.Block_addEquation(self, *args)


    def addNotClassifiedEquation(self, *args):
        """addNotClassifiedEquation(Block self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)"""
        return _modelicacasadi_wrapper.Block_addNotClassifiedEquation(self, *args)


    def addUnsolvedEquation(self, *args):
        """addUnsolvedEquation(Block self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)"""
        return _modelicacasadi_wrapper.Block_addUnsolvedEquation(self, *args)


    def getEquationsforModel(self, *args):
        """getEquationsforModel(Block self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.Block_getEquationsforModel(self, *args)


    def computeJacobianCasADi(self, *args):
        """computeJacobianCasADi(Block self)"""
        return _modelicacasadi_wrapper.Block_computeJacobianCasADi(self, *args)


    def printBlock(self, *args):
        """printBlock(Block self, std::ostream & out, bool withData=False)"""
        return _modelicacasadi_wrapper.Block_printBlock(self, *args)


    def isSimple(self, *args):
        """isSimple(Block self) -> bool"""
        return _modelicacasadi_wrapper.Block_isSimple(self, *args)


    def isLinear(self, *args):
        """isLinear(Block self) -> bool"""
        return _modelicacasadi_wrapper.Block_isLinear(self, *args)


    def isSolvable(self, *args):
        """isSolvable(Block self) -> bool"""
        return _modelicacasadi_wrapper.Block_isSolvable(self, *args)


    def setasSimple(self, *args):
        """setasSimple(Block self, bool flag)"""
        return _modelicacasadi_wrapper.Block_setasSimple(self, *args)


    def setasLinear(self, *args):
        """setasLinear(Block self, bool flag)"""
        return _modelicacasadi_wrapper.Block_setasLinear(self, *args)


    def setasSolvable(self, *args):
        """setasSolvable(Block self, bool flag)"""
        return _modelicacasadi_wrapper.Block_setasSolvable(self, *args)


    def solveLinearSystem(self, *args):
        """solveLinearSystem(Block self)"""
        return _modelicacasadi_wrapper.Block_solveLinearSystem(self, *args)


    def substitute(self, *args):
        """substitute(Block self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & mapVariableToExpression)"""
        return _modelicacasadi_wrapper.Block_substitute(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Block self) -> Block
        __init__(ModelicaCasADi::Block self, Block other) -> Block
        """
        this = _modelicacasadi_wrapper.new_Block(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Block
    __del__ = lambda self: None
Block_swigregister = _modelicacasadi_wrapper.Block_swigregister
Block_swigregister(Block)

class Equations(RefCountedNode):
    """Proxy of C++ ModelicaCasADi::Equations class."""

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Equations, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Equations, name)
    __repr__ = _swig_repr

    def hasBLT(self, *args):
        """hasBLT(Equations self) -> bool"""
        return _modelicacasadi_wrapper.Equations_hasBLT(self, *args)


    def eliminableVariables(self, *args):
        """eliminableVariables(Equations self) -> std::set< ModelicaCasADi::Variable const * >"""
        return _modelicacasadi_wrapper.Equations_eliminableVariables(self, *args)


    def getDaeResidual(self, *args):
        """getDaeResidual(Equations self) -> MX"""
        return _modelicacasadi_wrapper.Equations_getDaeResidual(self, *args)


    def getDaeEquations(self, *args):
        """getDaeEquations(Equations self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.Equations_getDaeEquations(self, *args)


    def addDaeEquation(self, *args):
        """addDaeEquation(Equations self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)"""
        return _modelicacasadi_wrapper.Equations_addDaeEquation(self, *args)


    def addBlock(self, *args):
        """addBlock(Equations self, ModelicaCasADi::Ref< ModelicaCasADi::Block > block)"""
        return _modelicacasadi_wrapper.Equations_addBlock(self, *args)


    def isBLTEliminable(self, *args):
        """isBLTEliminable(Equations self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var) -> bool"""
        return _modelicacasadi_wrapper.Equations_isBLTEliminable(self, *args)


    def getSubstitues(self, *args):
        """
        getSubstitues(Equations self, Variable eliminable, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > & storageMap)
        getSubstitues(Equations self, std::list< std::pair< int,ModelicaCasADi::Variable const * > > const & eliminables, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > & storageMap)
        """
        return _modelicacasadi_wrapper.Equations_getSubstitues(self, *args)


    def substitute(self, *args):
        """substitute(Equations self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & substituteMap)"""
        return _modelicacasadi_wrapper.Equations_substitute(self, *args)


    def printBLT(self, *args):
        """printBLT(Equations self, std::ostream & out, bool with_details=False)"""
        return _modelicacasadi_wrapper.Equations_printBLT(self, *args)


    def getBlockIDWithSolutionOf(self, *args):
        """getBlockIDWithSolutionOf(Equations self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var) -> int"""
        return _modelicacasadi_wrapper.Equations_getBlockIDWithSolutionOf(self, *args)


    def eliminateVariables(self, *args):
        """eliminateVariables(Equations self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & substituteMap)"""
        return _modelicacasadi_wrapper.Equations_eliminateVariables(self, *args)


    def solveBlocksWithLinearSystems(self, *args):
        """solveBlocksWithLinearSystems(Equations self)"""
        return _modelicacasadi_wrapper.Equations_solveBlocksWithLinearSystems(self, *args)


    def getBlock(self, *args):
        """getBlock(Equations self, int i) -> ModelicaCasADi::Ref< ModelicaCasADi::Block >"""
        return _modelicacasadi_wrapper.Equations_getBlock(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Equations self) -> Equations
        __init__(ModelicaCasADi::Equations self, Equations other) -> Equations
        """
        this = _modelicacasadi_wrapper.new_Equations(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_Equations
    __del__ = lambda self: None
Equations_swigregister = _modelicacasadi_wrapper.Equations_swigregister
Equations_swigregister(Equations)

class FlatEquations(Equations):
    """Proxy of C++ ModelicaCasADi::FlatEquations class."""

    __swig_setmethods__ = {}
    for _s in [Equations]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlatEquations, name, value)
    __swig_getmethods__ = {}
    for _s in [Equations]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlatEquations, name)
    __repr__ = _swig_repr

    def getDaeResidual(self, *args):
        """getDaeResidual(FlatEquations self) -> MX"""
        return _modelicacasadi_wrapper.FlatEquations_getDaeResidual(self, *args)


    def getDaeEquations(self, *args):
        """getDaeEquations(FlatEquations self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.FlatEquations_getDaeEquations(self, *args)


    def addDaeEquation(self, *args):
        """addDaeEquation(FlatEquations self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)"""
        return _modelicacasadi_wrapper.FlatEquations_addDaeEquation(self, *args)


    def eliminateVariables(self, *args):
        """
        eliminateVariables(FlatEquations self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var)
        eliminateVariables(FlatEquations self, std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > > & vars)
        """
        return _modelicacasadi_wrapper.FlatEquations_eliminateVariables(self, *args)


    def addBlock(self, *args):
        """addBlock(FlatEquations self, ModelicaCasADi::Ref< ModelicaCasADi::Block > block)"""
        return _modelicacasadi_wrapper.FlatEquations_addBlock(self, *args)


    def substitute(self, *args):
        """substitute(FlatEquations self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & substituteMap)"""
        return _modelicacasadi_wrapper.FlatEquations_substitute(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::FlatEquations self) -> FlatEquations
        __init__(ModelicaCasADi::FlatEquations self, FlatEquations other) -> FlatEquations
        """
        this = _modelicacasadi_wrapper.new_FlatEquations(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_FlatEquations
    __del__ = lambda self: None
FlatEquations_swigregister = _modelicacasadi_wrapper.FlatEquations_swigregister
FlatEquations_swigregister(FlatEquations)

class BLT(Equations):
    """Proxy of C++ ModelicaCasADi::BLT class."""

    __swig_setmethods__ = {}
    for _s in [Equations]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BLT, name, value)
    __swig_getmethods__ = {}
    for _s in [Equations]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BLT, name)
    __repr__ = _swig_repr

    def hasBLT(self, *args):
        """hasBLT(BLT self) -> bool"""
        return _modelicacasadi_wrapper.BLT_hasBLT(self, *args)


    def getDaeResidual(self, *args):
        """getDaeResidual(BLT self) -> MX"""
        return _modelicacasadi_wrapper.BLT_getDaeResidual(self, *args)


    def getDaeEquations(self, *args):
        """getDaeEquations(BLT self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >"""
        return _modelicacasadi_wrapper.BLT_getDaeEquations(self, *args)


    def addDaeEquation(self, *args):
        """addDaeEquation(BLT self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)"""
        return _modelicacasadi_wrapper.BLT_addDaeEquation(self, *args)


    def addBlock(self, *args):
        """addBlock(BLT self, ModelicaCasADi::Ref< ModelicaCasADi::Block > block)"""
        return _modelicacasadi_wrapper.BLT_addBlock(self, *args)


    def getNumberOfBlocks(self, *args):
        """getNumberOfBlocks(BLT self) -> int"""
        return _modelicacasadi_wrapper.BLT_getNumberOfBlocks(self, *args)


    def getBlock(self, *args):
        """getBlock(BLT self, int i) -> ModelicaCasADi::Ref< ModelicaCasADi::Block >"""
        return _modelicacasadi_wrapper.BLT_getBlock(self, *args)


    def printBLT(self, *args):
        """printBLT(BLT self, std::ostream & out, bool with_details=False)"""
        return _modelicacasadi_wrapper.BLT_printBLT(self, *args)


    def eliminableVariables(self, *args):
        """eliminableVariables(BLT self) -> std::set< ModelicaCasADi::Variable const * >"""
        return _modelicacasadi_wrapper.BLT_eliminableVariables(self, *args)


    def getSubstitues(self, *args):
        """
        getSubstitues(BLT self, Variable eliminable, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > & storageMap)
        getSubstitues(BLT self, std::list< std::pair< int,ModelicaCasADi::Variable const * > > const & eliminables, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > & storageMap)
        """
        return _modelicacasadi_wrapper.BLT_getSubstitues(self, *args)


    def removeSolutionOfVariable(self, *args):
        """removeSolutionOfVariable(BLT self, Variable var)"""
        return _modelicacasadi_wrapper.BLT_removeSolutionOfVariable(self, *args)


    def substitute(self, *args):
        """substitute(BLT self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & substituteMap)"""
        return _modelicacasadi_wrapper.BLT_substitute(self, *args)


    def isBLTEliminable(self, *args):
        """isBLTEliminable(BLT self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var) -> bool"""
        return _modelicacasadi_wrapper.BLT_isBLTEliminable(self, *args)


    def eliminateVariables(self, *args):
        """eliminateVariables(BLT self, std::map< ModelicaCasADi::Variable const *,casadi::MX,std::less< ModelicaCasADi::Variable const * >,std::allocator< std::pair< ModelicaCasADi::Variable const *const,casadi::MX > > > const & substituteMap)"""
        return _modelicacasadi_wrapper.BLT_eliminateVariables(self, *args)


    def getBlockIDWithSolutionOf(self, *args):
        """getBlockIDWithSolutionOf(BLT self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var) -> int"""
        return _modelicacasadi_wrapper.BLT_getBlockIDWithSolutionOf(self, *args)


    def solveBlocksWithLinearSystems(self, *args):
        """solveBlocksWithLinearSystems(BLT self)"""
        return _modelicacasadi_wrapper.BLT_solveBlocksWithLinearSystems(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::BLT self) -> BLT
        __init__(ModelicaCasADi::BLT self, BLT other) -> BLT
        """
        this = _modelicacasadi_wrapper.new_BLT(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_BLT
    __del__ = lambda self: None
BLT_swigregister = _modelicacasadi_wrapper.BLT_swigregister
BLT_swigregister(BLT)

class Model(RefCountedNode):
    """

    Model represent a compiled Modelica model in CasADi interface, 
    and it mostly keeps lists with variables and equations. Model 
    provides many methods for getting/setting various properties on the model,
    and it also provides high-level functionality such as calculating
    the values of dependent parameters, or categorising variables. 
    """

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    REAL_CONSTANT = _modelicacasadi_wrapper.Model_REAL_CONSTANT
    REAL_PARAMETER_INDEPENDENT = _modelicacasadi_wrapper.Model_REAL_PARAMETER_INDEPENDENT
    REAL_PARAMETER_DEPENDENT = _modelicacasadi_wrapper.Model_REAL_PARAMETER_DEPENDENT
    INTEGER_CONSTANT = _modelicacasadi_wrapper.Model_INTEGER_CONSTANT
    INTEGER_PARAMETER_INDEPENDENT = _modelicacasadi_wrapper.Model_INTEGER_PARAMETER_INDEPENDENT
    INTEGER_PARAMETER_DEPENDENT = _modelicacasadi_wrapper.Model_INTEGER_PARAMETER_DEPENDENT
    BOOLEAN_CONSTANT = _modelicacasadi_wrapper.Model_BOOLEAN_CONSTANT
    BOOLEAN_PARAMETER_INDEPENDENT = _modelicacasadi_wrapper.Model_BOOLEAN_PARAMETER_INDEPENDENT
    BOOLEAN_PARAMETER_DEPENDENT = _modelicacasadi_wrapper.Model_BOOLEAN_PARAMETER_DEPENDENT
    STRING_CONSTANT = _modelicacasadi_wrapper.Model_STRING_CONSTANT
    STRING_PARAMETER_INDEPENDENT = _modelicacasadi_wrapper.Model_STRING_PARAMETER_INDEPENDENT
    STRING_PARAMETER_DEPENDENT = _modelicacasadi_wrapper.Model_STRING_PARAMETER_DEPENDENT
    DERIVATIVE = _modelicacasadi_wrapper.Model_DERIVATIVE
    DIFFERENTIATED = _modelicacasadi_wrapper.Model_DIFFERENTIATED
    REAL_INPUT = _modelicacasadi_wrapper.Model_REAL_INPUT
    REAL_ALGEBRAIC = _modelicacasadi_wrapper.Model_REAL_ALGEBRAIC
    REAL_DISCRETE = _modelicacasadi_wrapper.Model_REAL_DISCRETE
    INTEGER_DISCRETE = _modelicacasadi_wrapper.Model_INTEGER_DISCRETE
    INTEGER_INPUT = _modelicacasadi_wrapper.Model_INTEGER_INPUT
    BOOLEAN_DISCRETE = _modelicacasadi_wrapper.Model_BOOLEAN_DISCRETE
    BOOLEAN_INPUT = _modelicacasadi_wrapper.Model_BOOLEAN_INPUT
    STRING_DISCRETE = _modelicacasadi_wrapper.Model_STRING_DISCRETE
    STRING_INPUT = _modelicacasadi_wrapper.Model_STRING_INPUT
    NUM_OF_VARIABLE_KIND = _modelicacasadi_wrapper.Model_NUM_OF_VARIABLE_KIND

    def initializeModel(self, *args):
        """initializeModel(Model self, std::string identifier)"""
        return _modelicacasadi_wrapper.Model_initializeModel(self, *args)

    __swig_destroy__ = _modelicacasadi_wrapper.delete_Model
    __del__ = lambda self: None

    def get(self, *args):
        """
        get(Model self, std::string varName) -> double
        get(Model self, StringVector varNames) -> DVector
        """
        return _modelicacasadi_wrapper.Model_get(self, *args)


    def set(self, *args):
        """
        set(Model self, std::string varName, double value)
        set(Model self, StringVector varNames, DVector values)
        """
        return _modelicacasadi_wrapper.Model_set(self, *args)


    def setTimeVariable(self, *args):
        """
        setTimeVariable(Model self, MX timeVar)


        Sets the time variable for this Model. Note that this variable is set
        automatically when models are transferred.

        Parameters::

            MX --
                A MX


        """
        return _modelicacasadi_wrapper.Model_setTimeVariable(self, *args)


    def getTimeVariable(self, *args):
        """
        getTimeVariable(Model self) -> MX


        Returns this model's time variable. 

        Returns::

            MX --
                A MX


        """
        return _modelicacasadi_wrapper.Model_getTimeVariable(self, *args)


    def addVariable(self, *args):
        """
        addVariable(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var)


        Adds a variable to the Model. Variables are assigned a VariableType if 
        they do not have on set. 

        Parameters::

            Variable --
                A Variable


        """
        return _modelicacasadi_wrapper.Model_addVariable(self, *args)


    def addInitialEquation(self, *args):
        """
        addInitialEquation(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)


        Adds an initial equation to the Model

        Parameters::

            Equation --
                An Equation

        """
        return _modelicacasadi_wrapper.Model_addInitialEquation(self, *args)


    def addDaeEquation(self, *args):
        """
        addDaeEquation(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Equation > eq)


        Adds an equation to the Model

        Parameters::

            Equation --
                An Equation


        """
        return _modelicacasadi_wrapper.Model_addDaeEquation(self, *args)


    def setModelFunctionByItsName(self, *args):
        """
        setModelFunctionByItsName(Model self, ModelicaCasADi::Ref< ModelicaCasADi::ModelFunction > mf)


        Sets a ModelFunction in the Model. ModelFunctions must have unique names,
        and if there is one with name equal to the one passed in it is thrown away. 

        Parameters::

            ModelFunction --
                A ModelFunction


        """
        return _modelicacasadi_wrapper.Model_setModelFunctionByItsName(self, *args)


    def addNewVariableType(self, *args):
        """
        addNewVariableType(Model self, ModelicaCasADi::Ref< ModelicaCasADi::VariableType > variableType)


        Adds a new VariableType. VariableTypes are singletons and all variable 
        types must have unique names.

        Parameters::

            VariableType --
                A VariableType


        """
        return _modelicacasadi_wrapper.Model_addNewVariableType(self, *args)


    def getVariableType(self, *args):
        """
        getVariableType(Model self, std::string typeName) -> ModelicaCasADi::Ref< ModelicaCasADi::VariableType >


        Get a VariableType with a certain name in the Model.

        Parameters::

            String --
                The name of the VariableType

        Returns::

            VariableType --
                The VariableType, if present. Otherwise None

        """
        return _modelicacasadi_wrapper.Model_getVariableType(self, *args)


    def getVariables(self, *args):
        """
        getVariables(Model self, ModelicaCasADi::Model::VariableKind kind) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a numpy array with all Variables of a certain kind, as specified in the Model.

        Parameters::

            VariableKind --
                A VariableKind, e.g. Model.DERIVATIVE

        Returns::

            numpy.array(Variable) --
                A numpy array with zero or more Variables. 


        """
        return _modelicacasadi_wrapper.Model_getVariables(self, *args)


    def getAllVariables(self, *args):
        """
        getAllVariables(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a numpy array with all Variables present in the Model. 

        Returns::

            numpy.array(Variable) --
                A numpy array with zero or more Variables. 


        """
        return _modelicacasadi_wrapper.Model_getAllVariables(self, *args)


    def getModelVariables(self, *args):
        """
        getModelVariables(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a numpy array with all model variables, i.e. that have not been 
        alias eliminated, present in the Model.  

        Returns::

            numpy.array(Variable) --
                A numpy array with zero or more Variables. 


        """
        return _modelicacasadi_wrapper.Model_getModelVariables(self, *args)


    def getAliases(self, *args):
        """
        getAliases(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a numpy array with all alias variables present in the Model. 

        Returns::

            numpy.array(Variable) --
                A numpy array with zero or more Variables. 


        """
        return _modelicacasadi_wrapper.Model_getAliases(self, *args)


    def getVariable(self, *args):
        """
        getVariable(Model self, std::string name) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable >


        Returns the Variable with the provided name. If there is no 
        variable with that name present in the Model None is returned.

        This method does not discriminate between alias variables and 
        an alias variable may be returned.

        Parameters::

            String --
                String name of a Variable

        Returns::

            Variable --
                The Variable with the provided name or None


        """
        return _modelicacasadi_wrapper.Model_getVariable(self, *args)


    def getModelVariable(self, *args):
        """
        getModelVariable(Model self, std::string name) -> ModelicaCasADi::Ref< ModelicaCasADi::Variable >


        Returns the Variable with the provided name. If there is no 
        variable with that name present in the Model None is returned.

        This method does discriminate between alias variables, and if the
        provided name is an alias variable its alias is returned instead. 

        Parameters::

            String --
                String name of a Variable

        Returns::

            Variable --
                The Variable with the provided name or its alias, or None


        """
        return _modelicacasadi_wrapper.Model_getModelVariable(self, *args)


    def calculateValuesForDependentParameters(self, *args):
        """
        calculateValuesForDependentParameters(Model self)


        Calculates the value of all dependent parameters. The calculated value is 
        set in the attribute evaluatedBindingExpression for dependent parameters. 


        """
        return _modelicacasadi_wrapper.Model_calculateValuesForDependentParameters(self, *args)


    def evaluateExpression(self, *args):
        """
        evaluateExpression(Model self, MX exp) -> double


        Calculates the value of the supplied expression. Assumes that the 
        MX in the expression are either parameters or constants present
        in the Model.

        Parameters::

            MX --
                A MX expression. 

        Returns::

            Double --
                The value of the evaluated expression


        """
        return _modelicacasadi_wrapper.Model_evaluateExpression(self, *args)


    def getInitialResidual(self, *args):
        """
        getInitialResidual(Model self) -> MX


        Returns all initial equations in a stacked MX on the form: lhs - rhs.

        Returns::

            MX --
                A MX with the possibly stacked initial equations.


        """
        return _modelicacasadi_wrapper.Model_getInitialResidual(self, *args)


    def getDaeResidual(self, *args):
        """
        getDaeResidual(Model self) -> MX


        Returns all DAE equations in a stacked MX on the form: lhs - rhs.

        Returns::

            MX --
                A MX with the possibly stacked DAE equations.


        """
        return _modelicacasadi_wrapper.Model_getDaeResidual(self, *args)


    def getDaeEquations(self, *args):
        """
        getDaeEquations(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >


        Returns a vector of all DAE equations, given by the Equation objects that represent them.

        Returns::

            ndarray --
                A vector of Equation objects with the Model's DAE equations.


        """
        return _modelicacasadi_wrapper.Model_getDaeEquations(self, *args)


    def getInitialEquations(self, *args):
        """
        getInitialEquations(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Equation >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Equation > > >


        Returns a vector of all initial equations, given by the Equation objects that represent them.

        Returns::

            ndarray --
                A vector of Equation objects with the Model's initial equations.


        """
        return _modelicacasadi_wrapper.Model_getInitialEquations(self, *args)


    def getModelFunction(self, *args):
        """
        getModelFunction(Model self, std::string name) -> ModelicaCasADi::Ref< ModelicaCasADi::ModelFunction >


        Retrieves a ModelFunction with a certain name. 

        Parameters::

            String --
                The name of the ModelFunction

        Returns::

            ModelFunction --
                The ModelFunction, or None if there is no ModelFunction with that name in the Model.


        """
        return _modelicacasadi_wrapper.Model_getModelFunction(self, *args)


    def getIdentifier(self, *args):
        """
        getIdentifier(Model self) -> std::string


        Returns Model identifier, typically <packagename>_<classname>

        Returns::

            String --
                Model identifier

        """
        return _modelicacasadi_wrapper.Model_getIdentifier(self, *args)


    def print_(self, *args):
        """print_(Model self, std::ostream & os)"""
        return _modelicacasadi_wrapper.Model_print_(self, *args)


    def getEliminableVariables(self, *args):
        """
        getEliminableVariables(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a vector of all eliminable variables of a Model. A variable is 
        considered eliminable if has a symbolic solution in the BLT and does not 
        have bounds, alias variables, or timed points.

        Returns::

            ndarray --
                A vector of Variable objects.


        """
        return _modelicacasadi_wrapper.Model_getEliminableVariables(self, *args)


    def substituteAllEliminables(self, *args):
        """
        substituteAllEliminables(Model self)


        Substitute all variables that are consider eliminable according to BLT. Model expressions are symbolically
        manipulated to replace the eliminable variables for its corresponding solution.


        """
        return _modelicacasadi_wrapper.Model_substituteAllEliminables(self, *args)


    def eliminateAlgebraics(self, *args):
        """
        eliminateAlgebraics(Model self)


        Eliminate all algebraic variables that are consider eliminable according to BLT information.
        The elimination of variables must be invoqued only once. If variables have been eliminated already,
        further eliminations wont be done.


        """
        return _modelicacasadi_wrapper.Model_eliminateAlgebraics(self, *args)


    def eliminateVariables(self, *args):
        """
        eliminateVariables(Model self)


        Eliminate all variables that were marked for elimination. The elimination of
        variables must be invoqued only once. If variables have been eliminated already,
        further eliminations wont be done.


        """
        return _modelicacasadi_wrapper.Model_eliminateVariables(self, *args)


    def getEliminatedVariables(self, *args):
        """
        getEliminatedVariables(Model self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > >


        Returns a vector of all eliminated variables of a Model.

        Returns::

            ndarray --
                A vector of Variable objects.


        """
        return _modelicacasadi_wrapper.Model_getEliminatedVariables(self, *args)


    def setDirty(self, *args):
        """setDirty(Model self)"""
        return _modelicacasadi_wrapper.Model_setDirty(self, *args)


    def hasBLT(self, *args):
        """hasBLT(Model self) -> bool"""
        return _modelicacasadi_wrapper.Model_hasBLT(self, *args)


    def setEquations(self, *args):
        """setEquations(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Equations > eqCont)"""
        return _modelicacasadi_wrapper.Model_setEquations(self, *args)


    def markVariablesForElimination(self, *args):
        """
        markVariablesForElimination(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var)
        markVariablesForElimination(Model self, std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > > const & vars)


        Append variables to a list of variables pending for elimination 

        Parameters::

            numpy.array(Variable) --
                A numpy array with zero or more Variables.


        """
        return _modelicacasadi_wrapper.Model_markVariablesForElimination(self, *args)


    def getSolutionOfEliminatedVariable(self, *args):
        """
        getSolutionOfEliminatedVariable(Model self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var) -> MX


        Retrive the symbolic solution of an eliminated variables 

        Parameters::

            Variable --
                A model variable.

        Returns::
            MX --
                A MX with the eliminated variable solution


        """
        return _modelicacasadi_wrapper.Model_getSolutionOfEliminatedVariable(self, *args)


    def solveLinearSystemsInBLT(self, *args):
        """
        solveLinearSystemsInBLT(Model self)


        Experimental method still under development. Solves all linear blocks in BLT. After linear blocks have been
        solved, the list of eliminable variables is updated so that the newly solved variables can be eliminated. 
        This method is still under testing.


        """
        return _modelicacasadi_wrapper.Model_solveLinearSystemsInBLT(self, *args)


    def __repr__(self, *args):
        """__repr__(Model self) -> std::string"""
        return _modelicacasadi_wrapper.Model___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::Model self) -> Model
        __init__(ModelicaCasADi::Model self, Model other) -> Model


        Creates a Model with the specified identifier. 
        If no identifier is supplied default identifier 
        is an empty string. 

        Parameters::

            String --
                Identfier, typically <packagename>_<classname>

        """
        this = _modelicacasadi_wrapper.new_Model(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
Model_swigregister = _modelicacasadi_wrapper.Model_swigregister
Model_swigregister(Model)

class OptimizationProblem(Model):
    """

    OptimizationProblem represents an Optimica optimization problem. 
    OptimizationProblem is a subclass Model and provides some
    additional information such as constraints, timed variables, Lagrange
    and Mayer terms. 
    """

    __swig_setmethods__ = {}
    for _s in [Model]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptimizationProblem, name, value)
    __swig_getmethods__ = {}
    for _s in [Model]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OptimizationProblem, name)
    __swig_destroy__ = _modelicacasadi_wrapper.delete_OptimizationProblem
    __del__ = lambda self: None

    def initializeProblem(self, *args):
        """initializeProblem(OptimizationProblem self, std::string identifier, bool normalizedTime=False)"""
        return _modelicacasadi_wrapper.OptimizationProblem_initializeProblem(self, *args)


    def getStartTime(self, *args):
        """
        getStartTime(OptimizationProblem self) -> MX


        Returns the start time

        Returns::

            MX --
                The start time


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getStartTime(self, *args)


    def getFinalTime(self, *args):
        """
        getFinalTime(OptimizationProblem self) -> MX


        Returns the final time

        Returns::

            MX --
                The final time


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getFinalTime(self, *args)


    def getNormalizedTimeFlag(self, *args):
        """
        getNormalizedTimeFlag(OptimizationProblem self) -> bool


        Returns a flag telling whether minumum time normalisation has been performed.

        Returns::

            bool --


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getNormalizedTimeFlag(self, *args)


    def getPathConstraints(self, *args):
        """
        getPathConstraints(OptimizationProblem self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Constraint >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Constraint > > >


        Returns the path constraints

        Returns::

            numpy.array(Constraint) --
                A numpy array with the path constraints


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getPathConstraints(self, *args)


    def getPointConstraints(self, *args):
        """
        getPointConstraints(OptimizationProblem self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Constraint >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Constraint > > >


        Returns the point constraints

        Returns::

            numpy.array(Constraint) --
                A numpy array with the point constraints


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getPointConstraints(self, *args)


    def getTimedVariables(self, *args):
        """
        getTimedVariables(OptimizationProblem self) -> std::vector< ModelicaCasADi::Ref< ModelicaCasADi::TimedVariable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::TimedVariable > > >


        Returns the timed variable

        Returns::

            numpy.array(TimedVariable) --
                A numpy array with the timed variables


        """
        return _modelicacasadi_wrapper.OptimizationProblem_getTimedVariables(self, *args)


    def getObjectiveIntegrand(self, *args):
        """getObjectiveIntegrand(OptimizationProblem self) -> MX"""
        return _modelicacasadi_wrapper.OptimizationProblem_getObjectiveIntegrand(self, *args)


    def getObjective(self, *args):
        """getObjective(OptimizationProblem self) -> MX"""
        return _modelicacasadi_wrapper.OptimizationProblem_getObjective(self, *args)


    def setStartTime(self, *args):
        """
        setStartTime(OptimizationProblem self, MX startTime)


        Sets the start time

        Parameters::

            MX --
                The start time to be set.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_setStartTime(self, *args)


    def setFinalTime(self, *args):
        """
        setFinalTime(OptimizationProblem self, MX finalTime)


        Sets the final time

        Parameters::

            MX --
                The final time to be set.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_setFinalTime(self, *args)


    def setPathConstraints(self, *args):
        """setPathConstraints(OptimizationProblem self, std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Constraint >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Constraint > > > const & pathConstraints)"""
        return _modelicacasadi_wrapper.OptimizationProblem_setPathConstraints(self, *args)


    def setPointConstraints(self, *args):
        """setPointConstraints(OptimizationProblem self, std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Constraint >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Constraint > > > const & pointConstraints)"""
        return _modelicacasadi_wrapper.OptimizationProblem_setPointConstraints(self, *args)


    def setObjectiveIntegrand(self, *args):
        """setObjectiveIntegrand(OptimizationProblem self, MX objectiveIntegrand)"""
        return _modelicacasadi_wrapper.OptimizationProblem_setObjectiveIntegrand(self, *args)


    def setObjective(self, *args):
        """setObjective(OptimizationProblem self, MX objective)"""
        return _modelicacasadi_wrapper.OptimizationProblem_setObjective(self, *args)


    def addTimedVariable(self, *args):
        """addTimedVariable(OptimizationProblem self, ModelicaCasADi::Ref< ModelicaCasADi::TimedVariable > timedVariable)"""
        return _modelicacasadi_wrapper.OptimizationProblem_addTimedVariable(self, *args)


    def print_(self, *args):
        """print_(OptimizationProblem self, std::ostream & os)"""
        return _modelicacasadi_wrapper.OptimizationProblem_print_(self, *args)


    def eliminateAlgebraics(self, *args):
        """
        eliminateAlgebraics(OptimizationProblem self)


        Eliminate all algebraic variables that are consider eliminable according to BLT information.
        The elimination of variables must be invoqued only once. If variables have been eliminated already,
        further eliminations wont be done.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_eliminateAlgebraics(self, *args)


    def eliminateVariables(self, *args):
        """
        eliminateVariables(OptimizationProblem self)


        Eliminate all variables that were marked for elimination. The elimination of
        variables must be invoqued only once. If variables have been eliminated already,
        further eliminations wont be done.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_eliminateVariables(self, *args)


    def substituteAllEliminables(self, *args):
        """
        substituteAllEliminables(OptimizationProblem self)


        Substitute all variables that are consider eliminable according to BLT. Model expressions are symbolically
        manipulated to replace the eliminable variables for its corresponding solution.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_substituteAllEliminables(self, *args)


    def setEquations(self, *args):
        """setEquations(OptimizationProblem self, ModelicaCasADi::Ref< ModelicaCasADi::Equations > eqCont)"""
        return _modelicacasadi_wrapper.OptimizationProblem_setEquations(self, *args)


    def markVariablesForElimination(self, *args):
        """
        markVariablesForElimination(OptimizationProblem self, ModelicaCasADi::Ref< ModelicaCasADi::Variable > var)
        markVariablesForElimination(OptimizationProblem self, std::vector< ModelicaCasADi::Ref< ModelicaCasADi::Variable >,std::allocator< ModelicaCasADi::Ref< ModelicaCasADi::Variable > > > const & vars)


        Append variables to a list of variables pending for elimination 

        Parameters::

            numpy.array(Variable) --
                A numpy array with zero or more Variables.


        """
        return _modelicacasadi_wrapper.OptimizationProblem_markVariablesForElimination(self, *args)


    def printPyomoModel(self, *args):
        """printPyomoModel(OptimizationProblem self, std::string const & modelName)"""
        return _modelicacasadi_wrapper.OptimizationProblem_printPyomoModel(self, *args)


    def __repr__(self, *args):
        """__repr__(OptimizationProblem self) -> std::string"""
        return _modelicacasadi_wrapper.OptimizationProblem___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::OptimizationProblem self) -> OptimizationProblem
        __init__(ModelicaCasADi::OptimizationProblem self, OptimizationProblem other) -> OptimizationProblem


        Create an OptimizationProblem, takes two optional arguments. 

        Parameters::

            string --
                An optional model identfier, default is empty string.

            bool --
                 An option flag telling whether minumum time normalisation
                 has been performed (by the compiler). Default is true.


        """
        this = _modelicacasadi_wrapper.new_OptimizationProblem(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
OptimizationProblem_swigregister = _modelicacasadi_wrapper.OptimizationProblem_swigregister
OptimizationProblem_swigregister(OptimizationProblem)


def setUpJVM(*args):
    """setUpJVM()"""
    return _modelicacasadi_wrapper.setUpJVM(*args)

def tearDownJVM(*args):
    """tearDownJVM()"""
    return _modelicacasadi_wrapper.tearDownJVM(*args)

def getBaseTypeForDerivedType(*args):
    """getBaseTypeForDerivedType(ModelicaCasADi::Ref< ModelicaCasADi::Model > m, std::string baseTypeName) -> ModelicaCasADi::Ref< ModelicaCasADi::PrimitiveType >"""
    return _modelicacasadi_wrapper.getBaseTypeForDerivedType(*args)
class ModelicaOptionsWrapper(RefCountedNode):
    """Proxy of C++ ModelicaCasADi::ModelicaOptionsWrapper class."""

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelicaOptionsWrapper, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelicaOptionsWrapper, name)

    def setStringOption(self, *args):
        """setStringOption(ModelicaOptionsWrapper self, std::string opt, std::string val)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_setStringOption(self, *args)


    def setBooleanOption(self, *args):
        """setBooleanOption(ModelicaOptionsWrapper self, std::string opt, bool val)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_setBooleanOption(self, *args)


    def setIntegerOption(self, *args):
        """setIntegerOption(ModelicaOptionsWrapper self, std::string opt, int val)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_setIntegerOption(self, *args)


    def setRealOption(self, *args):
        """setRealOption(ModelicaOptionsWrapper self, std::string opt, double val)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_setRealOption(self, *args)


    def getBooleanOption(self, *args):
        """getBooleanOption(ModelicaOptionsWrapper self, std::string opt) -> bool"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_getBooleanOption(self, *args)


    def printCompilerOptions(self, *args):
        """printCompilerOptions(ModelicaOptionsWrapper self, std::ostream & out)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_printCompilerOptions(self, *args)


    def printOpts(self, *args):
        """printOpts(ModelicaOptionsWrapper self)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_printOpts(self, *args)


    def getOptionRegistry(self, *args):
        """getOptionRegistry(ModelicaOptionsWrapper self) -> org::jmodelica::modelica::compiler::generated::OptionRegistry"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_getOptionRegistry(self, *args)


    def print_(self, *args):
        """print_(ModelicaOptionsWrapper self, std::ostream & os)"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(ModelicaOptionsWrapper self) -> std::string"""
        return _modelicacasadi_wrapper.ModelicaOptionsWrapper___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::ModelicaOptionsWrapper self) -> ModelicaOptionsWrapper
        __init__(ModelicaCasADi::ModelicaOptionsWrapper self, ModelicaOptionsWrapper other) -> ModelicaOptionsWrapper
        """
        this = _modelicacasadi_wrapper.new_ModelicaOptionsWrapper(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_ModelicaOptionsWrapper
    __del__ = lambda self: None
ModelicaOptionsWrapper_swigregister = _modelicacasadi_wrapper.ModelicaOptionsWrapper_swigregister
ModelicaOptionsWrapper_swigregister(ModelicaOptionsWrapper)

class OptimicaOptionsWrapper(RefCountedNode):
    """Proxy of C++ ModelicaCasADi::OptimicaOptionsWrapper class."""

    __swig_setmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptimicaOptionsWrapper, name, value)
    __swig_getmethods__ = {}
    for _s in [RefCountedNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OptimicaOptionsWrapper, name)

    def setStringOption(self, *args):
        """setStringOption(OptimicaOptionsWrapper self, std::string opt, std::string val)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_setStringOption(self, *args)


    def setBooleanOption(self, *args):
        """setBooleanOption(OptimicaOptionsWrapper self, std::string opt, bool val)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_setBooleanOption(self, *args)


    def setIntegerOption(self, *args):
        """setIntegerOption(OptimicaOptionsWrapper self, std::string opt, int val)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_setIntegerOption(self, *args)


    def setRealOption(self, *args):
        """setRealOption(OptimicaOptionsWrapper self, std::string opt, double val)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_setRealOption(self, *args)


    def getBooleanOption(self, *args):
        """getBooleanOption(OptimicaOptionsWrapper self, std::string opt) -> bool"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_getBooleanOption(self, *args)


    def printCompilerOptions(self, *args):
        """printCompilerOptions(OptimicaOptionsWrapper self, std::ostream & out)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_printCompilerOptions(self, *args)


    def printOpts(self, *args):
        """printOpts(OptimicaOptionsWrapper self)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_printOpts(self, *args)


    def getOptionRegistry(self, *args):
        """getOptionRegistry(OptimicaOptionsWrapper self) -> org::jmodelica::optimica::compiler::generated::OptionRegistry"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_getOptionRegistry(self, *args)


    def print_(self, *args):
        """print_(OptimicaOptionsWrapper self, std::ostream & os)"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper_print_(self, *args)


    def __repr__(self, *args):
        """__repr__(OptimicaOptionsWrapper self) -> std::string"""
        return _modelicacasadi_wrapper.OptimicaOptionsWrapper___repr__(self, *args)


    def __init__(self, *args):
        """
        __init__(ModelicaCasADi::OptimicaOptionsWrapper self) -> OptimicaOptionsWrapper
        __init__(ModelicaCasADi::OptimicaOptionsWrapper self, OptimicaOptionsWrapper other) -> OptimicaOptionsWrapper
        """
        this = _modelicacasadi_wrapper.new_OptimicaOptionsWrapper(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _modelicacasadi_wrapper.delete_OptimicaOptionsWrapper
    __del__ = lambda self: None
OptimicaOptionsWrapper_swigregister = _modelicacasadi_wrapper.OptimicaOptionsWrapper_swigregister
OptimicaOptionsWrapper_swigregister(OptimicaOptionsWrapper)


def transferModelFromModelicaCompiler(*args):
    """transferModelFromModelicaCompiler(ModelicaCasADi::Ref< ModelicaCasADi::Model > m, std::string modelName, StringVector modelFiles, ModelicaCasADi::Ref< ModelicaCasADi::ModelicaOptionsWrapper > options, std::string log_level)"""
    return _modelicacasadi_wrapper.transferModelFromModelicaCompiler(*args)

def transferModelFromOptimicaCompiler(*args):
    """transferModelFromOptimicaCompiler(ModelicaCasADi::Ref< ModelicaCasADi::Model > m, std::string modelName, StringVector modelFiles, ModelicaCasADi::Ref< ModelicaCasADi::OptimicaOptionsWrapper > options, std::string log_level)"""
    return _modelicacasadi_wrapper.transferModelFromOptimicaCompiler(*args)

def _transferOptimizationProblem(*args):
    """
    _transferOptimizationProblem(ModelicaCasADi::Ref< ModelicaCasADi::OptimizationProblem > optProblem, std::string modelName, StringVector modelFiles, ModelicaCasADi::Ref< ModelicaCasADi::OptimicaOptionsWrapper > options, std::string log_level)


    Transfers the specified optimization problem.

    Parameters::

        string --
            The name of the optimization problem

        string --
            The file that contains the optimization problem

        OptionRegistry --
            An OptionRegistry for passing compiler options to the JModelica compiler.
            Currently not accessible from Python. 

    Returns::

        OptimizationProblem --
            The transferred optimization problem


    """
    return _modelicacasadi_wrapper._transferOptimizationProblem(*args)
# This file is compatible with both classic and new-style classes.


