# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_casadi_core', [dirname(__file__)])
        except ImportError:
            import _casadi_core
            return _casadi_core
        if fp is not None:
            try:
                _mod = imp.load_module('_casadi_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _casadi_core = swig_import_helper()
    del swig_import_helper
else:
    import _casadi_core
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0




class _copyableObject(_object):
  def __copy__(self):
    return self.__class__(self)

  def __deepcopy__(self,dummy=None):
    shallow = self.__class__(self)
    if hasattr(self,'makeUnique'):
      shallow.makeUnique()
    return shallow

_object = _copyableObject

_swig_repr_default = _swig_repr
def _swig_repr(self):
  if hasattr(self,'getRepresentation'):
    return self.getRepresentation()
  else:
    return _swig_repr_default(self)


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi_core.delete_SwigPyIterator

    def value(self, *args):
        """value(SwigPyIterator self) -> PyObject *"""
        return _casadi_core.SwigPyIterator_value(self, *args)


    def incr(self, *args):
        """incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator_incr(self, *args)


    def decr(self, *args):
        """decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator_decr(self, *args)


    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _casadi_core.SwigPyIterator_distance(self, *args)


    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi_core.SwigPyIterator_equal(self, *args)


    def copy(self, *args):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator_copy(self, *args)


    def next(self, *args):
        """next(SwigPyIterator self) -> PyObject *"""
        return _casadi_core.SwigPyIterator_next(self, *args)


    def __next__(self, *args):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _casadi_core.SwigPyIterator___next__(self, *args)


    def previous(self, *args):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _casadi_core.SwigPyIterator_previous(self, *args)


    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator_advance(self, *args)


    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi_core.SwigPyIterator___eq__(self, *args)


    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi_core.SwigPyIterator___ne__(self, *args)


    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator___iadd__(self, *args)


    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator___isub__(self, *args)


    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi_core.SwigPyIterator___add__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _casadi_core.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _casadi_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> StringVector
        __init__(std::vector<(std::string)> self, StringVector other) -> StringVector
        """
        this = _casadi_core.new_StringVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_StringVector
StringVector_swigregister = _casadi_core.StringVector_swigregister
StringVector_swigregister(StringVector)

class BVector(_object):
    """Proxy of C++ std::vector<(bool)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(bool)> self) -> BVector
        __init__(std::vector<(bool)> self, BVector other) -> BVector
        """
        this = _casadi_core.new_BVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_BVector
BVector_swigregister = _casadi_core.BVector_swigregister
BVector_swigregister(BVector)

class BVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(bool)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(bool)>)> self) -> BVectorVector
        __init__(std::vector<(std::vector<(bool)>)> self, BVectorVector other) -> BVectorVector
        """
        this = _casadi_core.new_BVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_BVectorVector
BVectorVector_swigregister = _casadi_core.BVectorVector_swigregister
BVectorVector_swigregister(BVectorVector)

class BVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(bool)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BVectorVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(bool)>)>)> self) -> BVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(bool)>)>)> self, BVectorVectorVector other) -> BVectorVectorVector
        """
        this = _casadi_core.new_BVectorVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_BVectorVectorVector
BVectorVectorVector_swigregister = _casadi_core.BVectorVectorVector_swigregister
BVectorVectorVector_swigregister(BVectorVectorVector)

class UCharVector(_object):
    """Proxy of C++ std::vector<(unsigned char)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UCharVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UCharVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned char)> self) -> UCharVector
        __init__(std::vector<(unsigned char)> self, UCharVector other) -> UCharVector
        """
        this = _casadi_core.new_UCharVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_UCharVector
UCharVector_swigregister = _casadi_core.UCharVector_swigregister
UCharVector_swigregister(UCharVector)

class IVector(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVector, name)

    def __repr__(self, *args):
        """__repr__(IVector self) -> std::string"""
        return _casadi_core.IVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(IVector self) -> std::string"""
        return _casadi_core.IVector___str__(self, *args)


    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)



    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> IVector
        __init__(std::vector<(int)> self, IVector other) -> IVector
        """
        this = _casadi_core.new_IVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IVector
IVector_swigregister = _casadi_core.IVector_swigregister
IVector_swigregister(IVector)

class IVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(int)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(int)>)> self) -> IVectorVector
        __init__(std::vector<(std::vector<(int)>)> self, IVectorVector other) -> IVectorVector
        """
        this = _casadi_core.new_IVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IVectorVector
IVectorVector_swigregister = _casadi_core.IVectorVector_swigregister
IVectorVector_swigregister(IVectorVector)

class IVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(int)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(int)>)>)> self) -> IVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(int)>)>)> self, IVectorVectorVector other) -> IVectorVectorVector
        """
        this = _casadi_core.new_IVectorVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IVectorVectorVector
IVectorVectorVector_swigregister = _casadi_core.IVectorVectorVector_swigregister
IVectorVectorVector_swigregister(IVectorVectorVector)

class DVector(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DVector, name)

    def __repr__(self, *args):
        """__repr__(DVector self) -> std::string"""
        return _casadi_core.DVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(DVector self) -> std::string"""
        return _casadi_core.DVector___str__(self, *args)


    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)



    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> DVector
        __init__(std::vector<(double)> self, DVector other) -> DVector
        """
        this = _casadi_core.new_DVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DVector
DVector_swigregister = _casadi_core.DVector_swigregister
DVector_swigregister(DVector)

class DVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> DVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, DVectorVector other) -> DVectorVector
        """
        this = _casadi_core.new_DVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DVectorVector
DVectorVector_swigregister = _casadi_core.DVectorVector_swigregister
DVectorVector_swigregister(DVectorVector)

class DVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(double)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DVectorVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self) -> DVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, DVectorVectorVector other) -> DVectorVectorVector
        """
        this = _casadi_core.new_DVectorVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DVectorVectorVector
DVectorVectorVector_swigregister = _casadi_core.DVectorVectorVector_swigregister
DVectorVectorVector_swigregister(DVectorVectorVector)

class Pair_Int_Int(_object):
    """Proxy of C++ std::pair<(int,int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_Int_Int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_Int_Int, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(int,int)> self) -> Pair_Int_Int
        __init__(std::pair<(int,int)> self, int first, int second) -> Pair_Int_Int
        __init__(std::pair<(int,int)> self, Pair_Int_Int p) -> Pair_Int_Int
        """
        this = _casadi_core.new_Pair_Int_Int(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_Int_Int_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_Int_Int_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_Int_Int_first_get, _casadi_core.Pair_Int_Int_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_Int_Int_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_Int_Int_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_Int_Int_second_get, _casadi_core.Pair_Int_Int_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_Int_Int
Pair_Int_Int_swigregister = _casadi_core.Pair_Int_Int_swigregister
Pair_Int_Int_swigregister(Pair_Int_Int)

class VectorPair_Int_Int(_object):
    """Proxy of C++ std::vector<(std::pair<(int,int)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPair_Int_Int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPair_Int_Int, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::pair<(int,int)>)> self) -> VectorPair_Int_Int
        __init__(std::vector<(std::pair<(int,int)>)> self, VectorPair_Int_Int other) -> VectorPair_Int_Int
        """
        this = _casadi_core.new_VectorPair_Int_Int(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_VectorPair_Int_Int
VectorPair_Int_Int_swigregister = _casadi_core.VectorPair_Int_Int_swigregister
VectorPair_Int_Int_swigregister(VectorPair_Int_Int)


def istype(*args):
    """istype(PyObject * p, swig_type_info * type) -> bool"""
    return _casadi_core.istype(*args)

def PySetParent(*args):
    """PySetParent(PyObject * arg1, PyObject * parent)"""
    return _casadi_core.PySetParent(*args)

def PyDECREFParent(*args):
    """PyDECREFParent(PyObject * arg1)"""
    return _casadi_core.PyDECREFParent(*args)

def PyObjectHasClassName(*args):
    """PyObjectHasClassName(PyObject * p, char const * name) -> bool"""
    return _casadi_core.PyObjectHasClassName(*args)

def PyIsSequence(*args):
    """PyIsSequence(PyObject * p) -> bool"""
    return _casadi_core.PyIsSequence(*args)

_casadi_core.PRECEDENCE_IVector_swigconstant(_casadi_core)
PRECEDENCE_IVector = _casadi_core.PRECEDENCE_IVector

_casadi_core.PRECEDENCE_PAIR_SLICE_SLICE_swigconstant(_casadi_core)
PRECEDENCE_PAIR_SLICE_SLICE = _casadi_core.PRECEDENCE_PAIR_SLICE_SLICE

_casadi_core.PRECEDENCE_SLICE_swigconstant(_casadi_core)
PRECEDENCE_SLICE = _casadi_core.PRECEDENCE_SLICE

_casadi_core.PRECEDENCE_IndexVector_swigconstant(_casadi_core)
PRECEDENCE_IndexVector = _casadi_core.PRECEDENCE_IndexVector

_casadi_core.PRECEDENCE_PAIR_IVector_IVector_swigconstant(_casadi_core)
PRECEDENCE_PAIR_IVector_IVector = _casadi_core.PRECEDENCE_PAIR_IVector_IVector

_casadi_core.PRECEDENCE_IMatrix_swigconstant(_casadi_core)
PRECEDENCE_IMatrix = _casadi_core.PRECEDENCE_IMatrix

_casadi_core.PRECEDENCE_IMatrixVector_swigconstant(_casadi_core)
PRECEDENCE_IMatrixVector = _casadi_core.PRECEDENCE_IMatrixVector

_casadi_core.PRECEDENCE_IMatrixVectorVector_swigconstant(_casadi_core)
PRECEDENCE_IMatrixVectorVector = _casadi_core.PRECEDENCE_IMatrixVectorVector

_casadi_core.PRECEDENCE_DVector_swigconstant(_casadi_core)
PRECEDENCE_DVector = _casadi_core.PRECEDENCE_DVector

_casadi_core.PRECEDENCE_DMatrix_swigconstant(_casadi_core)
PRECEDENCE_DMatrix = _casadi_core.PRECEDENCE_DMatrix

_casadi_core.PRECEDENCE_DMatrixVector_swigconstant(_casadi_core)
PRECEDENCE_DMatrixVector = _casadi_core.PRECEDENCE_DMatrixVector

_casadi_core.PRECEDENCE_DMatrixVectorVector_swigconstant(_casadi_core)
PRECEDENCE_DMatrixVectorVector = _casadi_core.PRECEDENCE_DMatrixVectorVector

_casadi_core.PRECEDENCE_SX_swigconstant(_casadi_core)
PRECEDENCE_SX = _casadi_core.PRECEDENCE_SX

_casadi_core.PRECEDENCE_SXElement_swigconstant(_casadi_core)
PRECEDENCE_SXElement = _casadi_core.PRECEDENCE_SXElement

_casadi_core.PRECEDENCE_SXVector_swigconstant(_casadi_core)
PRECEDENCE_SXVector = _casadi_core.PRECEDENCE_SXVector

_casadi_core.PRECEDENCE_SXVectorVector_swigconstant(_casadi_core)
PRECEDENCE_SXVectorVector = _casadi_core.PRECEDENCE_SXVectorVector

_casadi_core.PRECEDENCE_SXElementVector_swigconstant(_casadi_core)
PRECEDENCE_SXElementVector = _casadi_core.PRECEDENCE_SXElementVector

_casadi_core.PRECEDENCE_SXElementVectorVector_swigconstant(_casadi_core)
PRECEDENCE_SXElementVectorVector = _casadi_core.PRECEDENCE_SXElementVectorVector

_casadi_core.PRECEDENCE_MX_swigconstant(_casadi_core)
PRECEDENCE_MX = _casadi_core.PRECEDENCE_MX

_casadi_core.PRECEDENCE_MXVector_swigconstant(_casadi_core)
PRECEDENCE_MXVector = _casadi_core.PRECEDENCE_MXVector

_casadi_core.PRECEDENCE_MXVectorVector_swigconstant(_casadi_core)
PRECEDENCE_MXVectorVector = _casadi_core.PRECEDENCE_MXVectorVector

_casadi_core.PRECEDENCE_CREATOR_swigconstant(_casadi_core)
PRECEDENCE_CREATOR = _casadi_core.PRECEDENCE_CREATOR

_casadi_core.PRECEDENCE_DERIVATIVEGENERATOR_swigconstant(_casadi_core)
PRECEDENCE_DERIVATIVEGENERATOR = _casadi_core.PRECEDENCE_DERIVATIVEGENERATOR

_casadi_core.PRECEDENCE_CUSTOMEVALUATE_swigconstant(_casadi_core)
PRECEDENCE_CUSTOMEVALUATE = _casadi_core.PRECEDENCE_CUSTOMEVALUATE

_casadi_core.PRECEDENCE_CALLBACK_swigconstant(_casadi_core)
PRECEDENCE_CALLBACK = _casadi_core.PRECEDENCE_CALLBACK

_casadi_core.PRECEDENCE_GENERICTYPE_swigconstant(_casadi_core)
PRECEDENCE_GENERICTYPE = _casadi_core.PRECEDENCE_GENERICTYPE

_casadi_core.PRECEDENCE_DICTIONARY_swigconstant(_casadi_core)
PRECEDENCE_DICTIONARY = _casadi_core.PRECEDENCE_DICTIONARY
class SXElementVector(_object):
    """Proxy of C++ std::vector<(casadi::SXElement)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElementVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXElementVector, name)

    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)



    def __repr__(self, *args):
        """__repr__(SXElementVector self) -> std::string"""
        return _casadi_core.SXElementVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(SXElementVector self) -> std::string"""
        return _casadi_core.SXElementVector___str__(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::SXElement)> self) -> SXElementVector
        __init__(std::vector<(casadi::SXElement)> self, SXElementVector other) -> SXElementVector
        """
        this = _casadi_core.new_SXElementVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXElementVector
SXElementVector_swigregister = _casadi_core.SXElementVector_swigregister
SXElementVector_swigregister(SXElementVector)

class SparsityVector(_object):
    """Proxy of C++ std::vector<(casadi::Sparsity)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparsityVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparsityVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Sparsity)> self) -> SparsityVector
        __init__(std::vector<(casadi::Sparsity)> self, SparsityVector other) -> SparsityVector
        """
        this = _casadi_core.new_SparsityVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SparsityVector
SparsityVector_swigregister = _casadi_core.SparsityVector_swigregister
SparsityVector_swigregister(SparsityVector)

class SparsityVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::Sparsity)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparsityVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparsityVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::Sparsity)>)> self) -> SparsityVectorVector
        __init__(std::vector<(std::vector<(casadi::Sparsity)>)> self, SparsityVectorVector other) -> SparsityVectorVector
        """
        this = _casadi_core.new_SparsityVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SparsityVectorVector
SparsityVectorVector_swigregister = _casadi_core.SparsityVectorVector_swigregister
SparsityVectorVector_swigregister(SparsityVectorVector)

class SXVector(_object):
    """Proxy of C++ std::vector<(casadi::Matrix<(casadi::SXElement)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXVector, name)

    def __repr__(self, *args):
        """__repr__(SXVector self) -> std::string"""
        return _casadi_core.SXVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(SXVector self) -> std::string"""
        return _casadi_core.SXVector___str__(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Matrix<(casadi::SXElement)>)> self) -> SXVector
        __init__(std::vector<(casadi::Matrix<(casadi::SXElement)>)> self, SXVector other) -> SXVector
        """
        this = _casadi_core.new_SXVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXVector
SXVector_swigregister = _casadi_core.SXVector_swigregister
SXVector_swigregister(SXVector)

class SXVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::Matrix<(casadi::SXElement)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::Matrix<(casadi::SXElement)>)>)> self) -> SXVectorVector
        __init__(std::vector<(std::vector<(casadi::Matrix<(casadi::SXElement)>)>)> self, SXVectorVector other) -> SXVectorVector
        """
        this = _casadi_core.new_SXVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXVectorVector
SXVectorVector_swigregister = _casadi_core.SXVectorVector_swigregister
SXVectorVector_swigregister(SXVectorVector)

class MXVector(_object):
    """Proxy of C++ std::vector<(casadi::MX)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MXVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MXVector, name)

    def __repr__(self, *args):
        """__repr__(MXVector self) -> std::string"""
        return _casadi_core.MXVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(MXVector self) -> std::string"""
        return _casadi_core.MXVector___str__(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::MX)> self) -> MXVector
        __init__(std::vector<(casadi::MX)> self, MXVector other) -> MXVector
        """
        this = _casadi_core.new_MXVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MXVector
MXVector_swigregister = _casadi_core.MXVector_swigregister
MXVector_swigregister(MXVector)

class MXVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::MX)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MXVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MXVectorVector, name)

    def __repr__(self, *args):
        """__repr__(MXVectorVector self) -> std::string"""
        return _casadi_core.MXVectorVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(MXVectorVector self) -> std::string"""
        return _casadi_core.MXVectorVector___str__(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::MX)>)> self) -> MXVectorVector
        __init__(std::vector<(std::vector<(casadi::MX)>)> self, MXVectorVector other) -> MXVectorVector
        """
        this = _casadi_core.new_MXVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MXVectorVector
MXVectorVector_swigregister = _casadi_core.MXVectorVector_swigregister
MXVectorVector_swigregister(MXVectorVector)

class IMatrixVector(_object):
    """Proxy of C++ std::vector<(casadi::Matrix<(int)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMatrixVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMatrixVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Matrix<(int)>)> self) -> IMatrixVector
        __init__(std::vector<(casadi::Matrix<(int)>)> self, IMatrixVector other) -> IMatrixVector
        """
        this = _casadi_core.new_IMatrixVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IMatrixVector
IMatrixVector_swigregister = _casadi_core.IMatrixVector_swigregister
IMatrixVector_swigregister(IMatrixVector)

class DMatrixVector(_object):
    """Proxy of C++ std::vector<(casadi::Matrix<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DMatrixVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DMatrixVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Matrix<(double)>)> self) -> DMatrixVector
        __init__(std::vector<(casadi::Matrix<(double)>)> self, DMatrixVector other) -> DMatrixVector
        """
        this = _casadi_core.new_DMatrixVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DMatrixVector
DMatrixVector_swigregister = _casadi_core.DMatrixVector_swigregister
DMatrixVector_swigregister(DMatrixVector)

class DMatrixVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::Matrix<(double)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DMatrixVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DMatrixVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::Matrix<(double)>)>)> self) -> DMatrixVectorVector
        __init__(std::vector<(std::vector<(casadi::Matrix<(double)>)>)> self, DMatrixVectorVector other) -> DMatrixVectorVector
        """
        this = _casadi_core.new_DMatrixVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DMatrixVectorVector
DMatrixVectorVector_swigregister = _casadi_core.DMatrixVectorVector_swigregister
DMatrixVectorVector_swigregister(DMatrixVectorVector)

class IMatrixVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::Matrix<(int)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMatrixVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMatrixVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::Matrix<(int)>)>)> self) -> IMatrixVectorVector
        __init__(std::vector<(std::vector<(casadi::Matrix<(int)>)>)> self, IMatrixVectorVector other) -> IMatrixVectorVector
        """
        this = _casadi_core.new_IMatrixVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IMatrixVectorVector
IMatrixVectorVector_swigregister = _casadi_core.IMatrixVectorVector_swigregister
IMatrixVectorVector_swigregister(IMatrixVectorVector)

class SXElementVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(casadi::SXElement)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElementVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXElementVectorVector, name)

    def __repr__(self, *args):
        """__repr__(SXElementVectorVector self) -> std::string"""
        return _casadi_core.SXElementVectorVector___repr__(self, *args)


    def __str__(self, *args):
        """__str__(SXElementVectorVector self) -> std::string"""
        return _casadi_core.SXElementVectorVector___str__(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(casadi::SXElement)>)> self) -> SXElementVectorVector
        __init__(std::vector<(std::vector<(casadi::SXElement)>)> self, SXElementVectorVector other) -> SXElementVectorVector
        """
        this = _casadi_core.new_SXElementVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXElementVectorVector
SXElementVectorVector_swigregister = _casadi_core.SXElementVectorVector_swigregister
SXElementVectorVector_swigregister(SXElementVectorVector)

class SXElementVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(casadi::SXElement)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElementVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXElementVectorVectorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(casadi::SXElement)>)>)> self) -> SXElementVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(casadi::SXElement)>)>)> self, SXElementVectorVectorVector other) -> SXElementVectorVectorVector
        """
        this = _casadi_core.new_SXElementVectorVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXElementVectorVectorVector
SXElementVectorVectorVector_swigregister = _casadi_core.SXElementVectorVectorVector_swigregister
SXElementVectorVectorVector_swigregister(SXElementVectorVectorVector)

class Dictionary(_object):
    """Proxy of C++ std::map<(std::string,casadi::GenericType)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)
    __repr__ = _swig_repr

    def iterator(self, *args):
        """iterator(Dictionary self) -> SwigPyIterator"""
        return _casadi_core.Dictionary_iterator(self, *args)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self, *args):
        """__nonzero__(Dictionary self) -> bool"""
        return _casadi_core.Dictionary___nonzero__(self, *args)


    def __bool__(self, *args):
        """__bool__(Dictionary self) -> bool"""
        return _casadi_core.Dictionary___bool__(self, *args)


    def __len__(self, *args):
        """__len__(Dictionary self) -> std::map< std::string,casadi::GenericType >::size_type"""
        return _casadi_core.Dictionary___len__(self, *args)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, *args):
        """__getitem__(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key) -> GenericType"""
        return _casadi_core.Dictionary___getitem__(self, *args)


    def __delitem__(self, *args):
        """__delitem__(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key)"""
        return _casadi_core.Dictionary___delitem__(self, *args)


    def has_key(self, *args):
        """has_key(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key) -> bool"""
        return _casadi_core.Dictionary_has_key(self, *args)


    def keys(self, *args):
        """keys(Dictionary self) -> PyObject *"""
        return _casadi_core.Dictionary_keys(self, *args)


    def values(self, *args):
        """values(Dictionary self) -> PyObject *"""
        return _casadi_core.Dictionary_values(self, *args)


    def items(self, *args):
        """items(Dictionary self) -> PyObject *"""
        return _casadi_core.Dictionary_items(self, *args)


    def __contains__(self, *args):
        """__contains__(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key) -> bool"""
        return _casadi_core.Dictionary___contains__(self, *args)


    def key_iterator(self, *args):
        """key_iterator(Dictionary self) -> SwigPyIterator"""
        return _casadi_core.Dictionary_key_iterator(self, *args)


    def value_iterator(self, *args):
        """value_iterator(Dictionary self) -> SwigPyIterator"""
        return _casadi_core.Dictionary_value_iterator(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key)
        __setitem__(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & key, GenericType x)
        """
        return _casadi_core.Dictionary___setitem__(self, *args)


    def asdict(self, *args):
        """asdict(Dictionary self) -> PyObject *"""
        return _casadi_core.Dictionary_asdict(self, *args)


    def __init__(self, *args):
        """
        __init__(std::map<(std::string,casadi::GenericType)> self, std::less< std::string > const & arg2) -> Dictionary
        __init__(std::map<(std::string,casadi::GenericType)> self) -> Dictionary
        __init__(std::map<(std::string,casadi::GenericType)> self, Dictionary arg2) -> Dictionary
        """
        this = _casadi_core.new_Dictionary(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self, *args):
        """empty(Dictionary self) -> bool"""
        return _casadi_core.Dictionary_empty(self, *args)


    def size(self, *args):
        """size(Dictionary self) -> std::map< std::string,casadi::GenericType >::size_type"""
        return _casadi_core.Dictionary_size(self, *args)


    def swap(self, *args):
        """swap(Dictionary self, Dictionary v)"""
        return _casadi_core.Dictionary_swap(self, *args)


    def begin(self, *args):
        """begin(Dictionary self) -> std::map< std::string,casadi::GenericType >::iterator"""
        return _casadi_core.Dictionary_begin(self, *args)


    def end(self, *args):
        """end(Dictionary self) -> std::map< std::string,casadi::GenericType >::iterator"""
        return _casadi_core.Dictionary_end(self, *args)


    def rbegin(self, *args):
        """rbegin(Dictionary self) -> std::map< std::string,casadi::GenericType >::reverse_iterator"""
        return _casadi_core.Dictionary_rbegin(self, *args)


    def rend(self, *args):
        """rend(Dictionary self) -> std::map< std::string,casadi::GenericType >::reverse_iterator"""
        return _casadi_core.Dictionary_rend(self, *args)


    def clear(self, *args):
        """clear(Dictionary self)"""
        return _casadi_core.Dictionary_clear(self, *args)


    def get_allocator(self, *args):
        """get_allocator(Dictionary self) -> std::map< std::string,casadi::GenericType >::allocator_type"""
        return _casadi_core.Dictionary_get_allocator(self, *args)


    def count(self, *args):
        """count(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & x) -> std::map< std::string,casadi::GenericType >::size_type"""
        return _casadi_core.Dictionary_count(self, *args)


    def erase(self, *args):
        """
        erase(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & x) -> std::map< std::string,casadi::GenericType >::size_type
        erase(Dictionary self, std::map< std::string,casadi::GenericType >::iterator position)
        erase(Dictionary self, std::map< std::string,casadi::GenericType >::iterator first, std::map< std::string,casadi::GenericType >::iterator last)
        """
        return _casadi_core.Dictionary_erase(self, *args)


    def find(self, *args):
        """find(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & x) -> std::map< std::string,casadi::GenericType >::iterator"""
        return _casadi_core.Dictionary_find(self, *args)


    def lower_bound(self, *args):
        """lower_bound(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & x) -> std::map< std::string,casadi::GenericType >::iterator"""
        return _casadi_core.Dictionary_lower_bound(self, *args)


    def upper_bound(self, *args):
        """upper_bound(Dictionary self, std::map< std::string,casadi::GenericType >::key_type const & x) -> std::map< std::string,casadi::GenericType >::iterator"""
        return _casadi_core.Dictionary_upper_bound(self, *args)

    __swig_destroy__ = _casadi_core.delete_Dictionary
Dictionary_swigregister = _casadi_core.Dictionary_swigregister
Dictionary_swigregister(Dictionary)


import _casadi_core


def dummy(*args):
    """dummy(SXElement foo, DVectorVector foo1, DVector foo2, MXVector foo3, MX foo4, DMatrix foo5, Sparsity foo6, SXElementVector foo7, SXElementVectorVector foo8, SX foo9, GenericType foo10, DMatrixVector foo11, DMatrixVectorVector foo12, IMatrixVector foo13, IMatrixVectorVector foo14, SXVector foo15, SXVectorVector foo16, MXVectorVector foo17, std::vector< std::vector< casadi::MX *,std::allocator< casadi::MX * > >,std::allocator< std::vector< casadi::MX *,std::allocator< casadi::MX * > > > > foo17b, Dictionary foo18, std::string & foo19, IMatrix foo20, CustomFunction foo24, Function foo25, int & bar, double & baz)"""
    return _casadi_core.dummy(*args)

def dummy2(*args):
    """dummy2(DerivativeGenerator foo1, Callback foo2, CustomEvaluate foo3)"""
    return _casadi_core.dummy2(*args)

_casadi_core.SCHEME_CLEInput_swigconstant(_casadi_core)
SCHEME_CLEInput = _casadi_core.SCHEME_CLEInput

_casadi_core.SCHEME_CLEOutput_swigconstant(_casadi_core)
SCHEME_CLEOutput = _casadi_core.SCHEME_CLEOutput

_casadi_core.SCHEME_CleStruct_swigconstant(_casadi_core)
SCHEME_CleStruct = _casadi_core.SCHEME_CleStruct

_casadi_core.SCHEME_ControlledDAEInput_swigconstant(_casadi_core)
SCHEME_ControlledDAEInput = _casadi_core.SCHEME_ControlledDAEInput

_casadi_core.SCHEME_ControlSimulatorInput_swigconstant(_casadi_core)
SCHEME_ControlSimulatorInput = _casadi_core.SCHEME_ControlSimulatorInput

_casadi_core.SCHEME_DLEInput_swigconstant(_casadi_core)
SCHEME_DLEInput = _casadi_core.SCHEME_DLEInput

_casadi_core.SCHEME_DLEOutput_swigconstant(_casadi_core)
SCHEME_DLEOutput = _casadi_core.SCHEME_DLEOutput

_casadi_core.SCHEME_DleStruct_swigconstant(_casadi_core)
SCHEME_DleStruct = _casadi_core.SCHEME_DleStruct

_casadi_core.SCHEME_DPLEInput_swigconstant(_casadi_core)
SCHEME_DPLEInput = _casadi_core.SCHEME_DPLEInput

_casadi_core.SCHEME_DPLEOutput_swigconstant(_casadi_core)
SCHEME_DPLEOutput = _casadi_core.SCHEME_DPLEOutput

_casadi_core.SCHEME_DpleVecStruct_swigconstant(_casadi_core)
SCHEME_DpleVecStruct = _casadi_core.SCHEME_DpleVecStruct

_casadi_core.SCHEME_HNLPInput_swigconstant(_casadi_core)
SCHEME_HNLPInput = _casadi_core.SCHEME_HNLPInput

_casadi_core.SCHEME_DAEInput_swigconstant(_casadi_core)
SCHEME_DAEInput = _casadi_core.SCHEME_DAEInput

_casadi_core.SCHEME_DAEOutput_swigconstant(_casadi_core)
SCHEME_DAEOutput = _casadi_core.SCHEME_DAEOutput

_casadi_core.SCHEME_RDAEInput_swigconstant(_casadi_core)
SCHEME_RDAEInput = _casadi_core.SCHEME_RDAEInput

_casadi_core.SCHEME_RDAEOutput_swigconstant(_casadi_core)
SCHEME_RDAEOutput = _casadi_core.SCHEME_RDAEOutput

_casadi_core.SCHEME_IntegratorInput_swigconstant(_casadi_core)
SCHEME_IntegratorInput = _casadi_core.SCHEME_IntegratorInput

_casadi_core.SCHEME_IntegratorOutput_swigconstant(_casadi_core)
SCHEME_IntegratorOutput = _casadi_core.SCHEME_IntegratorOutput

_casadi_core.SCHEME_LinsolInput_swigconstant(_casadi_core)
SCHEME_LinsolInput = _casadi_core.SCHEME_LinsolInput

_casadi_core.SCHEME_LinsolOutput_swigconstant(_casadi_core)
SCHEME_LinsolOutput = _casadi_core.SCHEME_LinsolOutput

_casadi_core.SCHEME_LpSolverInput_swigconstant(_casadi_core)
SCHEME_LpSolverInput = _casadi_core.SCHEME_LpSolverInput

_casadi_core.SCHEME_LpSolverOutput_swigconstant(_casadi_core)
SCHEME_LpSolverOutput = _casadi_core.SCHEME_LpSolverOutput

_casadi_core.SCHEME_LPStruct_swigconstant(_casadi_core)
SCHEME_LPStruct = _casadi_core.SCHEME_LPStruct

_casadi_core.SCHEME_LR_DLEInput_swigconstant(_casadi_core)
SCHEME_LR_DLEInput = _casadi_core.SCHEME_LR_DLEInput

_casadi_core.SCHEME_LR_DLEOutput_swigconstant(_casadi_core)
SCHEME_LR_DLEOutput = _casadi_core.SCHEME_LR_DLEOutput

_casadi_core.SCHEME_LrDleStruct_swigconstant(_casadi_core)
SCHEME_LrDleStruct = _casadi_core.SCHEME_LrDleStruct

_casadi_core.SCHEME_LR_DPLEInput_swigconstant(_casadi_core)
SCHEME_LR_DPLEInput = _casadi_core.SCHEME_LR_DPLEInput

_casadi_core.SCHEME_LR_DPLEOutput_swigconstant(_casadi_core)
SCHEME_LR_DPLEOutput = _casadi_core.SCHEME_LR_DPLEOutput

_casadi_core.SCHEME_LrDpleVecStruct_swigconstant(_casadi_core)
SCHEME_LrDpleVecStruct = _casadi_core.SCHEME_LrDpleVecStruct

_casadi_core.SCHEME_NLPInput_swigconstant(_casadi_core)
SCHEME_NLPInput = _casadi_core.SCHEME_NLPInput

_casadi_core.SCHEME_NLPOutput_swigconstant(_casadi_core)
SCHEME_NLPOutput = _casadi_core.SCHEME_NLPOutput

_casadi_core.SCHEME_GradFInput_swigconstant(_casadi_core)
SCHEME_GradFInput = _casadi_core.SCHEME_GradFInput

_casadi_core.SCHEME_GradFOutput_swigconstant(_casadi_core)
SCHEME_GradFOutput = _casadi_core.SCHEME_GradFOutput

_casadi_core.SCHEME_JacGInput_swigconstant(_casadi_core)
SCHEME_JacGInput = _casadi_core.SCHEME_JacGInput

_casadi_core.SCHEME_JacGOutput_swigconstant(_casadi_core)
SCHEME_JacGOutput = _casadi_core.SCHEME_JacGOutput

_casadi_core.SCHEME_HessLagInput_swigconstant(_casadi_core)
SCHEME_HessLagInput = _casadi_core.SCHEME_HessLagInput

_casadi_core.SCHEME_HessLagOutput_swigconstant(_casadi_core)
SCHEME_HessLagOutput = _casadi_core.SCHEME_HessLagOutput

_casadi_core.SCHEME_NlpSolverInput_swigconstant(_casadi_core)
SCHEME_NlpSolverInput = _casadi_core.SCHEME_NlpSolverInput

_casadi_core.SCHEME_NlpSolverOutput_swigconstant(_casadi_core)
SCHEME_NlpSolverOutput = _casadi_core.SCHEME_NlpSolverOutput

_casadi_core.SCHEME_QcqpSolverInput_swigconstant(_casadi_core)
SCHEME_QcqpSolverInput = _casadi_core.SCHEME_QcqpSolverInput

_casadi_core.SCHEME_QcqpSolverOutput_swigconstant(_casadi_core)
SCHEME_QcqpSolverOutput = _casadi_core.SCHEME_QcqpSolverOutput

_casadi_core.SCHEME_QCQPStruct_swigconstant(_casadi_core)
SCHEME_QCQPStruct = _casadi_core.SCHEME_QCQPStruct

_casadi_core.SCHEME_QpSolverInput_swigconstant(_casadi_core)
SCHEME_QpSolverInput = _casadi_core.SCHEME_QpSolverInput

_casadi_core.SCHEME_QpSolverOutput_swigconstant(_casadi_core)
SCHEME_QpSolverOutput = _casadi_core.SCHEME_QpSolverOutput

_casadi_core.SCHEME_QPStruct_swigconstant(_casadi_core)
SCHEME_QPStruct = _casadi_core.SCHEME_QPStruct

_casadi_core.SCHEME_SDPInput_swigconstant(_casadi_core)
SCHEME_SDPInput = _casadi_core.SCHEME_SDPInput

_casadi_core.SCHEME_SDPOutput_swigconstant(_casadi_core)
SCHEME_SDPOutput = _casadi_core.SCHEME_SDPOutput

_casadi_core.SCHEME_SDPStruct_swigconstant(_casadi_core)
SCHEME_SDPStruct = _casadi_core.SCHEME_SDPStruct

_casadi_core.SCHEME_SDQPInput_swigconstant(_casadi_core)
SCHEME_SDQPInput = _casadi_core.SCHEME_SDQPInput

_casadi_core.SCHEME_SDQPOutput_swigconstant(_casadi_core)
SCHEME_SDQPOutput = _casadi_core.SCHEME_SDQPOutput

_casadi_core.SCHEME_SDQPStruct_swigconstant(_casadi_core)
SCHEME_SDQPStruct = _casadi_core.SCHEME_SDQPStruct

_casadi_core.SCHEME_SOCPInput_swigconstant(_casadi_core)
SCHEME_SOCPInput = _casadi_core.SCHEME_SOCPInput

_casadi_core.SCHEME_SOCPOutput_swigconstant(_casadi_core)
SCHEME_SOCPOutput = _casadi_core.SCHEME_SOCPOutput

_casadi_core.SCHEME_SOCPStruct_swigconstant(_casadi_core)
SCHEME_SOCPStruct = _casadi_core.SCHEME_SOCPStruct

_casadi_core.SCHEME_StabilizedQpSolverInput_swigconstant(_casadi_core)
SCHEME_StabilizedQpSolverInput = _casadi_core.SCHEME_StabilizedQpSolverInput

def getSchemeEntryName(*args):
    """getSchemeEntryName(casadi::InputOutputScheme scheme, int i) -> std::string"""
    return _casadi_core.getSchemeEntryName(*args)

def getSchemeEntryDoc(*args):
    """getSchemeEntryDoc(casadi::InputOutputScheme scheme, int i) -> std::string"""
    return _casadi_core.getSchemeEntryDoc(*args)

def getSchemeEntryEnumName(*args):
    """getSchemeEntryEnumName(casadi::InputOutputScheme scheme, int i) -> std::string"""
    return _casadi_core.getSchemeEntryEnumName(*args)

def getSchemeEntryEnum(*args):
    """getSchemeEntryEnum(casadi::InputOutputScheme scheme, std::string const & name) -> int"""
    return _casadi_core.getSchemeEntryEnum(*args)

def getSchemeSize(*args):
    """getSchemeSize(casadi::InputOutputScheme scheme) -> int"""
    return _casadi_core.getSchemeSize(*args)

def getSchemeName(*args):
    """getSchemeName(casadi::InputOutputScheme scheme) -> std::string"""
    return _casadi_core.getSchemeName(*args)

def getSchemeEntryNames(*args):
    """getSchemeEntryNames(casadi::InputOutputScheme scheme) -> std::string"""
    return _casadi_core.getSchemeEntryNames(*args)

try:
  from numpy import pi, inf
except:
  pass

try:
  from numpy import sin, cos, tan, sqrt, log, exp, floor, ceil, fmod, fmin, fmax, sinh, cosh, tanh, arcsin, arccos, arctan, arctan2, fabs, sign, arctanh, arcsinh, arccosh, copysign
except:
  sin = lambda x: x.sin()
  cos = lambda x: x.cos()
  tan = lambda x: x.tan()
  arcsin = lambda x: x.arcsin()
  arccos = lambda x: x.arccos()
  arctan = lambda x: x.arctan()
  sqrt = lambda x: x.sqrt()
  log = lambda x: x.log()
  exp = lambda x: x.exp()
  floor = lambda x: x.floor()
  ceil = lambda x: x.ceil()
  fmin = lambda x,y: x.fmin(y)
  fmax = lambda x,y: x.fmax(y)
  sinh = lambda x: x.sinh()
  cosh = lambda x: x.cosh()
  tanh = lambda x: x.tanh()
  fabs = lambda x: x.fabs()
  sign = lambda x: x.sign()
  arctan2 = lambda x,y: x.arctan2(y)
  arctanh = lambda x: x.arctanh()
  arcsinh = lambda x: x.arcsinh()
  arccosh = lambda x: x.arccosh()
  copysign = lambda x,y: x.copysign(y)


def prod(self,*args):
    raise Exception("'prod' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")
def dot(self,*args):
    raise Exception("'dot' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")

class NZproxy:
  def __init__(self,matrix):
    self.matrix = matrix

  def __getitem__(self,s):
    return self.matrix.__NZgetitem__(s)

  def __setitem__(self,s,val):
    return self.matrix.__NZsetitem__(s,val)

  def __len__(self):
    return self.matrix.size()

  def __iter__(self):
    for k in range(len(self)):
      yield self[k]

class PrintSharedObject(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSharedObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSharedObject, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintSharedObject self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSharedObject_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSharedObject self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSharedObject_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::SharedObject)> self) -> PrintSharedObject
        __init__(casadi::PrintableObject<(casadi::SharedObject)> self, PrintSharedObject other) -> PrintSharedObject
        """
        this = _casadi_core.new_PrintSharedObject(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSharedObject
PrintSharedObject_swigregister = _casadi_core.PrintSharedObject_swigregister
PrintSharedObject_swigregister(PrintSharedObject)

class PrintSlice(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSlice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSlice, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintSlice self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSlice_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSlice self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSlice_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::Slice)> self) -> PrintSlice
        __init__(casadi::PrintableObject<(casadi::Slice)> self, PrintSlice other) -> PrintSlice
        """
        this = _casadi_core.new_PrintSlice(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSlice
PrintSlice_swigregister = _casadi_core.PrintSlice_swigregister
PrintSlice_swigregister(PrintSlice)

class PrintIMatrix(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIMatrix, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIMatrix self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIMatrix_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIMatrix self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIMatrix_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(int)>)> self) -> PrintIMatrix
        __init__(casadi::PrintableObject<(casadi::Matrix<(int)>)> self, PrintIMatrix other) -> PrintIMatrix
        """
        this = _casadi_core.new_PrintIMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIMatrix
PrintIMatrix_swigregister = _casadi_core.PrintIMatrix_swigregister
PrintIMatrix_swigregister(PrintIMatrix)

class PrintDMatrix(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintDMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintDMatrix, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintDMatrix self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintDMatrix_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintDMatrix self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintDMatrix_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(double)>)> self) -> PrintDMatrix
        __init__(casadi::PrintableObject<(casadi::Matrix<(double)>)> self, PrintDMatrix other) -> PrintDMatrix
        """
        this = _casadi_core.new_PrintDMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintDMatrix
PrintDMatrix_swigregister = _casadi_core.PrintDMatrix_swigregister
PrintDMatrix_swigregister(PrintDMatrix)

class PrintSXElement(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSXElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSXElement, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintSXElement self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSXElement_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSXElement self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSXElement_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::SXElement)> self) -> PrintSXElement
        __init__(casadi::PrintableObject<(casadi::SXElement)> self, PrintSXElement other) -> PrintSXElement
        """
        this = _casadi_core.new_PrintSXElement(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSXElement
PrintSXElement_swigregister = _casadi_core.PrintSXElement_swigregister
PrintSXElement_swigregister(PrintSXElement)

class PrintSymbolicNLP(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSymbolicNLP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSymbolicNLP, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintSymbolicNLP self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSymbolicNLP_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSymbolicNLP self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSymbolicNLP_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::SymbolicNLP)> self) -> PrintSymbolicNLP
        __init__(casadi::PrintableObject<(casadi::SymbolicNLP)> self, PrintSymbolicNLP other) -> PrintSymbolicNLP
        """
        this = _casadi_core.new_PrintSymbolicNLP(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSymbolicNLP
PrintSymbolicNLP_swigregister = _casadi_core.PrintSymbolicNLP_swigregister
PrintSymbolicNLP_swigregister(PrintSymbolicNLP)

class PrintVariable(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintVariable, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintVariable self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintVariable_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintVariable self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintVariable_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::Variable)> self) -> PrintVariable
        __init__(casadi::PrintableObject<(casadi::Variable)> self, PrintVariable other) -> PrintVariable
        """
        this = _casadi_core.new_PrintVariable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintVariable
PrintVariable_swigregister = _casadi_core.PrintVariable_swigregister
PrintVariable_swigregister(PrintVariable)

class PrintSymbolicOCP(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSymbolicOCP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSymbolicOCP, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintSymbolicOCP self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSymbolicOCP_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSymbolicOCP self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSymbolicOCP_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::SymbolicOCP)> self) -> PrintSymbolicOCP
        __init__(casadi::PrintableObject<(casadi::SymbolicOCP)> self, PrintSymbolicOCP other) -> PrintSymbolicOCP
        """
        this = _casadi_core.new_PrintSymbolicOCP(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSymbolicOCP
PrintSymbolicOCP_swigregister = _casadi_core.PrintSymbolicOCP_swigregister
PrintSymbolicOCP_swigregister(PrintSymbolicOCP)

class PrintIOSchemeVectorMX(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIOSchemeVectorMX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIOSchemeVectorMX, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIOSchemeVectorMX self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorMX_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIOSchemeVectorMX self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorMX_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::MX)>)> self) -> PrintIOSchemeVectorMX
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::MX)>)> self, PrintIOSchemeVectorMX other) -> PrintIOSchemeVectorMX
        """
        this = _casadi_core.new_PrintIOSchemeVectorMX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIOSchemeVectorMX
PrintIOSchemeVectorMX_swigregister = _casadi_core.PrintIOSchemeVectorMX_swigregister
PrintIOSchemeVectorMX_swigregister(PrintIOSchemeVectorMX)

class PrintIOSchemeVectorSX(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIOSchemeVectorSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIOSchemeVectorSX, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIOSchemeVectorSX self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSX_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIOSchemeVectorSX self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSX_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Matrix<(casadi::SXElement)>)>)> self) -> PrintIOSchemeVectorSX
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Matrix<(casadi::SXElement)>)>)> self, PrintIOSchemeVectorSX other) -> PrintIOSchemeVectorSX
        """
        this = _casadi_core.new_PrintIOSchemeVectorSX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIOSchemeVectorSX
PrintIOSchemeVectorSX_swigregister = _casadi_core.PrintIOSchemeVectorSX_swigregister
PrintIOSchemeVectorSX_swigregister(PrintIOSchemeVectorSX)

class PrintIOSchemeVectorD(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIOSchemeVectorD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIOSchemeVectorD, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIOSchemeVectorD self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorD_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIOSchemeVectorD self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorD_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Matrix<(double)>)>)> self) -> PrintIOSchemeVectorD
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Matrix<(double)>)>)> self, PrintIOSchemeVectorD other) -> PrintIOSchemeVectorD
        """
        this = _casadi_core.new_PrintIOSchemeVectorD(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIOSchemeVectorD
PrintIOSchemeVectorD_swigregister = _casadi_core.PrintIOSchemeVectorD_swigregister
PrintIOSchemeVectorD_swigregister(PrintIOSchemeVectorD)

class PrintIOSchemeVectorSparsity(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIOSchemeVectorSparsity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIOSchemeVectorSparsity, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIOSchemeVectorSparsity self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSparsity_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIOSchemeVectorSparsity self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSparsity_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Sparsity)>)> self) -> PrintIOSchemeVectorSparsity
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(casadi::Sparsity)>)> self, PrintIOSchemeVectorSparsity other) -> PrintIOSchemeVectorSparsity
        """
        this = _casadi_core.new_PrintIOSchemeVectorSparsity(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIOSchemeVectorSparsity
PrintIOSchemeVectorSparsity_swigregister = _casadi_core.PrintIOSchemeVectorSparsity_swigregister
PrintIOSchemeVectorSparsity_swigregister(PrintIOSchemeVectorSparsity)

class PrintIOSchemeVectorSparsityVector(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIOSchemeVectorSparsityVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIOSchemeVectorSparsityVector, name)
    __repr__ = _swig_repr

    def getDescription(self, *args):
        """
        getDescription(PrintIOSchemeVectorSparsityVector self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSparsityVector_getDescription(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIOSchemeVectorSparsityVector self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintIOSchemeVectorSparsityVector_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(std::vector<(casadi::Sparsity)>)>)> self) -> PrintIOSchemeVectorSparsityVector
        __init__(casadi::PrintableObject<(casadi::IOSchemeVector<(std::vector<(casadi::Sparsity)>)>)> self, PrintIOSchemeVectorSparsityVector other) -> PrintIOSchemeVectorSparsityVector
        """
        this = _casadi_core.new_PrintIOSchemeVectorSparsityVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintIOSchemeVectorSparsityVector
PrintIOSchemeVectorSparsityVector_swigregister = _casadi_core.PrintIOSchemeVectorSparsityVector_swigregister
PrintIOSchemeVectorSparsityVector_swigregister(PrintIOSchemeVectorSparsityVector)

class SharedObject(PrintSharedObject):
    """


    SharedObject implements a reference counting framework similar for efficient
    and easily-maintained memory management.

    To use the class, both the SharedObject class (the public class), and the
    SharedObjectNode class (the internal class) must be inherited from. It can
    be done in two different files and together with memory management, this
    approach provides a clear distinction of which methods of the class are to
    be considered "public", i.e. methods for public use that can be considered
    to remain over time with small changes, and the internal memory.

    When interfacing a software, which typically includes including some header
    file, this is best done only in the file where the internal class is
    defined, to avoid polluting the global namespace and other side effects.

    The default constructor always means creating a null pointer to an internal
    class only. To allocate an internal class (this works only when the internal
    class isn't abstract), use the constructor with arguments.

    The copy constructor and the assignment operator perform shallow copies
    only, to make a deep copy you must use the clone method explicitly. This
    will give a shared pointer instance.

    In an inheritance hierarchy, you can cast down automatically, e.g. (
    SXFunction is a child class of Function): SXFunction derived(...); Function
    base = derived;

    To cast up, use the shared_cast template function, which works analogously
    to dynamic_cast, static_cast, const_cast etc, e.g.: SXFunction derived(...);
    Function base = derived; SXFunction derived_from_base =
    shared_cast<SXFunction>(base);

    A failed shared_cast will result in a null pointer (cf. dynamic_cast)

    Joel Andersson

    C++ includes: shared_object.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintSharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SharedObject, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SharedObject, name)
    __repr__ = _swig_repr

    def printPtr(self, *args):
        """
        printPtr(SharedObject self, std::ostream & stream)

        [INTERNAL]  Print the
        pointer to the internal class


        """
        return _casadi_core.SharedObject_printPtr(self, *args)


    def init(self, *args):
        """
        init(SharedObject self, bool allow_reinit=True)



        Initialize or re-initialize the object:

        more documentation in the node class ( SharedObjectNode and derived classes)


        """
        return _casadi_core.SharedObject_init(self, *args)


    def isInit(self, *args):
        """
        isInit(SharedObject self) -> bool



        Is initialized?


        """
        return _casadi_core.SharedObject_isInit(self, *args)


    def assertInit(self, *args):
        """
        assertInit(SharedObject self)

        [INTERNAL]  Assert
        that it is initialized


        """
        return _casadi_core.SharedObject_assertInit(self, *args)


    def isNull(self, *args):
        """
        isNull(SharedObject self) -> bool



        Is a null pointer?


        """
        return _casadi_core.SharedObject_isNull(self, *args)


    def makeUnique(self, *args):
        """
        makeUnique(SharedObject self, bool clone_members=True)



        >  void casadi::SharedObject::makeUnique(bool clone_members=true)
        ------------------------------------------------------------------------

        Make unique.

        If there are other references to the object, then make a deep copy of it and
        point to this new object

        >  void casadi::SharedObject::makeUnique(std::map< SharedObjectNode *, SharedObject > &already_copied, bool clone_members=true)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Make unique.

        If there are other references to the object, then make a deep copy of it and
        point to this new object


        """
        return _casadi_core.SharedObject_makeUnique(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::SharedObject self) -> SharedObject
        __init__(casadi::SharedObject self, SharedObject other) -> SharedObject



        >  casadi::SharedObject::SharedObject()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Default constructor.

        >  casadi::SharedObject::SharedObject(const SharedObject &ref)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Copy constructor (shallow copy)


        """
        this = _casadi_core.new_SharedObject(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SharedObject
SharedObject_swigregister = _casadi_core.SharedObject_swigregister
SharedObject_swigregister(SharedObject)


def complement(*args):
    """
    complement(IVector v, int size) -> IVector


    Returns the list of all i in [0, size[ not found in supplied list.

    The supplied vector may contain duplicates and may be non-monotonous The
    supplied vector will be checked for bounds The result vector is guaranteed
    to be monotonously increasing


    """
    return _casadi_core.complement(*args)

def lookupvector(*args):
    """
    lookupvector(IVector v, int size) -> IVector



    Returns a vector for quickly looking up entries of supplied list.

    lookupvector[i]!=-1 <=> v contains i v[lookupvector[i]] == i <=> v contains
    i

    Duplicates are treated by looking up last occurrence


    """
    return _casadi_core.lookupvector(*args)
 #NOLINT(whitespace/braces)
def makeVector(T, size, *elems):
    assert len(elems) % 2 == 0, \
        "The number of provided indices does not the number of provided values"
    num_elem = len(elems)/2
    ret = [T()]*size
    for i in range(num_elem):
        ind = elems[2*i]
        val = elems[2*i+1]
        ret[ind] = val
    return ret


def isIncreasing(*args):
    """
    isIncreasing(IVector v) -> bool
    isIncreasing(DVector v) -> bool



    Check if the vector is strictly increasing.


    """
    return _casadi_core.isIncreasing(*args)

def isDecreasing(*args):
    """
    isDecreasing(IVector v) -> bool
    isDecreasing(DVector v) -> bool



    Check if the vector is strictly decreasing.


    """
    return _casadi_core.isDecreasing(*args)

def isNonIncreasing(*args):
    """
    isNonIncreasing(IVector v) -> bool
    isNonIncreasing(DVector v) -> bool



    Check if the vector is non-increasing.


    """
    return _casadi_core.isNonIncreasing(*args)

def isNonDecreasing(*args):
    """
    isNonDecreasing(IVector v) -> bool
    isNonDecreasing(DVector v) -> bool



    Check if the vector is non-decreasing.


    """
    return _casadi_core.isNonDecreasing(*args)

def isMonotone(*args):
    """
    isMonotone(IVector v) -> bool
    isMonotone(DVector v) -> bool



    Check if the vector is monotone.


    """
    return _casadi_core.isMonotone(*args)

def isStrictlyMonotone(*args):
    """
    isStrictlyMonotone(IVector v) -> bool
    isStrictlyMonotone(DVector v) -> bool



    Check if the vector is strictly monotone.


    """
    return _casadi_core.isStrictlyMonotone(*args)

def isRegular(*args):
    """
    isRegular(IVector v) -> bool
    isRegular(DVector v) -> bool



    Checks if vector does not contain NaN or Inf.


    """
    return _casadi_core.isRegular(*args)
class WeakRef(SharedObject):
    """
    [INTERNAL]  Weak reference type A
    weak reference to a SharedObject.

    Joel Andersson

    C++ includes: weak_ref.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeakRef, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeakRef, name)
    __repr__ = _swig_repr

    def shared(self, *args):
        """
        shared(WeakRef self) -> SharedObject

        [INTERNAL]  Get a shared
        (owning) reference.


        """
        return _casadi_core.WeakRef_shared(self, *args)


    def alive(self, *args):
        """
        alive(WeakRef self) -> bool

        [INTERNAL]  Check if alive.


        """
        return _casadi_core.WeakRef_alive(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::WeakRef self, int dummy=0) -> WeakRef
        __init__(casadi::WeakRef self, SharedObject shared) -> WeakRef
        __init__(casadi::WeakRef self, WeakRef other) -> WeakRef



        >  casadi::WeakRef::WeakRef(int dummy=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Default constructor.

        >  casadi::WeakRef::WeakRef(SharedObject shared)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct from a shared object (also implicit type conversion)


        """
        this = _casadi_core.new_WeakRef(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_WeakRef
WeakRef_swigregister = _casadi_core.WeakRef_swigregister
WeakRef_swigregister(WeakRef)


_casadi_core.OT_BOOLEAN_swigconstant(_casadi_core)
OT_BOOLEAN = _casadi_core.OT_BOOLEAN

_casadi_core.OT_INTEGER_swigconstant(_casadi_core)
OT_INTEGER = _casadi_core.OT_INTEGER

_casadi_core.OT_REAL_swigconstant(_casadi_core)
OT_REAL = _casadi_core.OT_REAL

_casadi_core.OT_STRING_swigconstant(_casadi_core)
OT_STRING = _casadi_core.OT_STRING

_casadi_core.OT_INTEGERVECTOR_swigconstant(_casadi_core)
OT_INTEGERVECTOR = _casadi_core.OT_INTEGERVECTOR

_casadi_core.OT_BOOLVECTOR_swigconstant(_casadi_core)
OT_BOOLVECTOR = _casadi_core.OT_BOOLVECTOR

_casadi_core.OT_REALVECTOR_swigconstant(_casadi_core)
OT_REALVECTOR = _casadi_core.OT_REALVECTOR

_casadi_core.OT_STRINGVECTOR_swigconstant(_casadi_core)
OT_STRINGVECTOR = _casadi_core.OT_STRINGVECTOR

_casadi_core.OT_DICTIONARY_swigconstant(_casadi_core)
OT_DICTIONARY = _casadi_core.OT_DICTIONARY

_casadi_core.OT_DERIVATIVEGENERATOR_swigconstant(_casadi_core)
OT_DERIVATIVEGENERATOR = _casadi_core.OT_DERIVATIVEGENERATOR

_casadi_core.OT_FUNCTION_swigconstant(_casadi_core)
OT_FUNCTION = _casadi_core.OT_FUNCTION

_casadi_core.OT_CALLBACK_swigconstant(_casadi_core)
OT_CALLBACK = _casadi_core.OT_CALLBACK

_casadi_core.OT_VOIDPTR_swigconstant(_casadi_core)
OT_VOIDPTR = _casadi_core.OT_VOIDPTR

_casadi_core.OT_UNKNOWN_swigconstant(_casadi_core)
OT_UNKNOWN = _casadi_core.OT_UNKNOWN
class GenericType(SharedObject):
    """


    Generic data type.

    Joel Andersson

    C++ includes: generic_type.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericType, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericType, name)
    __repr__ = _swig_repr

    def get_type_description(*args):
        """get_type_description(casadi::opt_type const & type) -> std::string"""
        return _casadi_core.GenericType_get_type_description(*args)

    if _newclass:
        get_type_description = staticmethod(get_type_description)
    __swig_getmethods__["get_type_description"] = lambda x: get_type_description

    def get_description(self, *args):
        """
        get_description(GenericType self) -> std::string



        Get a description of the object's type.


        """
        return _casadi_core.GenericType_get_description(self, *args)


    def from_type(*args):
        """from_type(casadi::opt_type type) -> GenericType"""
        return _casadi_core.GenericType_from_type(*args)

    if _newclass:
        from_type = staticmethod(from_type)
    __swig_getmethods__["from_type"] = lambda x: from_type

    def getType(self, *args):
        """getType(GenericType self) -> casadi::opt_type"""
        return _casadi_core.GenericType_getType(self, *args)


    def can_cast_to(self, *args):
        """
        can_cast_to(GenericType self, casadi::opt_type other) -> bool
        can_cast_to(GenericType self, GenericType other) -> bool
        """
        return _casadi_core.GenericType_can_cast_to(self, *args)


    def isBool(self, *args):
        """
        isBool(GenericType self) -> bool



        Is boolean?


        """
        return _casadi_core.GenericType_isBool(self, *args)


    def isInt(self, *args):
        """
        isInt(GenericType self) -> bool



        Is an integer?


        """
        return _casadi_core.GenericType_isInt(self, *args)


    def isDouble(self, *args):
        """
        isDouble(GenericType self) -> bool



        Is a double?


        """
        return _casadi_core.GenericType_isDouble(self, *args)


    def isString(self, *args):
        """
        isString(GenericType self) -> bool



        Is a string?


        """
        return _casadi_core.GenericType_isString(self, *args)


    def isEmptyVector(self, *args):
        """
        isEmptyVector(GenericType self) -> bool



        Is an empty vector?


        """
        return _casadi_core.GenericType_isEmptyVector(self, *args)


    def isIntVector(self, *args):
        """
        isIntVector(GenericType self) -> bool



        Is a vector of ints?


        """
        return _casadi_core.GenericType_isIntVector(self, *args)


    def isDoubleVector(self, *args):
        """
        isDoubleVector(GenericType self) -> bool



        Is a vector of doubles?


        """
        return _casadi_core.GenericType_isDoubleVector(self, *args)


    def isStringVector(self, *args):
        """
        isStringVector(GenericType self) -> bool



        Is a vector of strings.


        """
        return _casadi_core.GenericType_isStringVector(self, *args)


    def isSharedObject(self, *args):
        """
        isSharedObject(GenericType self) -> bool



        Is a shared object?


        """
        return _casadi_core.GenericType_isSharedObject(self, *args)


    def isDictionary(self, *args):
        """
        isDictionary(GenericType self) -> bool



        Is a shared object?


        """
        return _casadi_core.GenericType_isDictionary(self, *args)


    def isFunction(self, *args):
        """
        isFunction(GenericType self) -> bool



        Is a shared object?


        """
        return _casadi_core.GenericType_isFunction(self, *args)


    def toBool(self, *args):
        """
        toBool(GenericType self) -> bool



        Convert to boolean.


        """
        return _casadi_core.GenericType_toBool(self, *args)


    def toInt(self, *args):
        """
        toInt(GenericType self) -> int



        Convert to int.


        """
        return _casadi_core.GenericType_toInt(self, *args)


    def toDouble(self, *args):
        """
        toDouble(GenericType self) -> double



        Convert to double.


        """
        return _casadi_core.GenericType_toDouble(self, *args)


    def toString(self, *args):
        """
        toString(GenericType self) -> std::string const &



        Convert to string.


        """
        return _casadi_core.GenericType_toString(self, *args)


    def toIntVector(self, *args):
        """
        toIntVector(GenericType self) -> IVector

        [INTERNAL]  Convert
        to vector of ints.


        """
        return _casadi_core.GenericType_toIntVector(self, *args)


    def toDoubleVector(self, *args):
        """
        toDoubleVector(GenericType self) -> DVector

        [INTERNAL]
        Convert to vector of doubles.


        """
        return _casadi_core.GenericType_toDoubleVector(self, *args)


    def toStringVector(self, *args):
        """
        toStringVector(GenericType self) -> StringVector



        Convert to vector of strings.


        """
        return _casadi_core.GenericType_toStringVector(self, *args)


    def toSharedObject(self, *args):
        """
        toSharedObject(GenericType self) -> SharedObject



        Convert to shared object.


        """
        return _casadi_core.GenericType_toSharedObject(self, *args)


    def toDictionary(self, *args):
        """
        toDictionary(GenericType self) -> Dictionary

        [INTERNAL]
        Convert to Dictionary.


        """
        return _casadi_core.GenericType_toDictionary(self, *args)


    def toFunction(self, *args):
        """
        toFunction(GenericType self) -> Function



        Convert to shared object.


        """
        return _casadi_core.GenericType_toFunction(self, *args)


    def toVoidPointer(self, *args):
        """
        toVoidPointer(GenericType self) -> void *



        Convert to void pointer.


        """
        return _casadi_core.GenericType_toVoidPointer(self, *args)


    def __eq__(self, *args):
        """__eq__(GenericType self, GenericType op2) -> bool"""
        return _casadi_core.GenericType___eq__(self, *args)


    def __ne__(self, *args):
        """__ne__(GenericType self, GenericType op2) -> bool"""
        return _casadi_core.GenericType___ne__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericType self) -> GenericType
        __init__(casadi::GenericType self, bool b) -> GenericType
        __init__(casadi::GenericType self, int i) -> GenericType
        __init__(casadi::GenericType self, double d) -> GenericType
        __init__(casadi::GenericType self, std::string const & s) -> GenericType
        __init__(casadi::GenericType self, BVector iv) -> GenericType
        __init__(casadi::GenericType self, IVector iv) -> GenericType
        __init__(casadi::GenericType self, DVector dv) -> GenericType
        __init__(casadi::GenericType self, StringVector sv) -> GenericType
        __init__(casadi::GenericType self, char const [] s) -> GenericType
        __init__(casadi::GenericType self, Function f) -> GenericType
        __init__(casadi::GenericType self, SharedObject obj) -> GenericType
        __init__(casadi::GenericType self, Dictionary dict) -> GenericType
        __init__(casadi::GenericType self, DerivativeGenerator c) -> GenericType
        __init__(casadi::GenericType self, Callback c) -> GenericType
        __init__(casadi::GenericType self, GenericType other) -> GenericType



        >  casadi::GenericType::GenericType(void *ptr)
        ------------------------------------------------------------------------
        [INTERNAL]

        >  casadi::GenericType::GenericType(const DerivativeGenerator &c)
        ------------------------------------------------------------------------

        Creator functions.


        """
        this = _casadi_core.new_GenericType(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_GenericType
GenericType_swigregister = _casadi_core.GenericType_swigregister
GenericType_swigregister(GenericType)

def GenericType_get_type_description(*args):
    """GenericType_get_type_description(casadi::opt_type const & type) -> std::string"""
    return _casadi_core.GenericType_get_type_description(*args)

def GenericType_from_type(*args):
    """GenericType_from_type(casadi::opt_type type) -> GenericType"""
    return _casadi_core.GenericType_from_type(*args)

class OptionsFunctionality(SharedObject):
    """


    Provides options setting/getting functionality.

    Gives a derived class the ability to set and retrieve options in a
    convenient way. It also contains error checking, making sure that the option
    exists and that the value type is correct.

    A derived class should add option names, types and default values to the
    corresponding vectors.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: options_functionality.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionsFunctionality, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OptionsFunctionality, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi_core.delete_OptionsFunctionality

    def getOption(self, *args):
        """
        getOption(OptionsFunctionality self, std::string const & str) -> GenericType



        get an option value


        """
        return _casadi_core.OptionsFunctionality_getOption(self, *args)


    def hasOption(self, *args):
        """
        hasOption(OptionsFunctionality self, std::string const & str) -> bool



        check if there is an option str


        """
        return _casadi_core.OptionsFunctionality_hasOption(self, *args)


    def hasSetOption(self, *args):
        """
        hasSetOption(OptionsFunctionality self, std::string const & str) -> bool



        check if the user has there is an option str


        """
        return _casadi_core.OptionsFunctionality_hasSetOption(self, *args)


    def printOptions(self, *args):
        """
        printOptions(OptionsFunctionality self, std::ostream & stream)



        Print options to a stream.


        """
        return _casadi_core.OptionsFunctionality_printOptions(self, *args)


    def copyOptions(self, *args):
        """
        copyOptions(OptionsFunctionality self, OptionsFunctionality obj, bool skipUnknown=False)



        Copy all options from another object.


        """
        return _casadi_core.OptionsFunctionality_copyOptions(self, *args)


    def dictionary(self, *args):
        """
        dictionary(OptionsFunctionality self) -> Dictionary



        Get the dictionary.


        """
        return _casadi_core.OptionsFunctionality_dictionary(self, *args)


    def getOptionNames(self, *args):
        """
        getOptionNames(OptionsFunctionality self) -> StringVector



        Get a list of all option names.


        """
        return _casadi_core.OptionsFunctionality_getOptionNames(self, *args)


    def getOptionDescription(self, *args):
        """
        getOptionDescription(OptionsFunctionality self, std::string const & str) -> std::string



        Get the description of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionDescription(self, *args)


    def getOptionType(self, *args):
        """
        getOptionType(OptionsFunctionality self, std::string const & str) -> casadi::opt_type



        Get the type of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionType(self, *args)


    def getOptionTypeName(self, *args):
        """
        getOptionTypeName(OptionsFunctionality self, std::string const & str) -> std::string



        Get the type name of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionTypeName(self, *args)


    def getOptionAllowed(self, *args):
        """
        getOptionAllowed(OptionsFunctionality self, std::string const & str) -> std::vector< casadi::GenericType,std::allocator< casadi::GenericType > >



        Get the allowed values of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionAllowed(self, *args)


    def getOptionAllowedIndex(self, *args):
        """
        getOptionAllowedIndex(OptionsFunctionality self, std::string const & name) -> int

        [INTERNAL]  Get the index into allowed options of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionAllowedIndex(self, *args)


    def setOptionByAllowedIndex(self, *args):
        """
        setOptionByAllowedIndex(OptionsFunctionality self, std::string const & name, int i)

        [INTERNAL]  Set a certain option by giving its index into the allowed
        values.


        """
        return _casadi_core.OptionsFunctionality_setOptionByAllowedIndex(self, *args)


    def getOptionEnumValue(self, *args):
        """
        getOptionEnumValue(OptionsFunctionality self, std::string const & name) -> int

        [INTERNAL]  Get the enum value corresponding to th certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionEnumValue(self, *args)


    def setOptionByEnumValue(self, *args):
        """
        setOptionByEnumValue(OptionsFunctionality self, std::string const & name, int v)

        [INTERNAL]  Set a certain option by giving an enum value.


        """
        return _casadi_core.OptionsFunctionality_setOptionByEnumValue(self, *args)


    def getOptionDefault(self, *args):
        """
        getOptionDefault(OptionsFunctionality self, std::string const & str) -> GenericType



        Get the default of a certain option.


        """
        return _casadi_core.OptionsFunctionality_getOptionDefault(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.OptionsFunctionality_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def setOption(self, *args):
        """
        setOption(OptionsFunctionality self, std::string const & str, GenericType val)
        setOption(OptionsFunctionality self, Dictionary dict, bool skipUnknown=False)
        setOption(OptionsFunctionality self, std::string const & name, std::string const & val)
        setOption(OptionsFunctionality self, std::string const & name, IVector val)
        setOption(OptionsFunctionality self, std::string const & name, DVector val)
        setOption(OptionsFunctionality self, std::string const & name, double val)
        setOption(OptionsFunctionality self, std::string const & name, int val)
        setOption(OptionsFunctionality self, std::string const & name, bool val)



        >  void casadi::OptionsFunctionality::setOption(const std::string &str, const GenericType &val)
        ------------------------------------------------------------------------

        set an option. For a list of options, check the class documentation of this
        class.

        The setOptions are only considered before the init function. If properties
        changes, the init function should be called again.

        >  void casadi::OptionsFunctionality::setOption(const Dictionary &dict, bool skipUnknown=false)
        ------------------------------------------------------------------------

        set a set of options. For a list of options, check the class documentation
        of this class.

        The setOptions are only considered before the init function. If properties
        changes, the init function should be called again.


        """
        return _casadi_core.OptionsFunctionality_setOption(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::OptionsFunctionality self) -> OptionsFunctionality
        __init__(casadi::OptionsFunctionality self, OptionsFunctionality other) -> OptionsFunctionality



        Default constructor.


        """
        this = _casadi_core.new_OptionsFunctionality(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
OptionsFunctionality_swigregister = _casadi_core.OptionsFunctionality_swigregister
OptionsFunctionality_swigregister(OptionsFunctionality)

def OptionsFunctionality_testCast(*args):
    """OptionsFunctionality_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.OptionsFunctionality_testCast(*args)


_casadi_core.M_PI_swigconstant(_casadi_core)
M_PI = _casadi_core.M_PI

_casadi_core.OP_ASSIGN_swigconstant(_casadi_core)
OP_ASSIGN = _casadi_core.OP_ASSIGN

_casadi_core.OP_ADD_swigconstant(_casadi_core)
OP_ADD = _casadi_core.OP_ADD

_casadi_core.OP_SUB_swigconstant(_casadi_core)
OP_SUB = _casadi_core.OP_SUB

_casadi_core.OP_MUL_swigconstant(_casadi_core)
OP_MUL = _casadi_core.OP_MUL

_casadi_core.OP_DIV_swigconstant(_casadi_core)
OP_DIV = _casadi_core.OP_DIV

_casadi_core.OP_NEG_swigconstant(_casadi_core)
OP_NEG = _casadi_core.OP_NEG

_casadi_core.OP_EXP_swigconstant(_casadi_core)
OP_EXP = _casadi_core.OP_EXP

_casadi_core.OP_LOG_swigconstant(_casadi_core)
OP_LOG = _casadi_core.OP_LOG

_casadi_core.OP_POW_swigconstant(_casadi_core)
OP_POW = _casadi_core.OP_POW

_casadi_core.OP_CONSTPOW_swigconstant(_casadi_core)
OP_CONSTPOW = _casadi_core.OP_CONSTPOW

_casadi_core.OP_SQRT_swigconstant(_casadi_core)
OP_SQRT = _casadi_core.OP_SQRT

_casadi_core.OP_SQ_swigconstant(_casadi_core)
OP_SQ = _casadi_core.OP_SQ

_casadi_core.OP_TWICE_swigconstant(_casadi_core)
OP_TWICE = _casadi_core.OP_TWICE

_casadi_core.OP_SIN_swigconstant(_casadi_core)
OP_SIN = _casadi_core.OP_SIN

_casadi_core.OP_COS_swigconstant(_casadi_core)
OP_COS = _casadi_core.OP_COS

_casadi_core.OP_TAN_swigconstant(_casadi_core)
OP_TAN = _casadi_core.OP_TAN

_casadi_core.OP_ASIN_swigconstant(_casadi_core)
OP_ASIN = _casadi_core.OP_ASIN

_casadi_core.OP_ACOS_swigconstant(_casadi_core)
OP_ACOS = _casadi_core.OP_ACOS

_casadi_core.OP_ATAN_swigconstant(_casadi_core)
OP_ATAN = _casadi_core.OP_ATAN

_casadi_core.OP_LT_swigconstant(_casadi_core)
OP_LT = _casadi_core.OP_LT

_casadi_core.OP_LE_swigconstant(_casadi_core)
OP_LE = _casadi_core.OP_LE

_casadi_core.OP_EQ_swigconstant(_casadi_core)
OP_EQ = _casadi_core.OP_EQ

_casadi_core.OP_NE_swigconstant(_casadi_core)
OP_NE = _casadi_core.OP_NE

_casadi_core.OP_NOT_swigconstant(_casadi_core)
OP_NOT = _casadi_core.OP_NOT

_casadi_core.OP_AND_swigconstant(_casadi_core)
OP_AND = _casadi_core.OP_AND

_casadi_core.OP_OR_swigconstant(_casadi_core)
OP_OR = _casadi_core.OP_OR

_casadi_core.OP_FLOOR_swigconstant(_casadi_core)
OP_FLOOR = _casadi_core.OP_FLOOR

_casadi_core.OP_CEIL_swigconstant(_casadi_core)
OP_CEIL = _casadi_core.OP_CEIL

_casadi_core.OP_FMOD_swigconstant(_casadi_core)
OP_FMOD = _casadi_core.OP_FMOD

_casadi_core.OP_FABS_swigconstant(_casadi_core)
OP_FABS = _casadi_core.OP_FABS

_casadi_core.OP_SIGN_swigconstant(_casadi_core)
OP_SIGN = _casadi_core.OP_SIGN

_casadi_core.OP_COPYSIGN_swigconstant(_casadi_core)
OP_COPYSIGN = _casadi_core.OP_COPYSIGN

_casadi_core.OP_IF_ELSE_ZERO_swigconstant(_casadi_core)
OP_IF_ELSE_ZERO = _casadi_core.OP_IF_ELSE_ZERO

_casadi_core.OP_ERF_swigconstant(_casadi_core)
OP_ERF = _casadi_core.OP_ERF

_casadi_core.OP_FMIN_swigconstant(_casadi_core)
OP_FMIN = _casadi_core.OP_FMIN

_casadi_core.OP_FMAX_swigconstant(_casadi_core)
OP_FMAX = _casadi_core.OP_FMAX

_casadi_core.OP_INV_swigconstant(_casadi_core)
OP_INV = _casadi_core.OP_INV

_casadi_core.OP_SINH_swigconstant(_casadi_core)
OP_SINH = _casadi_core.OP_SINH

_casadi_core.OP_COSH_swigconstant(_casadi_core)
OP_COSH = _casadi_core.OP_COSH

_casadi_core.OP_TANH_swigconstant(_casadi_core)
OP_TANH = _casadi_core.OP_TANH

_casadi_core.OP_ASINH_swigconstant(_casadi_core)
OP_ASINH = _casadi_core.OP_ASINH

_casadi_core.OP_ACOSH_swigconstant(_casadi_core)
OP_ACOSH = _casadi_core.OP_ACOSH

_casadi_core.OP_ATANH_swigconstant(_casadi_core)
OP_ATANH = _casadi_core.OP_ATANH

_casadi_core.OP_ATAN2_swigconstant(_casadi_core)
OP_ATAN2 = _casadi_core.OP_ATAN2

_casadi_core.OP_CONST_swigconstant(_casadi_core)
OP_CONST = _casadi_core.OP_CONST

_casadi_core.OP_INPUT_swigconstant(_casadi_core)
OP_INPUT = _casadi_core.OP_INPUT

_casadi_core.OP_OUTPUT_swigconstant(_casadi_core)
OP_OUTPUT = _casadi_core.OP_OUTPUT

_casadi_core.OP_PARAMETER_swigconstant(_casadi_core)
OP_PARAMETER = _casadi_core.OP_PARAMETER

_casadi_core.OP_CALL_swigconstant(_casadi_core)
OP_CALL = _casadi_core.OP_CALL

_casadi_core.OP_MATMUL_swigconstant(_casadi_core)
OP_MATMUL = _casadi_core.OP_MATMUL

_casadi_core.OP_SOLVE_swigconstant(_casadi_core)
OP_SOLVE = _casadi_core.OP_SOLVE

_casadi_core.OP_TRANSPOSE_swigconstant(_casadi_core)
OP_TRANSPOSE = _casadi_core.OP_TRANSPOSE

_casadi_core.OP_DETERMINANT_swigconstant(_casadi_core)
OP_DETERMINANT = _casadi_core.OP_DETERMINANT

_casadi_core.OP_INVERSE_swigconstant(_casadi_core)
OP_INVERSE = _casadi_core.OP_INVERSE

_casadi_core.OP_INNER_PROD_swigconstant(_casadi_core)
OP_INNER_PROD = _casadi_core.OP_INNER_PROD

_casadi_core.OP_HORZCAT_swigconstant(_casadi_core)
OP_HORZCAT = _casadi_core.OP_HORZCAT

_casadi_core.OP_VERTCAT_swigconstant(_casadi_core)
OP_VERTCAT = _casadi_core.OP_VERTCAT

_casadi_core.OP_DIAGCAT_swigconstant(_casadi_core)
OP_DIAGCAT = _casadi_core.OP_DIAGCAT

_casadi_core.OP_HORZSPLIT_swigconstant(_casadi_core)
OP_HORZSPLIT = _casadi_core.OP_HORZSPLIT

_casadi_core.OP_VERTSPLIT_swigconstant(_casadi_core)
OP_VERTSPLIT = _casadi_core.OP_VERTSPLIT

_casadi_core.OP_DIAGSPLIT_swigconstant(_casadi_core)
OP_DIAGSPLIT = _casadi_core.OP_DIAGSPLIT

_casadi_core.OP_RESHAPE_swigconstant(_casadi_core)
OP_RESHAPE = _casadi_core.OP_RESHAPE

_casadi_core.OP_SUBREF_swigconstant(_casadi_core)
OP_SUBREF = _casadi_core.OP_SUBREF

_casadi_core.OP_SUBASSIGN_swigconstant(_casadi_core)
OP_SUBASSIGN = _casadi_core.OP_SUBASSIGN

_casadi_core.OP_GETNONZEROS_swigconstant(_casadi_core)
OP_GETNONZEROS = _casadi_core.OP_GETNONZEROS

_casadi_core.OP_ADDNONZEROS_swigconstant(_casadi_core)
OP_ADDNONZEROS = _casadi_core.OP_ADDNONZEROS

_casadi_core.OP_SETNONZEROS_swigconstant(_casadi_core)
OP_SETNONZEROS = _casadi_core.OP_SETNONZEROS

_casadi_core.OP_SET_SPARSE_swigconstant(_casadi_core)
OP_SET_SPARSE = _casadi_core.OP_SET_SPARSE

_casadi_core.OP_ASSERTION_swigconstant(_casadi_core)
OP_ASSERTION = _casadi_core.OP_ASSERTION

_casadi_core.OP_NORM2_swigconstant(_casadi_core)
OP_NORM2 = _casadi_core.OP_NORM2

_casadi_core.OP_NORM1_swigconstant(_casadi_core)
OP_NORM1 = _casadi_core.OP_NORM1

_casadi_core.OP_NORMINF_swigconstant(_casadi_core)
OP_NORMINF = _casadi_core.OP_NORMINF

_casadi_core.OP_NORMF_swigconstant(_casadi_core)
OP_NORMF = _casadi_core.OP_NORMF

_casadi_core.OP_ERFINV_swigconstant(_casadi_core)
OP_ERFINV = _casadi_core.OP_ERFINV

_casadi_core.OP_PRINTME_swigconstant(_casadi_core)
OP_PRINTME = _casadi_core.OP_PRINTME

_casadi_core.OP_LIFT_swigconstant(_casadi_core)
OP_LIFT = _casadi_core.OP_LIFT

_casadi_core.NUM_BUILT_IN_OPS_swigconstant(_casadi_core)
NUM_BUILT_IN_OPS = _casadi_core.NUM_BUILT_IN_OPS
class Sparsity(SharedObject):
    """


    General sparsity class.

    The storage format is a compressed column storage (CCS) format.  In this
    format, the structural non-zero elements are stored in column-major order,
    starting from the upper left corner of the matrix and ending in the lower
    right corner.

    In addition to the dimension ( size1(), size2()), (i.e. the number of rows
    and the number of columns respectively), there are also two vectors of
    integers:

    "colind" [length size2()+1], which contains the index to the first non-
    zero element on or after the corresponding column. All the non-zero elements
    of a particular i are thus the elements with index el that fulfills:
    colind[i] <= el < colind[i+1].

    "row" [same length as the number of non-zero elements, size()] The rows
    for each of the structural non-zeros.

    Note that with this format, it is cheap to loop over all the non-zero
    elements of a particular column, at constant time per element, but expensive
    to jump to access a location (i, j).

    If the matrix is dense, i.e. length(row) == size1()*size2(), the format
    reduces to standard dense column major format, which allows access to an
    arbitrary element in constant time.

    Since the object is reference counted (it inherits from SharedObject),
    several matrices are allowed to share the same sparsity pattern.

    The implementations of some methods of this class has been taken from the
    CSparse package and modified to use C++ standard library and CasADi data
    structures.

    See:   Matrix

    Joel Andersson

    C++ includes: sparsity.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sparsity, name)
    __repr__ = _swig_repr

    def scalar(*args):
        """
        scalar(bool dense_scalar=True) -> Sparsity



        Create a scalar sparsity pattern.


        """
        return _casadi_core.Sparsity_scalar(*args)

    if _newclass:
        scalar = staticmethod(scalar)
    __swig_getmethods__["scalar"] = lambda x: scalar

    def dense(*args):
        """
        dense(int nrow, int ncol=1) -> Sparsity
        dense(Pair_Int_Int rc) -> Sparsity



        Create a dense rectangular sparsity pattern.


        """
        return _casadi_core.Sparsity_dense(*args)

    if _newclass:
        dense = staticmethod(dense)
    __swig_getmethods__["dense"] = lambda x: dense

    def sparse(*args):
        """
        sparse(int nrow, int ncol=1) -> Sparsity
        sparse(Pair_Int_Int rc) -> Sparsity



        Create a sparse (empty) rectangular sparsity pattern.


        """
        return _casadi_core.Sparsity_sparse(*args)

    if _newclass:
        sparse = staticmethod(sparse)
    __swig_getmethods__["sparse"] = lambda x: sparse

    def unit(*args):
        """
        unit(int n, int el) -> Sparsity



        Create the sparsity pattern for a unit vector of length n and a nonzero on
        position el.


        """
        return _casadi_core.Sparsity_unit(*args)

    if _newclass:
        unit = staticmethod(unit)
    __swig_getmethods__["unit"] = lambda x: unit

    def triu(*args):
        """triu(int n) -> Sparsity"""
        return _casadi_core.Sparsity_triu(*args)

    if _newclass:
        triu = staticmethod(triu)
    __swig_getmethods__["triu"] = lambda x: triu

    def tril(*args):
        """tril(int n) -> Sparsity"""
        return _casadi_core.Sparsity_tril(*args)

    if _newclass:
        tril = staticmethod(tril)
    __swig_getmethods__["tril"] = lambda x: tril

    def diag(*args):
        """
        diag(int nrow) -> Sparsity
        diag(int nrow, int ncol) -> Sparsity
        diag(Pair_Int_Int rc) -> Sparsity



        Create diagonal sparsity pattern.


        """
        return _casadi_core.Sparsity_diag(*args)

    if _newclass:
        diag = staticmethod(diag)
    __swig_getmethods__["diag"] = lambda x: diag

    def band(*args):
        """band(int n, int p) -> Sparsity"""
        return _casadi_core.Sparsity_band(*args)

    if _newclass:
        band = staticmethod(band)
    __swig_getmethods__["band"] = lambda x: band

    def banded(*args):
        """banded(int n, int p) -> Sparsity"""
        return _casadi_core.Sparsity_banded(*args)

    if _newclass:
        banded = staticmethod(banded)
    __swig_getmethods__["banded"] = lambda x: banded

    def rowcol(*args):
        """rowcol(IVector row, IVector col, int nrow, int ncol) -> Sparsity"""
        return _casadi_core.Sparsity_rowcol(*args)

    if _newclass:
        rowcol = staticmethod(rowcol)
    __swig_getmethods__["rowcol"] = lambda x: rowcol

    def triplet(*args):
        """
        triplet(int nrow, int ncol, IVector row, IVector col, IVector mapping, bool invert_mapping=False) -> Sparsity
        triplet(int nrow, int ncol, IVector row, IVector col) -> Sparsity
        """
        return _casadi_core.Sparsity_triplet(*args)

    if _newclass:
        triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet

    def compressed(*args):
        """
        compressed(IVector v) -> Sparsity



        >  Sparsity casadi::Sparsity::compressed(const std::vector< int > &v)
        ------------------------------------------------------------------------

        Create from a single vector containing the pattern in compressed column
        storage format: The format: The first two entries are the number of rows
        (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
        (colind). Note that the last element, colind[ncol], gives the number of
        nonzeros The last colind[ncol] entries are the row indices

        >  Sparsity casadi::Sparsity::compressed(const int *v)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Create from a single vector containing the pattern in compressed
        column storage format: The format: The first two entries are the
        number of rows (nrow) and columns (ncol) The next ncol+1 entries are
        the column offsets (colind). Note that the last element, colind[ncol],
        gives the number of nonzeros The last colind[ncol] entries are the row
        indices


        """
        return _casadi_core.Sparsity_compressed(*args)

    if _newclass:
        compressed = staticmethod(compressed)
    __swig_getmethods__["compressed"] = lambda x: compressed

    def reCache(self, *args):
        """
        reCache(Sparsity self)

        [INTERNAL]  Check if there
        is an identical copy of the sparsity pattern in the cache, and if so, make a
        shallow copy of that one.


        """
        return _casadi_core.Sparsity_reCache(self, *args)


    def clearCache(*args):
        """clearCache()"""
        return _casadi_core.Sparsity_clearCache(*args)

    if _newclass:
        clearCache = staticmethod(clearCache)
    __swig_getmethods__["clearCache"] = lambda x: clearCache

    def sanityCheck(self, *args):
        """
        sanityCheck(Sparsity self, bool complete=False)



        Check if the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi_core.Sparsity_sanityCheck(self, *args)


    def getDiag(self, *args):
        """
        getDiag(Sparsity self) -> Sparsity



        Get the diagonal of the matrix/create a diagonal matrix (mapping will
        contain the nonzero mapping) When the input is square, the diagonal elements
        are returned. If the input is vector-like, a diagonal matrix is constructed
        with it.


        """
        return _casadi_core.Sparsity_getDiag(self, *args)


    def compress(self, *args):
        """
        compress(Sparsity self) -> IVector



        Compress a sparsity pattern.


        """
        return _casadi_core.Sparsity_compress(self, *args)


    def isEqual(self, *args):
        """
        isEqual(Sparsity self, Sparsity y) -> bool
        isEqual(Sparsity self, int nrow, int ncol, IVector colind, IVector row) -> bool
        """
        return _casadi_core.Sparsity_isEqual(self, *args)


    def __eq__(self, *args):
        """__eq__(Sparsity self, Sparsity y) -> bool"""
        return _casadi_core.Sparsity___eq__(self, *args)


    def __ne__(self, *args):
        """__ne__(Sparsity self, Sparsity y) -> bool"""
        return _casadi_core.Sparsity___ne__(self, *args)


    def size1(self, *args):
        """
        size1(Sparsity self) -> int



        Get the number of rows.


        """
        return _casadi_core.Sparsity_size1(self, *args)


    def size2(self, *args):
        """
        size2(Sparsity self) -> int



        Get the number of columns.


        """
        return _casadi_core.Sparsity_size2(self, *args)


    def numel(self, *args):
        """
        numel(Sparsity self) -> int



        The total number of elements, including structural zeros, i.e.
        size2()*size1()

        See:   size()


        """
        return _casadi_core.Sparsity_numel(self, *args)


    def isEmpty(self, *args):
        """
        isEmpty(Sparsity self, bool both=False) -> bool



        Check if the sparsity is empty.

        A sparsity is considered empty if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi_core.Sparsity_isEmpty(self, *args)


    def size(self, *args):
        """
        size(Sparsity self) -> int



        Get the number of (structural) non-zeros.

        See:   numel()


        """
        return _casadi_core.Sparsity_size(self, *args)


    def sizeU(self, *args):
        """
        sizeU(Sparsity self) -> int



        Number of non-zeros in the upper triangular half, i.e. the number of
        elements (i, j) with j>=i.


        """
        return _casadi_core.Sparsity_sizeU(self, *args)


    def sizeL(self, *args):
        """
        sizeL(Sparsity self) -> int



        Number of non-zeros in the lower triangular half, i.e. the number of
        elements (i, j) with j<=i.


        """
        return _casadi_core.Sparsity_sizeL(self, *args)


    def sizeD(self, *args):
        """
        sizeD(Sparsity self) -> int



        Number of non-zeros on the diagonal, i.e. the number of elements (i, j) with
        j==i.


        """
        return _casadi_core.Sparsity_sizeD(self, *args)


    def bandwidthU(self, *args):
        """
        bandwidthU(Sparsity self) -> int



        Upper half-bandwidth.


        """
        return _casadi_core.Sparsity_bandwidthU(self, *args)


    def bandwidthL(self, *args):
        """
        bandwidthL(Sparsity self) -> int



        Lower half-bandwidth.


        """
        return _casadi_core.Sparsity_bandwidthL(self, *args)


    def row(self, *args):
        """
        row(Sparsity self) -> IVector
        row(Sparsity self, int el) -> int



        >  const std::vector< int > & casadi::Sparsity::row() const 
        ------------------------------------------------------------------------

        Get a reference to row-vector, containing rows for all non-zero elements
        (see class description)

        >  int casadi::Sparsity::row(int el) const 
        ------------------------------------------------------------------------

        Get the row of a non-zero element.


        """
        return _casadi_core.Sparsity_row(self, *args)


    def colind(self, *args):
        """
        colind(Sparsity self) -> IVector
        colind(Sparsity self, int i) -> int



        >  const std::vector< int > & casadi::Sparsity::colind() const 
        ------------------------------------------------------------------------

        Get a reference to the colindex of all column element (see class
        description)

        >  int casadi::Sparsity::colind(int i) const 
        ------------------------------------------------------------------------

        Get a reference to the colindex of col i (see class description)


        """
        return _casadi_core.Sparsity_colind(self, *args)


    def getCol(self, *args):
        """
        getCol(Sparsity self) -> IVector



        Get the column for each non-zero entry Together with the row-vector, this
        vector gives the sparsity of the matrix in sparse triplet format, i.e. the
        column and row for each non-zero elements.


        """
        return _casadi_core.Sparsity_getCol(self, *args)


    def resize(self, *args):
        """
        resize(Sparsity self, int nrow, int ncol)



        Resize.


        """
        return _casadi_core.Sparsity_resize(self, *args)


    def reshape(self, *args):
        """
        reshape(Sparsity self, int nrow, int ncol) -> Sparsity



        Reshape a sparsity, order of nonzeros remains the same.


        """
        return _casadi_core.Sparsity_reshape(self, *args)


    def getNZ_const(self, *args):
        """
        getNZ_const(Sparsity self, int rr, int cc) -> int



        >  int casadi::Sparsity::getNZ(int rr, int cc)
        ------------------------------------------------------------------------

        Get the index of a non-zero element Add the element if it does not exist and
        copy object if it's not unique.

        >  int casadi::Sparsity::getNZ(int rr, int cc) const 
        ------------------------------------------------------------------------

        Get the index of an existing non-zero element return -1 if the element does
        not exist.

        >  std::vector< int > casadi::Sparsity::getNZ(const std::vector< int > &rr, const std::vector< int > &cc) const 
        ------------------------------------------------------------------------

        Get a set of non-zero element return -1 if the element does not exist.


        """
        return _casadi_core.Sparsity_getNZ_const(self, *args)


    def hasNZ(self, *args):
        """
        hasNZ(Sparsity self, int rr, int cc) -> bool



        Returns true if the pattern has a non-zero at location rr, cc.


        """
        return _casadi_core.Sparsity_hasNZ(self, *args)


    def getNZ(self, *args):
        """
        getNZ(Sparsity self, int rr, int cc) -> int
        getNZ(Sparsity self, IVector rr, IVector cc) -> IVector



        >  int casadi::Sparsity::getNZ(int rr, int cc)
        ------------------------------------------------------------------------

        Get the index of a non-zero element Add the element if it does not exist and
        copy object if it's not unique.

        >  int casadi::Sparsity::getNZ(int rr, int cc) const 
        ------------------------------------------------------------------------

        Get the index of an existing non-zero element return -1 if the element does
        not exist.

        >  std::vector< int > casadi::Sparsity::getNZ(const std::vector< int > &rr, const std::vector< int > &cc) const 
        ------------------------------------------------------------------------

        Get a set of non-zero element return -1 if the element does not exist.


        """
        return _casadi_core.Sparsity_getNZ(self, *args)


    def getNZInplace(self, *args):
        """
        getNZInplace(Sparsity self, IVector indices)



        Get the nonzero index for a set of elements The index vector is used both
        for input and outputs and must be sorted by increasing nonzero index, i.e.
        column-wise. Elements not found in the sparsity pattern are set to -1.


        """
        return _casadi_core.Sparsity_getNZInplace(self, *args)


    def getLowerNZ(self, *args):
        """
        getLowerNZ(Sparsity self) -> IVector



        Get nonzeros in lower triangular part.


        """
        return _casadi_core.Sparsity_getLowerNZ(self, *args)


    def getUpperNZ(self, *args):
        """
        getUpperNZ(Sparsity self) -> IVector



        Get nonzeros in upper triangular part.


        """
        return _casadi_core.Sparsity_getUpperNZ(self, *args)


    def getCCS(self, *args):
        """
        getCCS(Sparsity self)



        Get the sparsity in compressed column storage (CCS) format.


        """
        return _casadi_core.Sparsity_getCCS(self, *args)


    def getCRS(self, *args):
        """
        getCRS(Sparsity self)



        Get the sparsity in compressed row storage (CRS) format.


        """
        return _casadi_core.Sparsity_getCRS(self, *args)


    def getTriplet(self, *args):
        """
        getTriplet(Sparsity self)



        Get the sparsity in sparse triplet format.


        """
        return _casadi_core.Sparsity_getTriplet(self, *args)


    def sub(self, *args):
        """
        sub(Sparsity self, IVector jj, IVector ii) -> Sparsity



        Get a submatrix.

        Returns the sparsity of the submatrix, with a mapping such that submatrix[k]
        = originalmatrix[mapping[k]]


        """
        return _casadi_core.Sparsity_sub(self, *args)


    def transpose(self, *args):
        """
        transpose(Sparsity self) -> Sparsity
        transpose(Sparsity self, IVector mapping, bool invert_mapping=False) -> Sparsity



        >  Sparsity casadi::Sparsity::transpose() const 
        ------------------------------------------------------------------------

        Transpose the matrix.

        >  Sparsity casadi::Sparsity::transpose(std::vector< int > &mapping, bool invert_mapping=false) const 
        ------------------------------------------------------------------------

        Transpose the matrix and get the reordering of the non-zero entries.

        Parameters:
        -----------

        mapping:  the non-zeros of the original matrix for each non-zero of the new
        matrix


        """
        return _casadi_core.Sparsity_transpose(self, *args)


    def isTranspose(self, *args):
        """
        isTranspose(Sparsity self, Sparsity y) -> bool



        Check if the sparsity is the transpose of another.


        """
        return _casadi_core.Sparsity_isTranspose(self, *args)


    def isReshape(self, *args):
        """
        isReshape(Sparsity self, Sparsity y) -> bool



        Check if the sparsity is a reshape of another.


        """
        return _casadi_core.Sparsity_isReshape(self, *args)


    def patternCombine(self, *args):
        """
        patternCombine(Sparsity self, Sparsity y, bool f0x_is_zero, bool function0_is_zero) -> Sparsity
        patternCombine(Sparsity self, Sparsity y, bool f0x_is_zero, bool function0_is_zero) -> Sparsity



        Combine two sparsity patterns Returns the new sparsity pattern as well as a
        mapping with the same length as the number of non-zero elements The mapping
        matrix contains the arguments for each nonzero, the first bit indicates if
        the first argument is nonzero, the second bit indicates if the second
        argument is nonzero (note that none of, one of or both of the arguments can
        be nonzero)


        """
        return _casadi_core.Sparsity_patternCombine(self, *args)


    def patternUnion(self, *args):
        """
        patternUnion(Sparsity self, Sparsity y) -> Sparsity
        patternUnion(Sparsity self, Sparsity y) -> Sparsity



        Union of two sparsity patterns.


        """
        return _casadi_core.Sparsity_patternUnion(self, *args)


    def __add__(self, *args):
        """__add__(Sparsity self, Sparsity b) -> Sparsity"""
        return _casadi_core.Sparsity___add__(self, *args)


    def patternIntersection(self, *args):
        """
        patternIntersection(Sparsity self, Sparsity y) -> Sparsity
        patternIntersection(Sparsity self, Sparsity y) -> Sparsity



        Intersection of two sparsity patterns Returns the new sparsity pattern as
        well as a mapping with the same length as the number of non-zero elements
        The value is 1 if the non-zero comes from the first (i.e. this) object, 2 if
        it is from the second and 3 (i.e. 1 | 2) if from both.


        """
        return _casadi_core.Sparsity_patternIntersection(self, *args)


    def __mul__(self, *args):
        """__mul__(Sparsity self, Sparsity b) -> Sparsity"""
        return _casadi_core.Sparsity___mul__(self, *args)


    def patternProduct(self, *args):
        """
        patternProduct(Sparsity self, Sparsity x_trans, std::vector< std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >,std::allocator< std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > > > & OUTPUT) -> Sparsity
        patternProduct(Sparsity self, Sparsity x_trans) -> Sparsity



        Sparsity pattern for a matrix-matrix product [deprecated] Returns the
        sparsity pattern resulting from pre-multiplying the pattern with the
        transpose of x. Returns the new sparsity pattern as well as a mapping with
        the same length as the number of non-zero elements The mapping contains a
        vector of the index pairs that makes up the scalar products for each non-
        zero.


        """
        return _casadi_core.Sparsity_patternProduct(self, *args)


    def patternProductNew(self, *args):
        """
        patternProductNew(Sparsity self, Sparsity y) -> Sparsity



        Sparsity pattern for a matrix-matrix product Returns the sparsity pattern
        resulting from multiplying the pattern with another pattern y from the
        right.

        This will replace patternProduct after deprecation.


        """
        return _casadi_core.Sparsity_patternProductNew(self, *args)


    def patternInverse(self, *args):
        """
        patternInverse(Sparsity self) -> Sparsity



        Take the inverse of a sparsity pattern; flip zeros and non-zeros.


        """
        return _casadi_core.Sparsity_patternInverse(self, *args)


    def enlarge(self, *args):
        """
        enlarge(Sparsity self, int nrow, int ncol, IVector jj, IVector ii)



        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.

        For the matrices A to B A(m, n) length(jj)=m , length(ii)=n B(nrow, ncol)

        A=enlarge(m, n, ii, jj) makes sure that

        B[jj, ii] == A


        """
        return _casadi_core.Sparsity_enlarge(self, *args)


    def enlargeRows(self, *args):
        """
        enlargeRows(Sparsity self, int nrow, IVector jj)



        Enlarge the matrix along the first dimension (i.e. insert rows)


        """
        return _casadi_core.Sparsity_enlargeRows(self, *args)


    def enlargeColumns(self, *args):
        """
        enlargeColumns(Sparsity self, int ncol, IVector ii)



        Enlarge the matrix along the second dimension (i.e. insert columns)


        """
        return _casadi_core.Sparsity_enlargeColumns(self, *args)


    def makeDense(self, *args):
        """
        makeDense(Sparsity self, IVector mapping) -> Sparsity



        Make a patten dense.


        """
        return _casadi_core.Sparsity_makeDense(self, *args)


    def erase(self, *args):
        """
        erase(Sparsity self, IVector jj, IVector ii) -> IVector



        Erase rows and/or columns of a matrix.


        """
        return _casadi_core.Sparsity_erase(self, *args)


    def append(self, *args):
        """
        append(Sparsity self, Sparsity sp)



        Append another sparsity patten vertically (NOTE: only efficient if vector)


        """
        return _casadi_core.Sparsity_append(self, *args)


    def appendColumns(self, *args):
        """
        appendColumns(Sparsity self, Sparsity sp)



        Append another sparsity patten horizontally.


        """
        return _casadi_core.Sparsity_appendColumns(self, *args)


    def reserve(self, *args):
        """
        reserve(Sparsity self, int nnz, int ncol)



        Reserve space.


        """
        return _casadi_core.Sparsity_reserve(self, *args)


    def isScalar(self, *args):
        """
        isScalar(Sparsity self, bool scalar_and_dense=False) -> bool



        Is scalar?


        """
        return _casadi_core.Sparsity_isScalar(self, *args)


    def isDense(self, *args):
        """
        isDense(Sparsity self) -> bool



        Is dense?


        """
        return _casadi_core.Sparsity_isDense(self, *args)


    def isVector(self, *args):
        """
        isVector(Sparsity self) -> bool



        Is vector (i.e. size2()==1)


        """
        return _casadi_core.Sparsity_isVector(self, *args)


    def isDiagonal(self, *args):
        """
        isDiagonal(Sparsity self) -> bool



        Is diagonal?


        """
        return _casadi_core.Sparsity_isDiagonal(self, *args)


    def isSquare(self, *args):
        """
        isSquare(Sparsity self) -> bool



        Is square?


        """
        return _casadi_core.Sparsity_isSquare(self, *args)


    def isSymmetric(self, *args):
        """
        isSymmetric(Sparsity self) -> bool



        Is symmetric?


        """
        return _casadi_core.Sparsity_isSymmetric(self, *args)


    def isTriu(self, *args):
        """
        isTriu(Sparsity self) -> bool



        Is upper triangular?


        """
        return _casadi_core.Sparsity_isTriu(self, *args)


    def isTril(self, *args):
        """
        isTril(Sparsity self) -> bool



        Is lower triangular?


        """
        return _casadi_core.Sparsity_isTril(self, *args)


    def isSingular(self, *args):
        """
        isSingular(Sparsity self) -> bool



        Check whether the sparsity-pattern indicates structural singularity.


        """
        return _casadi_core.Sparsity_isSingular(self, *args)


    def getTriu(self, *args):
        """
        getTriu(Sparsity self, bool includeDiagonal=True) -> Sparsity



        Get upper triangular part.


        """
        return _casadi_core.Sparsity_getTriu(self, *args)


    def getTril(self, *args):
        """
        getTril(Sparsity self, bool includeDiagonal=True) -> Sparsity



        Get lower triangular part.


        """
        return _casadi_core.Sparsity_getTril(self, *args)


    def rowsSequential(self, *args):
        """
        rowsSequential(Sparsity self, bool strictly=True) -> bool



        Do the rows appear sequentially on each column.

        Parameters:
        -----------

        strictly:  if true, then do not allow multiple entries


        """
        return _casadi_core.Sparsity_rowsSequential(self, *args)


    def removeDuplicates(self, *args):
        """
        removeDuplicates(Sparsity self, IVector mapping)



        Remove duplicate entries.

        The same indices will be removed from the mapping vector, which must have
        the same length as the number of nonzeros


        """
        return _casadi_core.Sparsity_removeDuplicates(self, *args)


    def eliminationTree(self, *args):
        """
        eliminationTree(Sparsity self, bool ata=False) -> IVector



        Calculate the elimination tree See Direct Methods for Sparse Linear Systems
        by Davis (2006). If the parameter ata is false, the algorithm is equivalent
        to Matlab's etree(A), except that the indices are zero- based. If ata is
        true, the algorithm is equivalent to Matlab's etree(A, 'row').


        """
        return _casadi_core.Sparsity_eliminationTree(self, *args)


    def depthFirstSearch(self, *args):
        """
        depthFirstSearch(Sparsity self, int j, int top, IVector xi, IVector pstack, IVector pinv, BVector marked) -> int



        Depth-first search on the adjacency graph of the sparsity See Direct Methods
        for Sparse Linear Systems by Davis (2006).


        """
        return _casadi_core.Sparsity_depthFirstSearch(self, *args)


    def stronglyConnectedComponents(self, *args):
        """
        stronglyConnectedComponents(Sparsity self) -> int



        Find the strongly connected components of the bigraph defined by the
        sparsity pattern of a square matrix.

        See Direct Methods for Sparse Linear Systems by Davis (2006). Returns:
        Number of components

        Offset for each components (length: 1 + number of components)

        Indices for each components, component i has indices index[offset[i]], ...,
        index[offset[i+1]]

        In the case that the matrix is symmetric, the result has a particular
        interpretation: Given a symmetric matrix A and n =
        A.stronglyConnectedComponents(p, r)

        => A[p, p] will appear block-diagonal with n blocks and with the indices of
        the block boundaries to be found in r.


        """
        return _casadi_core.Sparsity_stronglyConnectedComponents(self, *args)


    def dulmageMendelsohn(self, *args):
        """
        dulmageMendelsohn(Sparsity self, int seed=0) -> int



        Compute the Dulmage-Mendelsohn decomposition See Direct Methods for Sparse
        Linear Systems by Davis (2006).

        Dulmage-Mendelsohn will try to bring your matrix into lower block-
        triangular (LBT) form. It will not care about the distance of off- diagonal
        elements to the diagonal: there is no guarantee you will get a block-
        diagonal matrix if you supply a randomly permuted block- diagonal matrix.

        If your matrix is symmetrical, this method is of limited use; permutation
        can make it non-symmetric.

        See:   stronglyConnectedComponents


        """
        return _casadi_core.Sparsity_dulmageMendelsohn(self, *args)


    def getElements(self, *args):
        """
        getElements(Sparsity self, bool col_major=True) -> IVector
        getElements(Sparsity self, IVector loc, bool col_major=True)



        >  std::vector< int > casadi::Sparsity::getElements(bool col_major=true) const 
        ------------------------------------------------------------------------

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.getElements() A[k] will contain the elements of A that are non- zero
        in B

        >  void casadi::Sparsity::getElements(std::vector< int > &loc, bool col_major=true) const 
        ------------------------------------------------------------------------

        Get the location of all nonzero elements (inplace version)


        """
        return _casadi_core.Sparsity_getElements(self, *args)


    def unidirectionalColoring(self, *args):
        """
        unidirectionalColoring(Sparsity self, Sparsity AT, int cutoff) -> Sparsity



        Perform a unidirectional coloring: A greedy distance-2 coloring algorithm
        (Algorithm 3.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN)


        """
        return _casadi_core.Sparsity_unidirectionalColoring(self, *args)


    def starColoring(self, *args):
        """
        starColoring(Sparsity self, int ordering=1, int cutoff) -> Sparsity



        Perform a star coloring of a symmetric matrix: A greedy distance-2 coloring
        algorithm (Algorithm 4.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN) Ordering
        options: None (0), largest first (1)


        """
        return _casadi_core.Sparsity_starColoring(self, *args)


    def starColoring2(self, *args):
        """
        starColoring2(Sparsity self, int ordering=1, int cutoff) -> Sparsity



        Perform a star coloring of a symmetric matrix: A new greedy distance-2
        coloring algorithm (Algorithm 4.1 in A. H. GEBREMEDHIN, A. TARAFDAR, F.
        MANNE, A. POTHEN) Ordering options: None (0), largest first (1)


        """
        return _casadi_core.Sparsity_starColoring2(self, *args)


    def largestFirstOrdering(self, *args):
        """
        largestFirstOrdering(Sparsity self) -> IVector



        Order the cols by decreasing degree.


        """
        return _casadi_core.Sparsity_largestFirstOrdering(self, *args)


    def pmult(self, *args):
        """
        pmult(Sparsity self, IVector p, bool permute_rows=True, bool permute_cols=True, bool invert_permutation=False) -> Sparsity



        Permute rows and/or columns Multiply the sparsity with a permutation matrix
        from the left and/or from the right P * A * trans(P), A * trans(P) or A *
        trans(P) with P defined by an index vector containing the row for each col.
        As an alternative, P can be transposed (inverted).


        """
        return _casadi_core.Sparsity_pmult(self, *args)


    def dimString(self, *args):
        """
        dimString(Sparsity self) -> std::string



        Get the dimension as a string.


        """
        return _casadi_core.Sparsity_dimString(self, *args)


    def spy(self, *args):
        """
        spy(Sparsity self, std::ostream & stream)



        Print a textual representation of sparsity.


        """
        return _casadi_core.Sparsity_spy(self, *args)


    def spyMatlab(self, *args):
        """
        spyMatlab(Sparsity self, std::string const & mfile)



        Generate a script for Matlab or Octave which visualizes the sparsity using
        the spy command.


        """
        return _casadi_core.Sparsity_spyMatlab(self, *args)


    def printCompact(self, *args):
        """
        printCompact(Sparsity self, std::ostream & stream)



        Print a compact description of the sparsity pattern.


        """
        return _casadi_core.Sparsity_printCompact(self, *args)


    def hash(self, *args):
        """hash(Sparsity self) -> std::size_t"""
        return _casadi_core.Sparsity_hash(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.Sparsity_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)



    def __setstate__(self, state):
        if state:
          self.__init__(state["nrow"],state["ncol"],state["colind"],state["row"])
        else:
          self.__init__()

    def __getstate__(self):
        if self.isNull(): return {}
        return {"nrow": self.size1(), "ncol": self.size2(), "colind": numpy.array(self.colind(),dtype=int), "row": numpy.array(self.row(),dtype=int)}


    @property
    def shape(self):
        return (self.size1(),self.size2())

    @property
    def T(self):
        return self.transpose()

    def __array__(self,*args,**kwargs):
        return DMatrix(self,1).toArray()


    def __init__(self, *args):
        """
        __init__(casadi::Sparsity self, int dummy=0) -> Sparsity
        __init__(casadi::Sparsity self, int nrow, int ncol, IVector colind, IVector row) -> Sparsity
        __init__(casadi::Sparsity self, Sparsity other) -> Sparsity



        >  casadi::Sparsity::Sparsity(int dummy=0)
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::Sparsity::Sparsity(int nrow, int ncol, const std::vector< int > &colind, const std::vector< int > &row)
        ------------------------------------------------------------------------

        Construct from sparsity pattern vectors given in compressed column storage
        format.


        """
        this = _casadi_core.new_Sparsity(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Sparsity
Sparsity_swigregister = _casadi_core.Sparsity_swigregister
Sparsity_swigregister(Sparsity)

def Sparsity_scalar(*args):
    """
    Sparsity_scalar(bool dense_scalar=True) -> Sparsity



    Create a scalar sparsity pattern.


    """
    return _casadi_core.Sparsity_scalar(*args)

def Sparsity_dense(*args):
    """
    dense(int nrow, int ncol=1) -> Sparsity
    Sparsity_dense(Pair_Int_Int rc) -> Sparsity



    Create a dense rectangular sparsity pattern.


    """
    return _casadi_core.Sparsity_dense(*args)

def Sparsity_sparse(*args):
    """
    sparse(int nrow, int ncol=1) -> Sparsity
    Sparsity_sparse(Pair_Int_Int rc) -> Sparsity



    Create a sparse (empty) rectangular sparsity pattern.


    """
    return _casadi_core.Sparsity_sparse(*args)

def Sparsity_unit(*args):
    """
    Sparsity_unit(int n, int el) -> Sparsity



    Create the sparsity pattern for a unit vector of length n and a nonzero on
    position el.


    """
    return _casadi_core.Sparsity_unit(*args)

def Sparsity_triu(*args):
    """Sparsity_triu(int n) -> Sparsity"""
    return _casadi_core.Sparsity_triu(*args)

def Sparsity_tril(*args):
    """Sparsity_tril(int n) -> Sparsity"""
    return _casadi_core.Sparsity_tril(*args)

def Sparsity_diag(*args):
    """
    diag(int nrow) -> Sparsity
    diag(int nrow, int ncol) -> Sparsity
    Sparsity_diag(Pair_Int_Int rc) -> Sparsity



    Create diagonal sparsity pattern.


    """
    return _casadi_core.Sparsity_diag(*args)

def Sparsity_band(*args):
    """Sparsity_band(int n, int p) -> Sparsity"""
    return _casadi_core.Sparsity_band(*args)

def Sparsity_banded(*args):
    """Sparsity_banded(int n, int p) -> Sparsity"""
    return _casadi_core.Sparsity_banded(*args)

def Sparsity_rowcol(*args):
    """Sparsity_rowcol(IVector row, IVector col, int nrow, int ncol) -> Sparsity"""
    return _casadi_core.Sparsity_rowcol(*args)

def Sparsity_triplet(*args):
    """
    triplet(int nrow, int ncol, IVector row, IVector col, IVector mapping, bool invert_mapping=False) -> Sparsity
    Sparsity_triplet(int nrow, int ncol, IVector row, IVector col) -> Sparsity
    """
    return _casadi_core.Sparsity_triplet(*args)

def Sparsity_compressed(*args):
    """
    Sparsity_compressed(IVector v) -> Sparsity



    >  Sparsity casadi::Sparsity::compressed(const std::vector< int > &v)
    ------------------------------------------------------------------------

    Create from a single vector containing the pattern in compressed column
    storage format: The format: The first two entries are the number of rows
    (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
    (colind). Note that the last element, colind[ncol], gives the number of
    nonzeros The last colind[ncol] entries are the row indices

    >  Sparsity casadi::Sparsity::compressed(const int *v)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Create from a single vector containing the pattern in compressed
    column storage format: The format: The first two entries are the
    number of rows (nrow) and columns (ncol) The next ncol+1 entries are
    the column offsets (colind). Note that the last element, colind[ncol],
    gives the number of nonzeros The last colind[ncol] entries are the row
    indices


    """
    return _casadi_core.Sparsity_compressed(*args)

def Sparsity_clearCache(*args):
    """Sparsity_clearCache()"""
    return _casadi_core.Sparsity_clearCache(*args)

def Sparsity_testCast(*args):
    """Sparsity_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.Sparsity_testCast(*args)


def hash_combine(*args):
    """
    hash_combine(std::size_t & seed, IVector v)

    [INTERNAL]  Generate a hash
    value incrementally (function taken from boost)


    """
    return _casadi_core.hash_combine(*args)

def hash_sparsity(*args):
    """
    hash_sparsity(int nrow, int ncol, IVector colind, IVector row) -> std::size_t

    [INTERNAL]  Hash a sparsity
    pattern.


    """
    return _casadi_core.hash_sparsity(*args)
class Slice(PrintSlice):
    """


    Class representing a Slice.

    Note that Python or Octave do not need to use this class. They can just use
    slicing utility from the host language ( M[0:6] in Python, M(1:7) )

    C++ includes: slice.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintSlice]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Slice, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSlice]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Slice, name)
    __repr__ = _swig_repr

    def isSlice(*args):
        """isSlice(IVector v) -> bool"""
        return _casadi_core.Slice_isSlice(*args)

    if _newclass:
        isSlice = staticmethod(isSlice)
    __swig_getmethods__["isSlice"] = lambda x: isSlice

    def isSlice2(*args):
        """isSlice2(IVector v) -> bool"""
        return _casadi_core.Slice_isSlice2(*args)

    if _newclass:
        isSlice2 = staticmethod(isSlice2)
    __swig_getmethods__["isSlice2"] = lambda x: isSlice2

    def getAll(self, *args):
        """
        getAll(Slice self, int len) -> IVector
        getAll(Slice self, Slice outer, int len) -> IVector



        >  std::vector< int > casadi::Slice::getAll(int len) const 
        ------------------------------------------------------------------------

        Get a vector of indices.

        >  std::vector< int > casadi::Slice::getAll(const Slice &outer, int len) const 
        ------------------------------------------------------------------------

        Get a vector of indices (nested slice)


        """
        return _casadi_core.Slice_getAll(self, *args)


    def __eq__(self, *args):
        """__eq__(Slice self, Slice other) -> bool"""
        return _casadi_core.Slice___eq__(self, *args)


    def __ne__(self, *args):
        """__ne__(Slice self, Slice other) -> bool"""
        return _casadi_core.Slice___ne__(self, *args)

    __swig_setmethods__["start_"] = _casadi_core.Slice_start__set
    __swig_getmethods__["start_"] = _casadi_core.Slice_start__get
    if _newclass:
        start_ = _swig_property(_casadi_core.Slice_start__get, _casadi_core.Slice_start__set)
    __swig_setmethods__["stop_"] = _casadi_core.Slice_stop__set
    __swig_getmethods__["stop_"] = _casadi_core.Slice_stop__get
    if _newclass:
        stop_ = _swig_property(_casadi_core.Slice_stop__get, _casadi_core.Slice_stop__set)
    __swig_setmethods__["step_"] = _casadi_core.Slice_step__set
    __swig_getmethods__["step_"] = _casadi_core.Slice_step__get
    if _newclass:
        step_ = _swig_property(_casadi_core.Slice_step__get, _casadi_core.Slice_step__set)

    def __init__(self, *args):
        """
        __init__(casadi::Slice self) -> Slice
        __init__(casadi::Slice self, int i) -> Slice
        __init__(casadi::Slice self, int start, int stop, int step=1) -> Slice
        __init__(casadi::Slice self, IVector v) -> Slice
        __init__(casadi::Slice self, IVector v, Slice outer) -> Slice
        __init__(casadi::Slice self, Slice other) -> Slice



        >  casadi::Slice::Slice()
        ------------------------------------------------------------------------

        Default constructor - all elements.

        >  casadi::Slice::Slice(int i)
        ------------------------------------------------------------------------

        A single element.

        >  casadi::Slice::Slice(int start, int stop, int step=1)
        ------------------------------------------------------------------------

        A slice.

        >  casadi::Slice::Slice(const std::vector< int > &v)
        ------------------------------------------------------------------------

        Construct from an index vector (requires isSlice(v) to be true)

        >  casadi::Slice::Slice(const std::vector< int > &v, Slice &outer)
        ------------------------------------------------------------------------

        Construct nested slices from an index vector (requires isSlice2(v) to be
        true)


        """
        this = _casadi_core.new_Slice(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Slice
Slice_swigregister = _casadi_core.Slice_swigregister
Slice_swigregister(Slice)

def Slice_isSlice(*args):
    """Slice_isSlice(IVector v) -> bool"""
    return _casadi_core.Slice_isSlice(*args)

def Slice_isSlice2(*args):
    """Slice_isSlice2(IVector v) -> bool"""
    return _casadi_core.Slice_isSlice2(*args)

class IndexList(_object):
    """
    [INTERNAL]  Class representing a
    non-regular (and thus non-slice) index list

    C++ includes: slice.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexList, name)
    __repr__ = _swig_repr
    NILL = _casadi_core.IndexList_NILL
    INT = _casadi_core.IndexList_INT
    SLICE = _casadi_core.IndexList_SLICE
    IVECTOR = _casadi_core.IndexList_IVECTOR

    def getAll(self, *args):
        """
        getAll(IndexList self, int len) -> IVector

        [INTERNAL]  Get a vector
        of indices.


        """
        return _casadi_core.IndexList_getAll(self, *args)

    __swig_setmethods__["slice"] = _casadi_core.IndexList_slice_set
    __swig_getmethods__["slice"] = _casadi_core.IndexList_slice_get
    if _newclass:
        slice = _swig_property(_casadi_core.IndexList_slice_get, _casadi_core.IndexList_slice_set)
    __swig_setmethods__["i"] = _casadi_core.IndexList_i_set
    __swig_getmethods__["i"] = _casadi_core.IndexList_i_get
    if _newclass:
        i = _swig_property(_casadi_core.IndexList_i_get, _casadi_core.IndexList_i_set)
    __swig_setmethods__["iv"] = _casadi_core.IndexList_iv_set
    __swig_getmethods__["iv"] = _casadi_core.IndexList_iv_get
    if _newclass:
        iv = _swig_property(_casadi_core.IndexList_iv_get, _casadi_core.IndexList_iv_set)
    __swig_setmethods__["type"] = _casadi_core.IndexList_type_set
    __swig_getmethods__["type"] = _casadi_core.IndexList_type_get
    if _newclass:
        type = _swig_property(_casadi_core.IndexList_type_get, _casadi_core.IndexList_type_set)

    def __init__(self, *args):
        """
        __init__(casadi::IndexList self) -> IndexList
        __init__(casadi::IndexList self, int i) -> IndexList
        __init__(casadi::IndexList self, IVector i) -> IndexList
        __init__(casadi::IndexList self, Slice i) -> IndexList
        __init__(casadi::IndexList self, IndexList other) -> IndexList



        >  casadi::IndexList::IndexList()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Constructor.

        >  casadi::IndexList::IndexList(int i)

        >  casadi::IndexList::IndexList(const std::vector< int > &i)

        >  casadi::IndexList::IndexList(const Slice &i)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        this = _casadi_core.new_IndexList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IndexList
IndexList_swigregister = _casadi_core.IndexList_swigregister
IndexList_swigregister(IndexList)

class Pair_Slice_Int(_object):
    """Proxy of C++ std::pair<(casadi::Slice,int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_Slice_Int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_Slice_Int, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(casadi::Slice,int)> self) -> Pair_Slice_Int
        __init__(std::pair<(casadi::Slice,int)> self, Slice first, int second) -> Pair_Slice_Int
        __init__(std::pair<(casadi::Slice,int)> self, Pair_Slice_Int p) -> Pair_Slice_Int
        """
        this = _casadi_core.new_Pair_Slice_Int(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_Slice_Int_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_Slice_Int_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_Slice_Int_first_get, _casadi_core.Pair_Slice_Int_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_Slice_Int_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_Slice_Int_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_Slice_Int_second_get, _casadi_core.Pair_Slice_Int_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_Slice_Int
Pair_Slice_Int_swigregister = _casadi_core.Pair_Slice_Int_swigregister
Pair_Slice_Int_swigregister(Pair_Slice_Int)

class Pair_Int_Slice(_object):
    """Proxy of C++ std::pair<(int,casadi::Slice)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_Int_Slice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_Int_Slice, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(int,casadi::Slice)> self) -> Pair_Int_Slice
        __init__(std::pair<(int,casadi::Slice)> self, int first, Slice second) -> Pair_Int_Slice
        __init__(std::pair<(int,casadi::Slice)> self, Pair_Int_Slice p) -> Pair_Int_Slice
        """
        this = _casadi_core.new_Pair_Int_Slice(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_Int_Slice_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_Int_Slice_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_Int_Slice_first_get, _casadi_core.Pair_Int_Slice_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_Int_Slice_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_Int_Slice_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_Int_Slice_second_get, _casadi_core.Pair_Int_Slice_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_Int_Slice
Pair_Int_Slice_swigregister = _casadi_core.Pair_Int_Slice_swigregister
Pair_Int_Slice_swigregister(Pair_Int_Slice)

class Pair_Slice_Slice(_object):
    """Proxy of C++ std::pair<(casadi::Slice,casadi::Slice)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_Slice_Slice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_Slice_Slice, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(casadi::Slice,casadi::Slice)> self) -> Pair_Slice_Slice
        __init__(std::pair<(casadi::Slice,casadi::Slice)> self, Slice first, Slice second) -> Pair_Slice_Slice
        __init__(std::pair<(casadi::Slice,casadi::Slice)> self, Pair_Slice_Slice p) -> Pair_Slice_Slice
        """
        this = _casadi_core.new_Pair_Slice_Slice(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_Slice_Slice_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_Slice_Slice_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_Slice_Slice_first_get, _casadi_core.Pair_Slice_Slice_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_Slice_Slice_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_Slice_Slice_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_Slice_Slice_second_get, _casadi_core.Pair_Slice_Slice_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_Slice_Slice
Pair_Slice_Slice_swigregister = _casadi_core.Pair_Slice_Slice_swigregister
Pair_Slice_Slice_swigregister(Pair_Slice_Slice)

class ExpIMatrix(_object):
    """


    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpIMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpIMatrix, name)
    __repr__ = _swig_repr

    def __mldivide__(self, *args):
        """
        __mldivide__(ExpIMatrix self, IMatrix y) -> IMatrix



        Matrix division from left.


        """
        return _casadi_core.ExpIMatrix___mldivide__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(ExpIMatrix self, IMatrix y) -> IMatrix



        No need to have both < and >


        """
        return _casadi_core.ExpIMatrix___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(ExpIMatrix self, IMatrix y) -> IMatrix



        No need to have both <= and >=.


        """
        return _casadi_core.ExpIMatrix___ge__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(ExpIMatrix self, IMatrix y) -> IMatrix



        Division (with __future__.division in effect)


        """
        return _casadi_core.ExpIMatrix___truediv__(self, *args)


    def __radd__(self, *args):
        """__radd__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rdiv__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rlt__(self, *args)


    def __rle__(self, *args):
        """__rle__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rle__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rgt__(self, *args)


    def __rge__(self, *args):
        """__rge__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rge__(self, *args)


    def __req__(self, *args):
        """__req__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___req__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(ExpIMatrix self, IMatrix y) -> IMatrix


        """
        return _casadi_core.ExpIMatrix___rne__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(ExpIMatrix self, IMatrix y) -> IMatrix"""
        return _casadi_core.ExpIMatrix___rtruediv__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(int)>)> self) -> ExpIMatrix
        __init__(casadi::GenericExpression<(casadi::Matrix<(int)>)> self, ExpIMatrix other) -> ExpIMatrix
        """
        this = _casadi_core.new_ExpIMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExpIMatrix
ExpIMatrix_swigregister = _casadi_core.ExpIMatrix_swigregister
ExpIMatrix_swigregister(ExpIMatrix)

class ExpDMatrix(_object):
    """


    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpDMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpDMatrix, name)
    __repr__ = _swig_repr

    def __mldivide__(self, *args):
        """
        __mldivide__(ExpDMatrix self, DMatrix y) -> DMatrix



        Matrix division from left.


        """
        return _casadi_core.ExpDMatrix___mldivide__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(ExpDMatrix self, DMatrix y) -> DMatrix



        No need to have both < and >


        """
        return _casadi_core.ExpDMatrix___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(ExpDMatrix self, DMatrix y) -> DMatrix



        No need to have both <= and >=.


        """
        return _casadi_core.ExpDMatrix___ge__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(ExpDMatrix self, DMatrix y) -> DMatrix



        Division (with __future__.division in effect)


        """
        return _casadi_core.ExpDMatrix___truediv__(self, *args)


    def __radd__(self, *args):
        """__radd__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rdiv__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rlt__(self, *args)


    def __rle__(self, *args):
        """__rle__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rle__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rgt__(self, *args)


    def __rge__(self, *args):
        """__rge__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rge__(self, *args)


    def __req__(self, *args):
        """__req__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___req__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(ExpDMatrix self, DMatrix y) -> DMatrix


        """
        return _casadi_core.ExpDMatrix___rne__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(ExpDMatrix self, DMatrix y) -> DMatrix"""
        return _casadi_core.ExpDMatrix___rtruediv__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(double)>)> self) -> ExpDMatrix
        __init__(casadi::GenericExpression<(casadi::Matrix<(double)>)> self, ExpDMatrix other) -> ExpDMatrix
        """
        this = _casadi_core.new_ExpDMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExpDMatrix
ExpDMatrix_swigregister = _casadi_core.ExpDMatrix_swigregister
ExpDMatrix_swigregister(ExpDMatrix)

class ExpSX(_object):
    """


    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpSX, name)
    __repr__ = _swig_repr

    def __mldivide__(self, *args):
        """
        __mldivide__(ExpSX self, SX y) -> SX



        Matrix division from left.


        """
        return _casadi_core.ExpSX___mldivide__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(ExpSX self, SX y) -> SX



        No need to have both < and >


        """
        return _casadi_core.ExpSX___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(ExpSX self, SX y) -> SX



        No need to have both <= and >=.


        """
        return _casadi_core.ExpSX___ge__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(ExpSX self, SX y) -> SX



        Division (with __future__.division in effect)


        """
        return _casadi_core.ExpSX___truediv__(self, *args)


    def __radd__(self, *args):
        """__radd__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rdiv__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rlt__(self, *args)


    def __rle__(self, *args):
        """__rle__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rle__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rgt__(self, *args)


    def __rge__(self, *args):
        """__rge__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rge__(self, *args)


    def __req__(self, *args):
        """__req__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___req__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(ExpSX self, SX y) -> SX


        """
        return _casadi_core.ExpSX___rne__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(ExpSX self, SX y) -> SX"""
        return _casadi_core.ExpSX___rtruediv__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(casadi::SXElement)>)> self) -> ExpSX
        __init__(casadi::GenericExpression<(casadi::Matrix<(casadi::SXElement)>)> self, ExpSX other) -> ExpSX
        """
        this = _casadi_core.new_ExpSX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExpSX
ExpSX_swigregister = _casadi_core.ExpSX_swigregister
ExpSX_swigregister(ExpSX)

class ExpMX(_object):
    """


    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpMX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpMX, name)
    __repr__ = _swig_repr

    def __mldivide__(self, *args):
        """
        __mldivide__(ExpMX self, MX y) -> MX



        Matrix division from left.


        """
        return _casadi_core.ExpMX___mldivide__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(ExpMX self, MX y) -> MX



        No need to have both < and >


        """
        return _casadi_core.ExpMX___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(ExpMX self, MX y) -> MX



        No need to have both <= and >=.


        """
        return _casadi_core.ExpMX___ge__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(ExpMX self, MX y) -> MX



        Division (with __future__.division in effect)


        """
        return _casadi_core.ExpMX___truediv__(self, *args)


    def __radd__(self, *args):
        """__radd__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rdiv__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rlt__(self, *args)


    def __rle__(self, *args):
        """__rle__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rle__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rgt__(self, *args)


    def __rge__(self, *args):
        """__rge__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rge__(self, *args)


    def __req__(self, *args):
        """__req__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___req__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(ExpMX self, MX y) -> MX


        """
        return _casadi_core.ExpMX___rne__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(ExpMX self, MX y) -> MX"""
        return _casadi_core.ExpMX___rtruediv__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericExpression<(casadi::MX)> self) -> ExpMX
        __init__(casadi::GenericExpression<(casadi::MX)> self, ExpMX other) -> ExpMX
        """
        this = _casadi_core.new_ExpMX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExpMX
ExpMX_swigregister = _casadi_core.ExpMX_swigregister
ExpMX_swigregister(ExpMX)

class ExpSXElement(_object):
    """


    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpSXElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpSXElement, name)
    __repr__ = _swig_repr

    def __mldivide__(self, *args):
        """
        __mldivide__(ExpSXElement self, SXElement y) -> SXElement



        Matrix division from left.


        """
        return _casadi_core.ExpSXElement___mldivide__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(ExpSXElement self, SXElement y) -> SXElement



        No need to have both < and >


        """
        return _casadi_core.ExpSXElement___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(ExpSXElement self, SXElement y) -> SXElement



        No need to have both <= and >=.


        """
        return _casadi_core.ExpSXElement___ge__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(ExpSXElement self, SXElement y) -> SXElement



        Division (with __future__.division in effect)


        """
        return _casadi_core.ExpSXElement___truediv__(self, *args)


    def __radd__(self, *args):
        """__radd__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rdiv__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rlt__(self, *args)


    def __rle__(self, *args):
        """__rle__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rle__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rgt__(self, *args)


    def __rge__(self, *args):
        """__rge__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rge__(self, *args)


    def __req__(self, *args):
        """__req__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___req__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(ExpSXElement self, SXElement y) -> SXElement


        """
        return _casadi_core.ExpSXElement___rne__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(ExpSXElement self, SXElement y) -> SXElement"""
        return _casadi_core.ExpSXElement___rtruediv__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericExpression<(casadi::SXElement)> self) -> ExpSXElement
        __init__(casadi::GenericExpression<(casadi::SXElement)> self, ExpSXElement other) -> ExpSXElement
        """
        this = _casadi_core.new_ExpSXElement(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExpSXElement
ExpSXElement_swigregister = _casadi_core.ExpSXElement_swigregister
ExpSXElement_swigregister(ExpSXElement)


_casadi_core.SPARSE_swigconstant(_casadi_core)
SPARSE = _casadi_core.SPARSE

_casadi_core.SPARSESYM_swigconstant(_casadi_core)
SPARSESYM = _casadi_core.SPARSESYM

_casadi_core.DENSE_swigconstant(_casadi_core)
DENSE = _casadi_core.DENSE

_casadi_core.DENSESYM_swigconstant(_casadi_core)
DENSESYM = _casadi_core.DENSESYM

_casadi_core.DENSETRANS_swigconstant(_casadi_core)
DENSETRANS = _casadi_core.DENSETRANS
class GenIMatrix(_object):
    """


    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenIMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenIMatrix, name)
    __repr__ = _swig_repr

    def sizeL(self, *args):
        """
        sizeL(GenIMatrix self) -> int



        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi_core.GenIMatrix_sizeL(self, *args)


    def sizeU(self, *args):
        """
        sizeU(GenIMatrix self) -> int



        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi_core.GenIMatrix_sizeU(self, *args)


    def sizeD(self, *args):
        """
        sizeD(GenIMatrix self) -> int



        Get get the number of non-zeros on the diagonal.


        """
        return _casadi_core.GenIMatrix_sizeD(self, *args)


    def numel(self, *args):
        """
        numel(GenIMatrix self) -> int



        Get the number of elements.


        """
        return _casadi_core.GenIMatrix_numel(self, *args)


    def size1(self, *args):
        """
        size1(GenIMatrix self) -> int



        Get the first dimension (i.e. number of rows)


        """
        return _casadi_core.GenIMatrix_size1(self, *args)


    def size2(self, *args):
        """
        size2(GenIMatrix self) -> int



        Get the second dimension (i.e. number of columns)


        """
        return _casadi_core.GenIMatrix_size2(self, *args)


    def size(self, *args):
        """
        size(GenIMatrix self) -> int
        size(GenIMatrix self, casadi::SparsityType sp) -> int



        >  int casadi::GenericMatrix< MatType >::size() const 
        ------------------------------------------------------------------------

        Get the number of (structural) non-zero elements.

        >  int casadi::GenericMatrix< MatType >::size(SparsityType sp) const 
        ------------------------------------------------------------------------

        Get the number if non-zeros for a given sparsity pattern.


        """
        return _casadi_core.GenIMatrix_size(self, *args)


    def dimString(self, *args):
        """
        dimString(GenIMatrix self) -> std::string



        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi_core.GenIMatrix_dimString(self, *args)


    def isEmpty(self, *args):
        """
        isEmpty(GenIMatrix self, bool both=False) -> bool



        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi_core.GenIMatrix_isEmpty(self, *args)


    def isDense(self, *args):
        """
        isDense(GenIMatrix self) -> bool



        Check if the matrix expression is dense.


        """
        return _casadi_core.GenIMatrix_isDense(self, *args)


    def isScalar(self, *args):
        """
        isScalar(GenIMatrix self, bool scalar_and_dense=False) -> bool



        Check if the matrix expression is scalar.


        """
        return _casadi_core.GenIMatrix_isScalar(self, *args)


    def isSquare(self, *args):
        """
        isSquare(GenIMatrix self) -> bool



        Check if the matrix expression is square.


        """
        return _casadi_core.GenIMatrix_isSquare(self, *args)


    def isVector(self, *args):
        """
        isVector(GenIMatrix self) -> bool



        Check if the matrix is a vector (i.e. size2()==1)


        """
        return _casadi_core.GenIMatrix_isVector(self, *args)


    def isTriu(self, *args):
        """
        isTriu(GenIMatrix self) -> bool



        Check if the matrix is upper triangular.


        """
        return _casadi_core.GenIMatrix_isTriu(self, *args)


    def isTril(self, *args):
        """
        isTril(GenIMatrix self) -> bool



        Check if the matrix is lower triangular.


        """
        return _casadi_core.GenIMatrix_isTril(self, *args)


    def sparsity(self, *args):
        """
        sparsity(GenIMatrix self) -> Sparsity



        Get the sparsity pattern.


        """
        return _casadi_core.GenIMatrix_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(GenIMatrix self) -> Sparsity



        Access the sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.GenIMatrix_sparsityRef(self, *args)


    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> IMatrix
        sym(std::string const & name, Pair_Int_Int rc) -> IMatrix
        sym(std::string const & name, Sparsity sp) -> IMatrix
        sym(std::string const & name, Sparsity sp, int p) -> IMatrixVector
        sym(std::string const & name, int nrow, int ncol, int p) -> IMatrixVector
        sym(std::string const & name, Sparsity sp, int p, int r) -> IMatrixVectorVector
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> IMatrixVectorVector



        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.


        """
        return _casadi_core.GenIMatrix_sym(*args)

    if _newclass:
        sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym

    def sparse(*args):
        """
        sparse(int nrow=1, int ncol=1) -> IMatrix
        sparse(Pair_Int_Int rc) -> IMatrix



        create a sparse matrix with all zeros


        """
        return _casadi_core.GenIMatrix_sparse(*args)

    if _newclass:
        sparse = staticmethod(sparse)
    __swig_getmethods__["sparse"] = lambda x: sparse

    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> IMatrix
        zeros(Sparsity sp) -> IMatrix
        zeros(Pair_Int_Int rc) -> IMatrix



        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi_core.GenIMatrix_zeros(*args)

    if _newclass:
        zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros

    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> IMatrix
        ones(Sparsity sp) -> IMatrix
        ones(Pair_Int_Int rc) -> IMatrix



        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi_core.GenIMatrix_ones(*args)

    if _newclass:
        ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones

    def mul_smart(self, *args):
        """
        mul_smart(GenIMatrix self, IMatrix y, Sparsity sp_z) -> IMatrix



        Matrix-matrix multiplication. Attempts to identify quick returns on matrix-
        level and delegates to MatType::mul_full if no such quick returns are found.


        """
        return _casadi_core.GenIMatrix_mul_smart(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(int)>)> self) -> GenIMatrix
        __init__(casadi::GenericMatrix<(casadi::Matrix<(int)>)> self, GenIMatrix other) -> GenIMatrix
        """
        this = _casadi_core.new_GenIMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_GenIMatrix
GenIMatrix_swigregister = _casadi_core.GenIMatrix_swigregister
GenIMatrix_swigregister(GenIMatrix)

def GenIMatrix_sym(*args):
    """
    sym(std::string const & name, int nrow=1, int ncol=1) -> IMatrix
    sym(std::string const & name, Pair_Int_Int rc) -> IMatrix
    sym(std::string const & name, Sparsity sp) -> IMatrix
    sym(std::string const & name, Sparsity sp, int p) -> IMatrixVector
    sym(std::string const & name, int nrow, int ncol, int p) -> IMatrixVector
    sym(std::string const & name, Sparsity sp, int p, int r) -> IMatrixVectorVector
    GenIMatrix_sym(std::string const & name, int nrow, int ncol, int p, int r) -> IMatrixVectorVector



    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.


    """
    return _casadi_core.GenIMatrix_sym(*args)

def GenIMatrix_sparse(*args):
    """
    sparse(int nrow=1, int ncol=1) -> IMatrix
    GenIMatrix_sparse(Pair_Int_Int rc) -> IMatrix



    create a sparse matrix with all zeros


    """
    return _casadi_core.GenIMatrix_sparse(*args)

def GenIMatrix_zeros(*args):
    """
    zeros(int nrow=1, int ncol=1) -> IMatrix
    zeros(Sparsity sp) -> IMatrix
    GenIMatrix_zeros(Pair_Int_Int rc) -> IMatrix



    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
    return _casadi_core.GenIMatrix_zeros(*args)

def GenIMatrix_ones(*args):
    """
    ones(int nrow=1, int ncol=1) -> IMatrix
    ones(Sparsity sp) -> IMatrix
    GenIMatrix_ones(Pair_Int_Int rc) -> IMatrix



    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
    return _casadi_core.GenIMatrix_ones(*args)

class GenDMatrix(_object):
    """


    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenDMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenDMatrix, name)
    __repr__ = _swig_repr

    def sizeL(self, *args):
        """
        sizeL(GenDMatrix self) -> int



        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi_core.GenDMatrix_sizeL(self, *args)


    def sizeU(self, *args):
        """
        sizeU(GenDMatrix self) -> int



        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi_core.GenDMatrix_sizeU(self, *args)


    def sizeD(self, *args):
        """
        sizeD(GenDMatrix self) -> int



        Get get the number of non-zeros on the diagonal.


        """
        return _casadi_core.GenDMatrix_sizeD(self, *args)


    def numel(self, *args):
        """
        numel(GenDMatrix self) -> int



        Get the number of elements.


        """
        return _casadi_core.GenDMatrix_numel(self, *args)


    def size1(self, *args):
        """
        size1(GenDMatrix self) -> int



        Get the first dimension (i.e. number of rows)


        """
        return _casadi_core.GenDMatrix_size1(self, *args)


    def size2(self, *args):
        """
        size2(GenDMatrix self) -> int



        Get the second dimension (i.e. number of columns)


        """
        return _casadi_core.GenDMatrix_size2(self, *args)


    def size(self, *args):
        """
        size(GenDMatrix self) -> int
        size(GenDMatrix self, casadi::SparsityType sp) -> int



        >  int casadi::GenericMatrix< MatType >::size() const 
        ------------------------------------------------------------------------

        Get the number of (structural) non-zero elements.

        >  int casadi::GenericMatrix< MatType >::size(SparsityType sp) const 
        ------------------------------------------------------------------------

        Get the number if non-zeros for a given sparsity pattern.


        """
        return _casadi_core.GenDMatrix_size(self, *args)


    def dimString(self, *args):
        """
        dimString(GenDMatrix self) -> std::string



        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi_core.GenDMatrix_dimString(self, *args)


    def isEmpty(self, *args):
        """
        isEmpty(GenDMatrix self, bool both=False) -> bool



        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi_core.GenDMatrix_isEmpty(self, *args)


    def isDense(self, *args):
        """
        isDense(GenDMatrix self) -> bool



        Check if the matrix expression is dense.


        """
        return _casadi_core.GenDMatrix_isDense(self, *args)


    def isScalar(self, *args):
        """
        isScalar(GenDMatrix self, bool scalar_and_dense=False) -> bool



        Check if the matrix expression is scalar.


        """
        return _casadi_core.GenDMatrix_isScalar(self, *args)


    def isSquare(self, *args):
        """
        isSquare(GenDMatrix self) -> bool



        Check if the matrix expression is square.


        """
        return _casadi_core.GenDMatrix_isSquare(self, *args)


    def isVector(self, *args):
        """
        isVector(GenDMatrix self) -> bool



        Check if the matrix is a vector (i.e. size2()==1)


        """
        return _casadi_core.GenDMatrix_isVector(self, *args)


    def isTriu(self, *args):
        """
        isTriu(GenDMatrix self) -> bool



        Check if the matrix is upper triangular.


        """
        return _casadi_core.GenDMatrix_isTriu(self, *args)


    def isTril(self, *args):
        """
        isTril(GenDMatrix self) -> bool



        Check if the matrix is lower triangular.


        """
        return _casadi_core.GenDMatrix_isTril(self, *args)


    def sparsity(self, *args):
        """
        sparsity(GenDMatrix self) -> Sparsity



        Get the sparsity pattern.


        """
        return _casadi_core.GenDMatrix_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(GenDMatrix self) -> Sparsity



        Access the sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.GenDMatrix_sparsityRef(self, *args)


    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> DMatrix
        sym(std::string const & name, Pair_Int_Int rc) -> DMatrix
        sym(std::string const & name, Sparsity sp) -> DMatrix
        sym(std::string const & name, Sparsity sp, int p) -> DMatrixVector
        sym(std::string const & name, int nrow, int ncol, int p) -> DMatrixVector
        sym(std::string const & name, Sparsity sp, int p, int r) -> DMatrixVectorVector
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> DMatrixVectorVector



        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.


        """
        return _casadi_core.GenDMatrix_sym(*args)

    if _newclass:
        sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym

    def sparse(*args):
        """
        sparse(int nrow=1, int ncol=1) -> DMatrix
        sparse(Pair_Int_Int rc) -> DMatrix



        create a sparse matrix with all zeros


        """
        return _casadi_core.GenDMatrix_sparse(*args)

    if _newclass:
        sparse = staticmethod(sparse)
    __swig_getmethods__["sparse"] = lambda x: sparse

    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> DMatrix
        zeros(Sparsity sp) -> DMatrix
        zeros(Pair_Int_Int rc) -> DMatrix



        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi_core.GenDMatrix_zeros(*args)

    if _newclass:
        zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros

    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> DMatrix
        ones(Sparsity sp) -> DMatrix
        ones(Pair_Int_Int rc) -> DMatrix



        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi_core.GenDMatrix_ones(*args)

    if _newclass:
        ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones

    def mul_smart(self, *args):
        """
        mul_smart(GenDMatrix self, DMatrix y, Sparsity sp_z) -> DMatrix



        Matrix-matrix multiplication. Attempts to identify quick returns on matrix-
        level and delegates to MatType::mul_full if no such quick returns are found.


        """
        return _casadi_core.GenDMatrix_mul_smart(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(double)>)> self) -> GenDMatrix
        __init__(casadi::GenericMatrix<(casadi::Matrix<(double)>)> self, GenDMatrix other) -> GenDMatrix
        """
        this = _casadi_core.new_GenDMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_GenDMatrix
GenDMatrix_swigregister = _casadi_core.GenDMatrix_swigregister
GenDMatrix_swigregister(GenDMatrix)

def GenDMatrix_sym(*args):
    """
    sym(std::string const & name, int nrow=1, int ncol=1) -> DMatrix
    sym(std::string const & name, Pair_Int_Int rc) -> DMatrix
    sym(std::string const & name, Sparsity sp) -> DMatrix
    sym(std::string const & name, Sparsity sp, int p) -> DMatrixVector
    sym(std::string const & name, int nrow, int ncol, int p) -> DMatrixVector
    sym(std::string const & name, Sparsity sp, int p, int r) -> DMatrixVectorVector
    GenDMatrix_sym(std::string const & name, int nrow, int ncol, int p, int r) -> DMatrixVectorVector



    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.


    """
    return _casadi_core.GenDMatrix_sym(*args)

def GenDMatrix_sparse(*args):
    """
    sparse(int nrow=1, int ncol=1) -> DMatrix
    GenDMatrix_sparse(Pair_Int_Int rc) -> DMatrix



    create a sparse matrix with all zeros


    """
    return _casadi_core.GenDMatrix_sparse(*args)

def GenDMatrix_zeros(*args):
    """
    zeros(int nrow=1, int ncol=1) -> DMatrix
    zeros(Sparsity sp) -> DMatrix
    GenDMatrix_zeros(Pair_Int_Int rc) -> DMatrix



    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
    return _casadi_core.GenDMatrix_zeros(*args)

def GenDMatrix_ones(*args):
    """
    ones(int nrow=1, int ncol=1) -> DMatrix
    ones(Sparsity sp) -> DMatrix
    GenDMatrix_ones(Pair_Int_Int rc) -> DMatrix



    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
    return _casadi_core.GenDMatrix_ones(*args)

class GenSX(_object):
    """


    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenSX, name)
    __repr__ = _swig_repr

    def sizeL(self, *args):
        """
        sizeL(GenSX self) -> int



        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi_core.GenSX_sizeL(self, *args)


    def sizeU(self, *args):
        """
        sizeU(GenSX self) -> int



        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi_core.GenSX_sizeU(self, *args)


    def sizeD(self, *args):
        """
        sizeD(GenSX self) -> int



        Get get the number of non-zeros on the diagonal.


        """
        return _casadi_core.GenSX_sizeD(self, *args)


    def numel(self, *args):
        """
        numel(GenSX self) -> int



        Get the number of elements.


        """
        return _casadi_core.GenSX_numel(self, *args)


    def size1(self, *args):
        """
        size1(GenSX self) -> int



        Get the first dimension (i.e. number of rows)


        """
        return _casadi_core.GenSX_size1(self, *args)


    def size2(self, *args):
        """
        size2(GenSX self) -> int



        Get the second dimension (i.e. number of columns)


        """
        return _casadi_core.GenSX_size2(self, *args)


    def size(self, *args):
        """
        size(GenSX self) -> int
        size(GenSX self, casadi::SparsityType sp) -> int



        >  int casadi::GenericMatrix< MatType >::size() const 
        ------------------------------------------------------------------------

        Get the number of (structural) non-zero elements.

        >  int casadi::GenericMatrix< MatType >::size(SparsityType sp) const 
        ------------------------------------------------------------------------

        Get the number if non-zeros for a given sparsity pattern.


        """
        return _casadi_core.GenSX_size(self, *args)


    def dimString(self, *args):
        """
        dimString(GenSX self) -> std::string



        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi_core.GenSX_dimString(self, *args)


    def isEmpty(self, *args):
        """
        isEmpty(GenSX self, bool both=False) -> bool



        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi_core.GenSX_isEmpty(self, *args)


    def isDense(self, *args):
        """
        isDense(GenSX self) -> bool



        Check if the matrix expression is dense.


        """
        return _casadi_core.GenSX_isDense(self, *args)


    def isScalar(self, *args):
        """
        isScalar(GenSX self, bool scalar_and_dense=False) -> bool



        Check if the matrix expression is scalar.


        """
        return _casadi_core.GenSX_isScalar(self, *args)


    def isSquare(self, *args):
        """
        isSquare(GenSX self) -> bool



        Check if the matrix expression is square.


        """
        return _casadi_core.GenSX_isSquare(self, *args)


    def isVector(self, *args):
        """
        isVector(GenSX self) -> bool



        Check if the matrix is a vector (i.e. size2()==1)


        """
        return _casadi_core.GenSX_isVector(self, *args)


    def isTriu(self, *args):
        """
        isTriu(GenSX self) -> bool



        Check if the matrix is upper triangular.


        """
        return _casadi_core.GenSX_isTriu(self, *args)


    def isTril(self, *args):
        """
        isTril(GenSX self) -> bool



        Check if the matrix is lower triangular.


        """
        return _casadi_core.GenSX_isTril(self, *args)


    def sparsity(self, *args):
        """
        sparsity(GenSX self) -> Sparsity



        Get the sparsity pattern.


        """
        return _casadi_core.GenSX_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(GenSX self) -> Sparsity



        Access the sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.GenSX_sparsityRef(self, *args)


    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> SX
        sym(std::string const & name, Pair_Int_Int rc) -> SX
        sym(std::string const & name, Sparsity sp) -> SX
        sym(std::string const & name, Sparsity sp, int p) -> SXVector
        sym(std::string const & name, int nrow, int ncol, int p) -> SXVector
        sym(std::string const & name, Sparsity sp, int p, int r) -> SXVectorVector
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> SXVectorVector



        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.


        """
        return _casadi_core.GenSX_sym(*args)

    if _newclass:
        sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym

    def sparse(*args):
        """
        sparse(int nrow=1, int ncol=1) -> SX
        sparse(Pair_Int_Int rc) -> SX



        create a sparse matrix with all zeros


        """
        return _casadi_core.GenSX_sparse(*args)

    if _newclass:
        sparse = staticmethod(sparse)
    __swig_getmethods__["sparse"] = lambda x: sparse

    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> SX
        zeros(Sparsity sp) -> SX
        zeros(Pair_Int_Int rc) -> SX



        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi_core.GenSX_zeros(*args)

    if _newclass:
        zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros

    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> SX
        ones(Sparsity sp) -> SX
        ones(Pair_Int_Int rc) -> SX



        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi_core.GenSX_ones(*args)

    if _newclass:
        ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones

    def mul_smart(self, *args):
        """
        mul_smart(GenSX self, SX y, Sparsity sp_z) -> SX



        Matrix-matrix multiplication. Attempts to identify quick returns on matrix-
        level and delegates to MatType::mul_full if no such quick returns are found.


        """
        return _casadi_core.GenSX_mul_smart(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(casadi::SXElement)>)> self) -> GenSX
        __init__(casadi::GenericMatrix<(casadi::Matrix<(casadi::SXElement)>)> self, GenSX other) -> GenSX
        """
        this = _casadi_core.new_GenSX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_GenSX
GenSX_swigregister = _casadi_core.GenSX_swigregister
GenSX_swigregister(GenSX)

def GenSX_sym(*args):
    """
    sym(std::string const & name, int nrow=1, int ncol=1) -> SX
    sym(std::string const & name, Pair_Int_Int rc) -> SX
    sym(std::string const & name, Sparsity sp) -> SX
    sym(std::string const & name, Sparsity sp, int p) -> SXVector
    sym(std::string const & name, int nrow, int ncol, int p) -> SXVector
    sym(std::string const & name, Sparsity sp, int p, int r) -> SXVectorVector
    GenSX_sym(std::string const & name, int nrow, int ncol, int p, int r) -> SXVectorVector



    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.


    """
    return _casadi_core.GenSX_sym(*args)

def GenSX_sparse(*args):
    """
    sparse(int nrow=1, int ncol=1) -> SX
    GenSX_sparse(Pair_Int_Int rc) -> SX



    create a sparse matrix with all zeros


    """
    return _casadi_core.GenSX_sparse(*args)

def GenSX_zeros(*args):
    """
    zeros(int nrow=1, int ncol=1) -> SX
    zeros(Sparsity sp) -> SX
    GenSX_zeros(Pair_Int_Int rc) -> SX



    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
    return _casadi_core.GenSX_zeros(*args)

def GenSX_ones(*args):
    """
    ones(int nrow=1, int ncol=1) -> SX
    ones(Sparsity sp) -> SX
    GenSX_ones(Pair_Int_Int rc) -> SX



    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
    return _casadi_core.GenSX_ones(*args)

class GenMX(_object):
    """


    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenMX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenMX, name)
    __repr__ = _swig_repr

    def sizeL(self, *args):
        """
        sizeL(GenMX self) -> int



        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi_core.GenMX_sizeL(self, *args)


    def sizeU(self, *args):
        """
        sizeU(GenMX self) -> int



        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi_core.GenMX_sizeU(self, *args)


    def sizeD(self, *args):
        """
        sizeD(GenMX self) -> int



        Get get the number of non-zeros on the diagonal.


        """
        return _casadi_core.GenMX_sizeD(self, *args)


    def numel(self, *args):
        """
        numel(GenMX self) -> int



        Get the number of elements.


        """
        return _casadi_core.GenMX_numel(self, *args)


    def size1(self, *args):
        """
        size1(GenMX self) -> int



        Get the first dimension (i.e. number of rows)


        """
        return _casadi_core.GenMX_size1(self, *args)


    def size2(self, *args):
        """
        size2(GenMX self) -> int



        Get the second dimension (i.e. number of columns)


        """
        return _casadi_core.GenMX_size2(self, *args)


    def size(self, *args):
        """
        size(GenMX self) -> int
        size(GenMX self, casadi::SparsityType sp) -> int



        >  int casadi::GenericMatrix< MatType >::size() const 
        ------------------------------------------------------------------------

        Get the number of (structural) non-zero elements.

        >  int casadi::GenericMatrix< MatType >::size(SparsityType sp) const 
        ------------------------------------------------------------------------

        Get the number if non-zeros for a given sparsity pattern.


        """
        return _casadi_core.GenMX_size(self, *args)


    def dimString(self, *args):
        """
        dimString(GenMX self) -> std::string



        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi_core.GenMX_dimString(self, *args)


    def isEmpty(self, *args):
        """
        isEmpty(GenMX self, bool both=False) -> bool



        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi_core.GenMX_isEmpty(self, *args)


    def isDense(self, *args):
        """
        isDense(GenMX self) -> bool



        Check if the matrix expression is dense.


        """
        return _casadi_core.GenMX_isDense(self, *args)


    def isScalar(self, *args):
        """
        isScalar(GenMX self, bool scalar_and_dense=False) -> bool



        Check if the matrix expression is scalar.


        """
        return _casadi_core.GenMX_isScalar(self, *args)


    def isSquare(self, *args):
        """
        isSquare(GenMX self) -> bool



        Check if the matrix expression is square.


        """
        return _casadi_core.GenMX_isSquare(self, *args)


    def isVector(self, *args):
        """
        isVector(GenMX self) -> bool



        Check if the matrix is a vector (i.e. size2()==1)


        """
        return _casadi_core.GenMX_isVector(self, *args)


    def isTriu(self, *args):
        """
        isTriu(GenMX self) -> bool



        Check if the matrix is upper triangular.


        """
        return _casadi_core.GenMX_isTriu(self, *args)


    def isTril(self, *args):
        """
        isTril(GenMX self) -> bool



        Check if the matrix is lower triangular.


        """
        return _casadi_core.GenMX_isTril(self, *args)


    def sparsity(self, *args):
        """
        sparsity(GenMX self) -> Sparsity



        Get the sparsity pattern.


        """
        return _casadi_core.GenMX_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(GenMX self) -> Sparsity



        Access the sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.GenMX_sparsityRef(self, *args)


    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> MX
        sym(std::string const & name, Pair_Int_Int rc) -> MX
        sym(std::string const & name, Sparsity sp) -> MX
        sym(std::string const & name, Sparsity sp, int p) -> MXVector
        sym(std::string const & name, int nrow, int ncol, int p) -> MXVector
        sym(std::string const & name, Sparsity sp, int p, int r) -> MXVectorVector
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> MXVectorVector



        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.


        """
        return _casadi_core.GenMX_sym(*args)

    if _newclass:
        sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym

    def sparse(*args):
        """
        sparse(int nrow=1, int ncol=1) -> MX
        sparse(Pair_Int_Int rc) -> MX



        create a sparse matrix with all zeros


        """
        return _casadi_core.GenMX_sparse(*args)

    if _newclass:
        sparse = staticmethod(sparse)
    __swig_getmethods__["sparse"] = lambda x: sparse

    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> MX
        zeros(Sparsity sp) -> MX
        zeros(Pair_Int_Int rc) -> MX



        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi_core.GenMX_zeros(*args)

    if _newclass:
        zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros

    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> MX
        ones(Sparsity sp) -> MX
        ones(Pair_Int_Int rc) -> MX



        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi_core.GenMX_ones(*args)

    if _newclass:
        ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones

    def mul_smart(self, *args):
        """
        mul_smart(GenMX self, MX y, Sparsity sp_z) -> MX



        Matrix-matrix multiplication. Attempts to identify quick returns on matrix-
        level and delegates to MatType::mul_full if no such quick returns are found.


        """
        return _casadi_core.GenMX_mul_smart(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::GenericMatrix<(casadi::MX)> self) -> GenMX
        __init__(casadi::GenericMatrix<(casadi::MX)> self, GenMX other) -> GenMX
        """
        this = _casadi_core.new_GenMX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_GenMX
GenMX_swigregister = _casadi_core.GenMX_swigregister
GenMX_swigregister(GenMX)

def GenMX_sym(*args):
    """
    sym(std::string const & name, int nrow=1, int ncol=1) -> MX
    sym(std::string const & name, Pair_Int_Int rc) -> MX
    sym(std::string const & name, Sparsity sp) -> MX
    sym(std::string const & name, Sparsity sp, int p) -> MXVector
    sym(std::string const & name, int nrow, int ncol, int p) -> MXVector
    sym(std::string const & name, Sparsity sp, int p, int r) -> MXVectorVector
    GenMX_sym(std::string const & name, int nrow, int ncol, int p, int r) -> MXVectorVector



    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const std::pair< int, int > &rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  std::vector< MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static std::vector<MatType > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  std::vector< std::vector< MatType > > casadi::GenericMatrix< MatType >::sym(const std::string &name, const Sparsity &sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static std::vector<std::vector<MatType> > casadi::GenericMatrix< MatType >::sym(const std::string &name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.


    """
    return _casadi_core.GenMX_sym(*args)

def GenMX_sparse(*args):
    """
    sparse(int nrow=1, int ncol=1) -> MX
    GenMX_sparse(Pair_Int_Int rc) -> MX



    create a sparse matrix with all zeros


    """
    return _casadi_core.GenMX_sparse(*args)

def GenMX_zeros(*args):
    """
    zeros(int nrow=1, int ncol=1) -> MX
    zeros(Sparsity sp) -> MX
    GenMX_zeros(Pair_Int_Int rc) -> MX



    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
    return _casadi_core.GenMX_zeros(*args)

def GenMX_ones(*args):
    """
    ones(int nrow=1, int ncol=1) -> MX
    ones(Sparsity sp) -> MX
    GenMX_ones(Pair_Int_Int rc) -> MX



    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
    return _casadi_core.GenMX_ones(*args)

class PrintSX(_object):
    """


    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSX, name)
    __repr__ = _swig_repr

    def __str__(self, *args):
        """
        __str__(PrintSX self) -> std::string



        Return a string with a description (for SWIG)


        """
        return _casadi_core.PrintSX___str__(self, *args)


    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSX self) -> std::string



        Return a string with a representation (for SWIG)


        """
        return _casadi_core.PrintSX_getRepresentation(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(casadi::SXElement)>)> self) -> PrintSX
        __init__(casadi::PrintableObject<(casadi::Matrix<(casadi::SXElement)>)> self, PrintSX other) -> PrintSX
        """
        this = _casadi_core.new_PrintSX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_PrintSX
PrintSX_swigregister = _casadi_core.PrintSX_swigregister
PrintSX_swigregister(PrintSX)

class IMatrix(ExpIMatrix, GenIMatrix, PrintIMatrix):
    """


    Sparse matrix class. SX and DMatrix are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero. Matrix<DataType> is polymorphic with a
    std::vector<DataType> that contain all non- identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [ExpIMatrix, GenIMatrix, PrintIMatrix]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpIMatrix, GenIMatrix, PrintIMatrix]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IMatrix, name)
    __repr__ = _swig_repr

    def sanityCheck(self, *args):
        """
        sanityCheck(IMatrix self, bool complete=False)

         [INTERNAL]  Check if
        the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi_core.IMatrix_sanityCheck(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::Matrix<(int)> self) -> IMatrix
        __init__(casadi::Matrix<(int)> self, IMatrix m) -> IMatrix
        __init__(casadi::Matrix<(int)> self, IVectorVector m) -> IMatrix
        __init__(casadi::Matrix<(int)> self, Sparsity sparsity, int const & val) -> IMatrix
        __init__(casadi::Matrix<(int)> self, Sparsity sparsity, IVector d) -> IMatrix
        __init__(casadi::Matrix<(int)> self, double val) -> IMatrix
        __init__(casadi::Matrix<(int)> self, IVector x) -> IMatrix
        __init__(casadi::Matrix<(int)> self, IVector x, int nrow, int ncol) -> IMatrix



        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const DataType &val=DataType(0))
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity

        >  casadi::Matrix< DataType >::Matrix()
        ------------------------------------------------------------------------
        [INTERNAL] 
        constructors

        empty 0-by-0 matrix constructor

        >  casadi::Matrix< DataType >::Matrix(const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Copy constructor.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< std::vector< DataType > > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Dense matrix constructor with data given as vector of vectors.

        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const std::vector< DataType > &d)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity and non-zero elements.

        >  casadi::Matrix< DataType >::Matrix(double val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        This constructor enables implicit type conversion from a numeric type.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct from a vector.

        Thanks to implicit conversion, you can pretend that Matrix(const SXElement&
        x); exists. Note: above remark applies only to C++, not python or octave
        interfaces

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x, int nrow, int ncol)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct dense matrix from a vector with the elements in column major
        ordering.

        >  casadi::Matrix< T >::Matrix(const Matrix< A > &x)
        ------------------------------------------------------------------------

        Create a matrix from a matrix with a different type of matrix entries
        (assuming that the scalar conversion is valid)

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x)
        ------------------------------------------------------------------------

        Create an expression from an stl vector.

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x, int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a non-vector expression from an stl vector.


        """
        this = _casadi_core.new_IMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def toScalar(self, *args):
        """
        toScalar(IMatrix self) -> int const

        [INTERNAL]  Convert to
        scalar type.


        """
        return _casadi_core.IMatrix_toScalar(self, *args)


    def at(self, *args):
        """
        at(IMatrix self, int k) -> int



        >  const DataType& casadi::Matrix< T >::at(int k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a non-zero element.

        >  DataType& casadi::Matrix< T >::at(int k)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access a non-zero element.


        """
        return _casadi_core.IMatrix_at(self, *args)


    def elem(self, *args):
        """
        elem(IMatrix self, int rr, int cc=0) -> int



        >  const DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get an element

        >  DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a reference to an element


        """
        return _casadi_core.IMatrix_elem(self, *args)


    def getElement(self, *args):
        """
        getElement(IMatrix self, int rr, int cc=0) -> int const



        get an element, do not allocate


        """
        return _casadi_core.IMatrix_getElement(self, *args)


    def hasNZ(self, *args):
        """
        hasNZ(IMatrix self, int rr, int cc) -> bool



        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi_core.IMatrix_hasNZ(self, *args)


    def __nonzero__(self, *args):
        """
        __nonzero__(IMatrix self) -> bool



        >  bool casadi::Matrix< DataType >::__nonzero__() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Returns the truth value of a Matrix.

        >  bool casadi::Matrix< SXElement >::__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.IMatrix___nonzero__(self, *args)


    def sub(self, *args):
        """
        sub(IMatrix self, int rr, int cc) -> IMatrix
        sub(IMatrix self, IVector rr, int cc) -> IMatrix
        sub(IMatrix self, int rr, IVector cc) -> IMatrix
        sub(IMatrix self, IVector rr, IVector cc) -> IMatrix
        sub(IMatrix self, Slice rr, IVector cc) -> IMatrix
        sub(IMatrix self, IVector rr, Slice cc) -> IMatrix
        sub(IMatrix self, Slice rr, Slice cc) -> IMatrix
        sub(IMatrix self, Slice rr, int cc) -> IMatrix
        sub(IMatrix self, int rr, Slice cc) -> IMatrix
        sub(IMatrix self, IMatrix rr, IVector cc) -> IMatrix
        sub(IMatrix self, IMatrix rr, int cc) -> IMatrix
        sub(IMatrix self, IVector rr, IMatrix cc) -> IMatrix
        sub(IMatrix self, int rr, IMatrix cc) -> IMatrix
        sub(IMatrix self, IMatrix rr, Slice cc) -> IMatrix
        sub(IMatrix self, Slice rr, IMatrix cc) -> IMatrix
        sub(IMatrix self, IMatrix rr, IMatrix cc) -> IMatrix
        sub(IMatrix self, Sparsity sp, int dummy=0) -> IMatrix

        [INTERNAL]  Get a submatrix


        """
        return _casadi_core.IMatrix_sub(self, *args)


    def setSub(self, *args):
        """
        setSub(IMatrix self, IMatrix m, int rr, int cc)
        setSub(IMatrix self, IMatrix m, IVector rr, int cc)
        setSub(IMatrix self, IMatrix m, int rr, IVector cc)
        setSub(IMatrix self, IMatrix m, IVector rr, IVector cc)
        setSub(IMatrix self, IMatrix m, Slice rr, IVector cc)
        setSub(IMatrix self, IMatrix m, IVector rr, Slice cc)
        setSub(IMatrix self, IMatrix m, Slice rr, Slice cc)
        setSub(IMatrix self, IMatrix m, IMatrix rr, IVector cc)
        setSub(IMatrix self, IMatrix m, IMatrix rr, int cc)
        setSub(IMatrix self, IMatrix m, IVector rr, IMatrix cc)
        setSub(IMatrix self, IMatrix m, int rr, IMatrix cc)
        setSub(IMatrix self, IMatrix m, IMatrix rr, Slice cc)
        setSub(IMatrix self, IMatrix m, Slice rr, IMatrix cc)
        setSub(IMatrix self, IMatrix m, IMatrix rr, IMatrix cc)
        setSub(IMatrix self, IMatrix m, Slice rr, int cc)
        setSub(IMatrix self, IMatrix m, int const rr, Slice cc)
        setSub(IMatrix self, IMatrix m, Sparsity sp, int dummy)

        [INTERNAL]  Set a submatrix


        """
        return _casadi_core.IMatrix_setSub(self, *args)


    def getNZ(self, *args):
        """
        getNZ(IMatrix self, int k) -> IMatrix
        getNZ(IMatrix self, IVector k) -> IMatrix
        getNZ(IMatrix self, Slice k) -> IMatrix
        getNZ(IMatrix self, IMatrix k) -> IMatrix



        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(int k) const

        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(const Slice &k) const 
        ------------------------------------------------------------------------

        Get a set of nonzeros

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const std::vector< int > &k) const

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a set of nonzeros


        """
        return _casadi_core.IMatrix_getNZ(self, *args)


    def setNZ(self, *args):
        """
        setNZ(IMatrix self, int k, IMatrix m)
        setNZ(IMatrix self, IVector k, IMatrix m)
        setNZ(IMatrix self, Slice k, IMatrix m)
        setNZ(IMatrix self, IMatrix k, IMatrix m)



        >  void casadi::Matrix< DataType >::setNZ(int k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const std::vector< int > &k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set a set of nonzeros

        >  void casadi::Matrix< T >::setNZ(const Slice &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------

        Set a set of nonzeros


        """
        return _casadi_core.IMatrix_setNZ(self, *args)


    def append(self, *args):
        """
        append(IMatrix self, IMatrix y)

        [INTERNAL]  Append a matrix
        vertically (NOTE: only efficient if vector)


        """
        return _casadi_core.IMatrix_append(self, *args)


    def appendColumns(self, *args):
        """
        appendColumns(IMatrix self, IMatrix y)

        [INTERNAL]  Append a
        matrix horizontally.


        """
        return _casadi_core.IMatrix_appendColumns(self, *args)


    def nz_indexed_one_based(self, *args):
        """
        nz_indexed_one_based(IMatrix self, int k) -> IMatrix
        nz_indexed_one_based(IMatrix self, IMatrix k) -> IMatrix

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.IMatrix_nz_indexed_one_based(self, *args)


    def __NZgetitem__(self, *args):
        """
        __NZgetitem__(IMatrix self, int k) -> IMatrix
        __NZgetitem__(IMatrix self, IMatrix k) -> IMatrix
        __NZgetitem__(IMatrix self, Slice k) -> IMatrix
        __NZgetitem__(IMatrix self, IndexList k) -> IMatrix

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.IMatrix___NZgetitem__(self, *args)


    def indexed_one_based(self, *args):
        """
        indexed_one_based(IMatrix self, IMatrix k) -> IMatrix
        indexed_one_based(IMatrix self, int rr, int cc) -> IMatrix
        indexed_one_based(IMatrix self, int rr) -> IMatrix



        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr, int cc) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a matrix element

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a vector element.


        """
        return _casadi_core.IMatrix_indexed_one_based(self, *args)


    def __Cgetitem__(self, *args):
        """
        __Cgetitem__(IMatrix self, IMatrix k) -> IMatrix
        __Cgetitem__(IMatrix self, int rr, int cc) -> IMatrix
        __Cgetitem__(IMatrix self, Slice rr, Slice cc) -> IMatrix
        __Cgetitem__(IMatrix self, IndexList rr, IndexList cc) -> IMatrix
        __Cgetitem__(IMatrix self, Slice rr, IMatrix cc) -> IMatrix
        __Cgetitem__(IMatrix self, IMatrix rr, IndexList cc) -> IMatrix
        __Cgetitem__(IMatrix self, IMatrix rr, Slice cc) -> IMatrix
        __Cgetitem__(IMatrix self, IndexList rr, IMatrix cc) -> IMatrix
        __Cgetitem__(IMatrix self, IMatrix rr, IMatrix cc) -> IMatrix
        __Cgetitem__(IMatrix self, Sparsity sp) -> IMatrix
        __Cgetitem__(IMatrix self, int rr) -> IMatrix
        __Cgetitem__(IMatrix self, Slice rr) -> IMatrix
        __Cgetitem__(IMatrix self, IndexList rr) -> IMatrix

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.IMatrix___Cgetitem__(self, *args)


    def nz_indexed_one_based_assignment(self, *args):
        """
        nz_indexed_one_based_assignment(IMatrix self, int k, int const & m)
        nz_indexed_one_based_assignment(IMatrix self, IMatrix k, IMatrix m)



        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(int k, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a non-zero

        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.IMatrix_nz_indexed_one_based_assignment(self, *args)


    def __NZsetitem__(self, *args):
        """
        __NZsetitem__(IMatrix self, int k, int const & m)
        __NZsetitem__(IMatrix self, Slice k, IMatrix m)
        __NZsetitem__(IMatrix self, IMatrix k, IMatrix m)
        __NZsetitem__(IMatrix self, IndexList k, IMatrix m)

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.IMatrix___NZsetitem__(self, *args)


    def indexed_one_based_assignment(self, *args):
        """
        indexed_one_based_assignment(IMatrix self, IMatrix k, IMatrix m)
        indexed_one_based_assignment(IMatrix self, int rr, int cc, int const & m)
        indexed_one_based_assignment(IMatrix self, int rr, int const & m)



        >  void casadi::Matrix< T >::indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, int cc, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a matrix element

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a vector element


        """
        return _casadi_core.IMatrix_indexed_one_based_assignment(self, *args)


    def __Csetitem__(self, *args):
        """
        __Csetitem__(IMatrix self, IMatrix k, IMatrix m)
        __Csetitem__(IMatrix self, int rr, int cc, int const & m)
        __Csetitem__(IMatrix self, Slice rr, Slice cc, IMatrix m)
        __Csetitem__(IMatrix self, IndexList rr, IndexList cc, IMatrix m)
        __Csetitem__(IMatrix self, Slice rr, IMatrix cc, IMatrix m)
        __Csetitem__(IMatrix self, IMatrix rr, Slice cc, IMatrix m)
        __Csetitem__(IMatrix self, IMatrix rr, IndexList cc, IMatrix m)
        __Csetitem__(IMatrix self, IndexList rr, IMatrix cc, IMatrix m)
        __Csetitem__(IMatrix self, IMatrix rr, IMatrix cc, IMatrix m)
        __Csetitem__(IMatrix self, Sparsity sp, IMatrix m)
        __Csetitem__(IMatrix self, int rr, int const & m)
        __Csetitem__(IMatrix self, Slice rr, IMatrix m)
        __Csetitem__(IMatrix self, IndexList rr, IMatrix m)



        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Sparsity &sp, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.IMatrix___Csetitem__(self, *args)


    def setZero(self, *args):
        """
        setZero(IMatrix self)

        [INTERNAL]  Set all elements
        to zero.


        """
        return _casadi_core.IMatrix_setZero(self, *args)


    def setAll(self, *args):
        """
        setAll(IMatrix self, int const & val)

        [INTERNAL]  Set all elements
        to a value.


        """
        return _casadi_core.IMatrix_setAll(self, *args)


    def setSparse(self, *args):
        """
        setSparse(IMatrix self, Sparsity sp, bool intersect=False) -> IMatrix

        [INTERNAL]  Set sparse.


        """
        return _casadi_core.IMatrix_setSparse(self, *args)


    def densify(self, *args):
        """
        densify(IMatrix self, int const & val=0)

        [INTERNAL]  Make the matrix
        dense.


        """
        return _casadi_core.IMatrix_densify(self, *args)


    def sparsify(self, *args):
        """
        sparsify(IMatrix self, double tol=0)

        [INTERNAL]  Make a matrix
        sparse by removing numerical zeros smaller in absolute value than a
        specified tolerance.


        """
        return _casadi_core.IMatrix_sparsify(self, *args)


    def __pos__(self, *args):
        """__pos__(IMatrix self) -> IMatrix"""
        return _casadi_core.IMatrix___pos__(self, *args)


    def __neg__(self, *args):
        """__neg__(IMatrix self) -> IMatrix"""
        return _casadi_core.IMatrix___neg__(self, *args)


    def binary(*args):
        """
        binary(int op, IMatrix x, IMatrix y) -> IMatrix

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.IMatrix_binary(*args)

    if _newclass:
        binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary

    def unary(*args):
        """
        unary(int op, IMatrix x) -> IMatrix

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.IMatrix_unary(*args)

    if _newclass:
        unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary

    def scalar_matrix(*args):
        """
        scalar_matrix(int op, IMatrix x, IMatrix y) -> IMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.IMatrix_scalar_matrix(*args)

    if _newclass:
        scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix

    def matrix_scalar(*args):
        """
        matrix_scalar(int op, IMatrix x, IMatrix y) -> IMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.IMatrix_matrix_scalar(*args)

    if _newclass:
        matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar

    def matrix_matrix(*args):
        """
        matrix_matrix(int op, IMatrix x, IMatrix y) -> IMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.IMatrix_matrix_matrix(*args)

    if _newclass:
        matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix

    def mul_full(self, *args):
        """
        mul_full(IMatrix self, IMatrix y, Sparsity sp_z) -> IMatrix

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.IMatrix_mul_full(self, *args)


    def mul_no_alloc_nt(*args):
        """mul_no_alloc_nt(IMatrix x, IMatrix trans_y, IMatrix z)"""
        return _casadi_core.IMatrix_mul_no_alloc_nt(*args)

    if _newclass:
        mul_no_alloc_nt = staticmethod(mul_no_alloc_nt)
    __swig_getmethods__["mul_no_alloc_nt"] = lambda x: mul_no_alloc_nt

    def mul_no_alloc_tn(*args):
        """
        mul_no_alloc_tn(IMatrix trans_x, IMatrix y, IMatrix z)
        mul_no_alloc_tn(IMatrix trans_x, IVector y, IVector z)
        """
        return _casadi_core.IMatrix_mul_no_alloc_tn(*args)

    if _newclass:
        mul_no_alloc_tn = staticmethod(mul_no_alloc_tn)
    __swig_getmethods__["mul_no_alloc_tn"] = lambda x: mul_no_alloc_tn

    def mul_no_alloc_nn(*args):
        """
        mul_no_alloc_nn(IMatrix x, IMatrix y, IMatrix z)
        mul_no_alloc_nn(IMatrix x, IMatrix y, IMatrix z, IVector work)
        mul_no_alloc_nn(IMatrix x, IVector y, IVector z)
        """
        return _casadi_core.IMatrix_mul_no_alloc_nn(*args)

    if _newclass:
        mul_no_alloc_nn = staticmethod(mul_no_alloc_nn)
    __swig_getmethods__["mul_no_alloc_nn"] = lambda x: mul_no_alloc_nn

    def quad_form(*args):
        """quad_form(IVector x, IMatrix A) -> int"""
        return _casadi_core.IMatrix_quad_form(*args)

    if _newclass:
        quad_form = staticmethod(quad_form)
    __swig_getmethods__["quad_form"] = lambda x: quad_form

    def trans(self, *args):
        """
        trans(IMatrix self) -> IMatrix

        [INTERNAL]   Transpose the
        matrix.


        """
        return _casadi_core.IMatrix_trans(self, *args)


    def sin(self, *args):
        """
        sin(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_sin(self, *args)


    def cos(self, *args):
        """
        cos(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_cos(self, *args)


    def tan(self, *args):
        """
        tan(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_tan(self, *args)


    def arcsin(self, *args):
        """
        arcsin(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arcsin(self, *args)


    def arccos(self, *args):
        """
        arccos(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arccos(self, *args)


    def arctan(self, *args):
        """
        arctan(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arctan(self, *args)


    def exp(self, *args):
        """
        exp(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_exp(self, *args)


    def log(self, *args):
        """
        log(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_log(self, *args)


    def sqrt(self, *args):
        """
        sqrt(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_sqrt(self, *args)


    def floor(self, *args):
        """
        floor(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_floor(self, *args)


    def ceil(self, *args):
        """
        ceil(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_ceil(self, *args)


    def fmod(self, *args):
        """
        fmod(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_fmod(self, *args)


    def fabs(self, *args):
        """
        fabs(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_fabs(self, *args)


    def sign(self, *args):
        """
        sign(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_sign(self, *args)


    def erfinv(self, *args):
        """
        erfinv(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_erfinv(self, *args)


    def fmin(self, *args):
        """
        fmin(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_fmin(self, *args)


    def fmax(self, *args):
        """
        fmax(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_fmax(self, *args)


    def erf(self, *args):
        """
        erf(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_erf(self, *args)


    def sinh(self, *args):
        """
        sinh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_sinh(self, *args)


    def cosh(self, *args):
        """
        cosh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_cosh(self, *args)


    def tanh(self, *args):
        """
        tanh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_tanh(self, *args)


    def arcsinh(self, *args):
        """
        arcsinh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arcsinh(self, *args)


    def arccosh(self, *args):
        """
        arccosh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arccosh(self, *args)


    def arctanh(self, *args):
        """
        arctanh(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arctanh(self, *args)


    def arctan2(self, *args):
        """
        arctan2(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_arctan2(self, *args)


    def log10(self, *args):
        """
        log10(IMatrix self) -> IMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.IMatrix_log10(self, *args)


    def printme(self, *args):
        """
        printme(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_printme(self, *args)


    def logic_not(self, *args):
        """
        logic_not(IMatrix self) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_logic_not(self, *args)


    def logic_and(self, *args):
        """
        logic_and(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_logic_and(self, *args)


    def logic_or(self, *args):
        """
        logic_or(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_logic_or(self, *args)


    def if_else_zero(self, *args):
        """
        if_else_zero(IMatrix self, IMatrix y) -> IMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix_if_else_zero(self, *args)


    def setMaxNumCallsInPrint(*args):
        """setMaxNumCallsInPrint(long num=10000)"""
        return _casadi_core.IMatrix_setMaxNumCallsInPrint(*args)

    if _newclass:
        setMaxNumCallsInPrint = staticmethod(setMaxNumCallsInPrint)
    __swig_getmethods__["setMaxNumCallsInPrint"] = lambda x: setMaxNumCallsInPrint

    def getMaxNumCallsInPrint(*args):
        """getMaxNumCallsInPrint() -> long"""
        return _casadi_core.IMatrix_getMaxNumCallsInPrint(*args)

    if _newclass:
        getMaxNumCallsInPrint = staticmethod(getMaxNumCallsInPrint)
    __swig_getmethods__["getMaxNumCallsInPrint"] = lambda x: getMaxNumCallsInPrint

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi_core.IMatrix_setEqualityCheckingDepth(*args)

    if _newclass:
        setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth

    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi_core.IMatrix_getEqualityCheckingDepth(*args)

    if _newclass:
        getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth

    def className(*args):
        """className() -> std::string"""
        return _casadi_core.IMatrix_className(*args)

    if _newclass:
        className = staticmethod(className)
    __swig_getmethods__["className"] = lambda x: className

    def printScalar(self, *args):
        """
        printScalar(IMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        scalar.


        """
        return _casadi_core.IMatrix_printScalar(self, *args)


    def printVector(self, *args):
        """
        printVector(IMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        vector-style.


        """
        return _casadi_core.IMatrix_printVector(self, *args)


    def printDense(self, *args):
        """
        printDense(IMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print dense
        matrix-stype.


        """
        return _casadi_core.IMatrix_printDense(self, *args)


    def printSparse(self, *args):
        """
        printSparse(IMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print sparse
        matrix style.


        """
        return _casadi_core.IMatrix_printSparse(self, *args)


    def row(self, *args):
        """
        row(IMatrix self) -> IVector
        row(IMatrix self, int el) -> int

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_row(self, *args)


    def colind(self, *args):
        """
        colind(IMatrix self) -> IVector
        colind(IMatrix self, int col) -> int

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_colind(self, *args)


    def clear(self, *args):
        """
        clear(IMatrix self)

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_clear(self, *args)


    def resize(self, *args):
        """
        resize(IMatrix self, int nrow, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_resize(self, *args)


    def reserve(self, *args):
        """
        reserve(IMatrix self, int nnz)
        reserve(IMatrix self, int nnz, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_reserve(self, *args)


    def erase(self, *args):
        """
        erase(IMatrix self, IVector rr, IVector cc)

        [INTERNAL]  Erase a submatrix
        Erase rows and/or columns of a matrix.


        """
        return _casadi_core.IMatrix_erase(self, *args)


    def remove(self, *args):
        """
        remove(IMatrix self, IVector rr, IVector cc)

        [INTERNAL]  Remove cols or
        rows Rremove/delete rows and/or columns of a matrix.


        """
        return _casadi_core.IMatrix_remove(self, *args)


    def enlarge(self, *args):
        """
        enlarge(IMatrix self, int nrow, int ncol, IVector rr, IVector cc)

        [INTERNAL]  Enlarge matrix
        Make the matrix larger by inserting empty rows and columns, keeping the
        existing non-zeros.


        """
        return _casadi_core.IMatrix_enlarge(self, *args)


    def data(self, *args):
        """
        data(IMatrix self) -> IVector
        data(IMatrix self) -> IVector



        >  std::vector< DataType > & casadi::Matrix< DataType >::data()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access the non-zero elements.

        >  const std::vector< DataType > & casadi::Matrix< DataType >::data() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Const access the non-zero elements.


        """
        return _casadi_core.IMatrix_data(self, *args)


    def ptr(self, *args):
        """
        ptr(IMatrix self) -> int
        ptr(IMatrix self) -> int const *



        >  DataType* casadi::Matrix< T >::ptr()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a pointer to the data

        >  const DataType* casadi::Matrix< T >::ptr() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a const pointer to the data.


        """
        return _casadi_core.IMatrix_ptr(self, *args)


    def sparsity(self, *args):
        """
        sparsity(IMatrix self) -> Sparsity



        Const access the sparsity - reference to data member.


        """
        return _casadi_core.IMatrix_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(IMatrix self) -> Sparsity

        [INTERNAL]  Access the
        sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.IMatrix_sparsityRef(self, *args)


    def getArray(self, *args):
        """
        getArray(IMatrix self, int * val, int len, casadi::SparsityType sp)
        getArray(IMatrix self, int * val)



        >  void casadi::Matrix< DataType >::getArray(DataType *val, int len, SparsityType sp=SPARSE) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array.

        >  void casadi::Matrix< DataType >::getArray(DataType *val) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.IMatrix_getArray(self, *args)


    def set(self, *args):
        """
        set(IMatrix self, int val, casadi::SparsityType sp)
        set(IMatrix self, IVector val, casadi::SparsityType sp)
        set(IMatrix self, IMatrix val, casadi::SparsityType sp)
        set(IMatrix self, int const * val, int len, casadi::SparsityType sp)
        set(IMatrix self, int const * val)



        >  void casadi::Matrix< DataType >::setArray(const DataType *val, int len, SparsityType sp=SPARSE)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array.

        >  void casadi::Matrix< DataType >::setArray(const DataType *val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.IMatrix_set(self, *args)


    def get(self, *args):
        """
        get(IMatrix self, int & val, casadi::SparsityType sp)
        get(IMatrix self, IVector val, casadi::SparsityType sp)
        get(IMatrix self, IMatrix val, casadi::SparsityType sp)
        get(IMatrix self, int * val, int len, int stride1, int stride2, casadi::SparsityType sp)

        [INTERNAL]  Get the
        non-zero elements, strided array.

        Set stride to zero for unstrided acces


        """
        return _casadi_core.IMatrix_get(self, *args)


    def getBand(self, *args):
        """
        getBand(IMatrix self, int kl, int ku, int ldres, int * res)

        [INTERNAL]  Save the result
        to the LAPACK banded format see LAPACK documentation kl: The number of
        subdiagonals in res ku: The number of superdiagonals in res ldres: The
        leading dimension in res res: The number of superdiagonals.


        """
        return _casadi_core.IMatrix_getBand(self, *args)


    def triplet(*args):
        """
        triplet(IVector row, IVector col, IVector d) -> IMatrix
        triplet(IVector row, IVector col, IVector d, int nrow, int ncol) -> IMatrix
        triplet(IVector row, IVector col, IVector d, Pair_Int_Int rc) -> IMatrix

        [INTERNAL] 
        """
        return _casadi_core.IMatrix_triplet(*args)

    if _newclass:
        triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet

    def inf(*args):
        """
        inf(Sparsity sp) -> IMatrix
        inf(int nrow=1, int ncol=1) -> IMatrix
        inf(Pair_Int_Int rc) -> IMatrix

        [INTERNAL]  create a matrix with
        all inf


        """
        return _casadi_core.IMatrix_inf(*args)

    if _newclass:
        inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf

    def nan(*args):
        """
        nan(Sparsity sp) -> IMatrix
        nan(int nrow=1, int ncol=1) -> IMatrix
        nan(Pair_Int_Int rc) -> IMatrix

        [INTERNAL]  create a matrix with
        all nan


        """
        return _casadi_core.IMatrix_nan(*args)

    if _newclass:
        nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan

    def repmat(*args):
        """
        repmat(int const & x, Sparsity sp) -> IMatrix
        repmat(IMatrix x, Sparsity sp) -> IMatrix
        repmat(IMatrix x, int nrow, int ncol=1) -> IMatrix
        repmat(IMatrix x, Pair_Int_Int rc) -> IMatrix

        [INTERNAL]  create a matrix
        by repeating an existing matrix


        """
        return _casadi_core.IMatrix_repmat(*args)

    if _newclass:
        repmat = staticmethod(repmat)
    __swig_getmethods__["repmat"] = lambda x: repmat

    def eye(*args):
        """eye(int ncol) -> IMatrix"""
        return _casadi_core.IMatrix_eye(*args)

    if _newclass:
        eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye

    def isRegular(self, *args):
        """
        isRegular(IMatrix self) -> bool

        [INTERNAL]  Checks if
        expression does not contain NaN or Inf.


        """
        return _casadi_core.IMatrix_isRegular(self, *args)


    def isSmooth(self, *args):
        """
        isSmooth(IMatrix self) -> bool

        [INTERNAL]  Check if
        smooth.


        """
        return _casadi_core.IMatrix_isSmooth(self, *args)


    def isSymbolic(self, *args):
        """
        isSymbolic(IMatrix self) -> bool

        [INTERNAL]  Check if
        symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi_core.IMatrix_isSymbolic(self, *args)


    def isSymbolicSparse(self, *args):
        """
        isSymbolicSparse(IMatrix self) -> bool

        [INTERNAL]  Check
        if symbolic Sparse matrices can return true if all non-zero elements are
        symbolic.


        """
        return _casadi_core.IMatrix_isSymbolicSparse(self, *args)


    def isConstant(self, *args):
        """
        isConstant(IMatrix self) -> bool

        [INTERNAL]  Check if the
        matrix is constant (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isConstant(self, *args)


    def isInteger(self, *args):
        """
        isInteger(IMatrix self) -> bool

        [INTERNAL]  Check if the
        matrix is integer-valued (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isInteger(self, *args)


    def isZero(self, *args):
        """
        isZero(IMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is 0 (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isZero(self, *args)


    def isOne(self, *args):
        """
        isOne(IMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is 1 (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isOne(self, *args)


    def isMinusOne(self, *args):
        """
        isMinusOne(IMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is -1 (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isMinusOne(self, *args)


    def isIdentity(self, *args):
        """
        isIdentity(IMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is an identity matrix (note that false negative answers are possible)


        """
        return _casadi_core.IMatrix_isIdentity(self, *args)


    def isEqual(self, *args):
        """
        isEqual(IMatrix self, IMatrix ex2) -> bool

        [INTERNAL]  Check if two
        expressions are equal May give false negatives.

        Note: does not work when CasadiOptions.setSimplificationOnTheFly(False) was
        called


        """
        return _casadi_core.IMatrix_isEqual(self, *args)


    def hasNonStructuralZeros(self, *args):
        """
        hasNonStructuralZeros(IMatrix self) -> bool

        [INTERNAL]
        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi_core.IMatrix_hasNonStructuralZeros(self, *args)


    def getValue(self, *args):
        """
        getValue(IMatrix self) -> double

        [INTERNAL]  Get double
        value (only if constant)


        """
        return _casadi_core.IMatrix_getValue(self, *args)


    def getName(self, *args):
        """
        getName(IMatrix self) -> std::string

        [INTERNAL]  Get name (only
        if symbolic scalar)


        """
        return _casadi_core.IMatrix_getName(self, *args)


    def setPrecision(*args):
        """
        setPrecision(int precision)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.IMatrix_setPrecision(*args)

    if _newclass:
        setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision

    def setWidth(*args):
        """
        setWidth(int width)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.IMatrix_setWidth(*args)

    if _newclass:
        setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth

    def setScientific(*args):
        """
        setScientific(bool scientific)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.IMatrix_setScientific(*args)

    if _newclass:
        setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific

    def assign(self, *args):
        """assign(IMatrix self, IMatrix rhs)"""
        return _casadi_core.IMatrix_assign(self, *args)



    def toMatrix(self):
        import numpy as n
        return n.matrix(self.toArray())

    def __iter__(self):
      for k in self.nz:
        yield k



    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi_core.reshape(self,arg)

    @property
    def T(self):
        return _casadi_core.transpose(self)

    def __getitem__(self,s):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Cgetitem__(s[0],s[1])  
        return self.__Cgetitem__(s)

    def __setitem__(self,s,val):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Csetitem__(s[0],s[1],val)  
        return self.__Csetitem__(s,val)

    @property
    def nz(self):
      return NZproxy(self)

    def prod(self,*args):
        raise Exception("'prod' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")




    __array_priority__ = 998.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.toArray()



    def toArray(self):
      import numpy as n
      r = n.zeros((self.size1(),self.size2()))
      for i in range(r.shape[0]):
        for j in range(r.shape[1]):
          r[i,j] = self.elem(i,j)
      return r


    def __float__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to a float")
      if self.size()==0:
        return 0.0
      return float(self.toScalar())


    def __int__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to an int")
      if self.size()==0:
        return 0
      return self.toScalar()


    def __rfmin__(self, *args):
        """
        __rfmin__(IMatrix self, IMatrix b) -> IMatrix
        __rfmin__(IMatrix self, SX b) -> SX
        __rfmin__(IMatrix self, DMatrix b) -> DMatrix
        __rfmin__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rfmin__(self, *args)


    def __rfmax__(self, *args):
        """
        __rfmax__(IMatrix self, IMatrix b) -> IMatrix
        __rfmax__(IMatrix self, SX b) -> SX
        __rfmax__(IMatrix self, DMatrix b) -> DMatrix
        __rfmax__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rfmax__(self, *args)


    def __constpow__(self, *args):
        """
        __constpow__(IMatrix self, IMatrix y) -> IMatrix
        __constpow__(IMatrix self, SX b) -> SX
        __constpow__(IMatrix self, DMatrix b) -> DMatrix
        __constpow__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___constpow__(self, *args)


    def __rconstpow__(self, *args):
        """
        __rconstpow__(IMatrix self, IMatrix b) -> IMatrix
        __rconstpow__(IMatrix self, SX b) -> SX
        __rconstpow__(IMatrix self, DMatrix b) -> DMatrix
        __rconstpow__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rconstpow__(self, *args)


    def __rarctan2__(self, *args):
        """
        __rarctan2__(IMatrix self, IMatrix b) -> IMatrix
        __rarctan2__(IMatrix self, SX b) -> SX
        __rarctan2__(IMatrix self, DMatrix b) -> DMatrix
        __rarctan2__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rarctan2__(self, *args)


    def __copysign__(self, *args):
        """
        __copysign__(IMatrix self, IMatrix y) -> IMatrix
        __copysign__(IMatrix self, SX b) -> SX
        __copysign__(IMatrix self, DMatrix b) -> DMatrix
        __copysign__(IMatrix self, MX b) -> MX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.IMatrix___copysign__(self, *args)


    def __rcopysign__(self, *args):
        """
        __rcopysign__(IMatrix self, IMatrix b) -> IMatrix
        __rcopysign__(IMatrix self, SX b) -> SX
        __rcopysign__(IMatrix self, DMatrix b) -> DMatrix
        __rcopysign__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rcopysign__(self, *args)


    def __pow__(self, *args):
        """
        __pow__(IMatrix self, IMatrix y) -> IMatrix
        __pow__(IMatrix self, SX b) -> SX
        __pow__(IMatrix self, DMatrix b) -> DMatrix
        __pow__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___pow__(self, *args)


    def __rpow__(self, *args):
        """
        __rpow__(IMatrix self, IMatrix b) -> IMatrix
        __rpow__(IMatrix self, SX b) -> SX
        __rpow__(IMatrix self, DMatrix b) -> DMatrix
        __rpow__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rpow__(self, *args)


    def __add__(self, *args):
        """
        __add__(IMatrix self, IMatrix y) -> IMatrix
        __add__(IMatrix self, SX b) -> SX
        __add__(IMatrix self, DMatrix b) -> DMatrix
        __add__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___add__(self, *args)


    def __radd__(self, *args):
        """
        __radd__(IMatrix self, IMatrix b) -> IMatrix
        __radd__(IMatrix self, SX b) -> SX
        __radd__(IMatrix self, DMatrix b) -> DMatrix
        __radd__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___radd__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(IMatrix self, IMatrix y) -> IMatrix
        __sub__(IMatrix self, SX b) -> SX
        __sub__(IMatrix self, DMatrix b) -> DMatrix
        __sub__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___sub__(self, *args)


    def __rsub__(self, *args):
        """
        __rsub__(IMatrix self, IMatrix b) -> IMatrix
        __rsub__(IMatrix self, SX b) -> SX
        __rsub__(IMatrix self, DMatrix b) -> DMatrix
        __rsub__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rsub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(IMatrix self, IMatrix y) -> IMatrix
        __mul__(IMatrix self, SX b) -> SX
        __mul__(IMatrix self, DMatrix b) -> DMatrix
        __mul__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___mul__(self, *args)


    def __rmul__(self, *args):
        """
        __rmul__(IMatrix self, IMatrix b) -> IMatrix
        __rmul__(IMatrix self, SX b) -> SX
        __rmul__(IMatrix self, DMatrix b) -> DMatrix
        __rmul__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rmul__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(IMatrix self, IMatrix y) -> IMatrix
        __ge__(IMatrix self, SX b) -> SX
        __ge__(IMatrix self, DMatrix b) -> DMatrix
        __ge__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___ge__(self, *args)


    def __rge__(self, *args):
        """
        __rge__(IMatrix self, IMatrix b) -> IMatrix
        __rge__(IMatrix self, SX b) -> SX
        __rge__(IMatrix self, DMatrix b) -> DMatrix
        __rge__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rge__(self, *args)


    def __le__(self, *args):
        """
        __le__(IMatrix self, IMatrix y) -> IMatrix
        __le__(IMatrix self, SX b) -> SX
        __le__(IMatrix self, DMatrix b) -> DMatrix
        __le__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___le__(self, *args)


    def __rle__(self, *args):
        """
        __rle__(IMatrix self, IMatrix b) -> IMatrix
        __rle__(IMatrix self, SX b) -> SX
        __rle__(IMatrix self, DMatrix b) -> DMatrix
        __rle__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rle__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(IMatrix self, IMatrix y) -> IMatrix
        __gt__(IMatrix self, SX b) -> SX
        __gt__(IMatrix self, DMatrix b) -> DMatrix
        __gt__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___gt__(self, *args)


    def __rgt__(self, *args):
        """
        __rgt__(IMatrix self, IMatrix b) -> IMatrix
        __rgt__(IMatrix self, SX b) -> SX
        __rgt__(IMatrix self, DMatrix b) -> DMatrix
        __rgt__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rgt__(self, *args)


    def __lt__(self, *args):
        """
        __lt__(IMatrix self, IMatrix y) -> IMatrix
        __lt__(IMatrix self, SX b) -> SX
        __lt__(IMatrix self, DMatrix b) -> DMatrix
        __lt__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___lt__(self, *args)


    def __rlt__(self, *args):
        """
        __rlt__(IMatrix self, IMatrix b) -> IMatrix
        __rlt__(IMatrix self, SX b) -> SX
        __rlt__(IMatrix self, DMatrix b) -> DMatrix
        __rlt__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rlt__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(IMatrix self, IMatrix y) -> IMatrix
        __eq__(IMatrix self, SX b) -> SX
        __eq__(IMatrix self, DMatrix b) -> DMatrix
        __eq__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___eq__(self, *args)


    def __req__(self, *args):
        """
        __req__(IMatrix self, IMatrix b) -> IMatrix
        __req__(IMatrix self, SX b) -> SX
        __req__(IMatrix self, DMatrix b) -> DMatrix
        __req__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___req__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(IMatrix self, IMatrix y) -> IMatrix
        __ne__(IMatrix self, SX b) -> SX
        __ne__(IMatrix self, DMatrix b) -> DMatrix
        __ne__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___ne__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(IMatrix self, IMatrix b) -> IMatrix
        __rne__(IMatrix self, SX b) -> SX
        __rne__(IMatrix self, DMatrix b) -> DMatrix
        __rne__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rne__(self, *args)


    def mul(self, *args):
        """
        mul(IMatrix self, IMatrix y, Sparsity sp_z) -> IMatrix
        mul(IMatrix self, SX b) -> SX
        mul(IMatrix self, DMatrix b) -> DMatrix
        mul(IMatrix self, MX b) -> MX

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.IMatrix_mul(self, *args)


    def rmul(self, *args):
        """
        rmul(IMatrix self, IMatrix b) -> IMatrix
        rmul(IMatrix self, SX b) -> SX
        rmul(IMatrix self, DMatrix b) -> DMatrix
        rmul(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix_rmul(self, *args)


    def __div__(self, *args):
        """
        __div__(IMatrix self, IMatrix y) -> IMatrix
        __div__(IMatrix self, SX b) -> SX
        __div__(IMatrix self, DMatrix b) -> DMatrix
        __div__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___div__(self, *args)


    def __rdiv__(self, *args):
        """
        __rdiv__(IMatrix self, IMatrix b) -> IMatrix
        __rdiv__(IMatrix self, SX b) -> SX
        __rdiv__(IMatrix self, DMatrix b) -> DMatrix
        __rdiv__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rdiv__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(IMatrix self, IMatrix y) -> IMatrix
        __truediv__(IMatrix self, SX b) -> SX
        __truediv__(IMatrix self, DMatrix b) -> DMatrix
        __truediv__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___truediv__(self, *args)


    def __rtruediv__(self, *args):
        """
        __rtruediv__(IMatrix self, IMatrix b) -> IMatrix
        __rtruediv__(IMatrix self, SX b) -> SX
        __rtruediv__(IMatrix self, DMatrix b) -> DMatrix
        __rtruediv__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rtruediv__(self, *args)


    def __mldivide__(self, *args):
        """
        __mldivide__(IMatrix self, SX b) -> SX
        __mldivide__(IMatrix self, DMatrix b) -> DMatrix
        __mldivide__(IMatrix self, MX b) -> MX



        Matrix division from left.


        """
        return _casadi_core.IMatrix___mldivide__(self, *args)


    def __rmldivide__(self, *args):
        """
        __rmldivide__(IMatrix self, IMatrix b) -> IMatrix
        __rmldivide__(IMatrix self, SX b) -> SX
        __rmldivide__(IMatrix self, DMatrix b) -> DMatrix
        __rmldivide__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rmldivide__(self, *args)


    def __mrdivide__(self, *args):
        """
        __mrdivide__(IMatrix self, IMatrix y) -> IMatrix
        __mrdivide__(IMatrix self, SX b) -> SX
        __mrdivide__(IMatrix self, DMatrix b) -> DMatrix
        __mrdivide__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___mrdivide__(self, *args)


    def __rmrdivide__(self, *args):
        """
        __rmrdivide__(IMatrix self, IMatrix b) -> IMatrix
        __rmrdivide__(IMatrix self, SX b) -> SX
        __rmrdivide__(IMatrix self, DMatrix b) -> DMatrix
        __rmrdivide__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rmrdivide__(self, *args)


    def __mpower__(self, *args):
        """
        __mpower__(IMatrix self, IMatrix y) -> IMatrix
        __mpower__(IMatrix self, SX b) -> SX
        __mpower__(IMatrix self, DMatrix b) -> DMatrix
        __mpower__(IMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.IMatrix___mpower__(self, *args)


    def __rmpower__(self, *args):
        """
        __rmpower__(IMatrix self, IMatrix b) -> IMatrix
        __rmpower__(IMatrix self, SX b) -> SX
        __rmpower__(IMatrix self, DMatrix b) -> DMatrix
        __rmpower__(IMatrix self, MX b) -> MX
        """
        return _casadi_core.IMatrix___rmpower__(self, *args)


    def __abs__(self):
      return int(self.__int__())


    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.data(),dtype=int)}

    __swig_destroy__ = _casadi_core.delete_IMatrix
IMatrix_swigregister = _casadi_core.IMatrix_swigregister
IMatrix_swigregister(IMatrix)

def IMatrix_binary(*args):
    """
    IMatrix_binary(int op, IMatrix x, IMatrix y) -> IMatrix

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.IMatrix_binary(*args)

def IMatrix_unary(*args):
    """
    IMatrix_unary(int op, IMatrix x) -> IMatrix

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.IMatrix_unary(*args)

def IMatrix_scalar_matrix(*args):
    """
    IMatrix_scalar_matrix(int op, IMatrix x, IMatrix y) -> IMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.IMatrix_scalar_matrix(*args)

def IMatrix_matrix_scalar(*args):
    """
    IMatrix_matrix_scalar(int op, IMatrix x, IMatrix y) -> IMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.IMatrix_matrix_scalar(*args)

def IMatrix_matrix_matrix(*args):
    """
    IMatrix_matrix_matrix(int op, IMatrix x, IMatrix y) -> IMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.IMatrix_matrix_matrix(*args)

def IMatrix_mul_no_alloc_nt(*args):
    """IMatrix_mul_no_alloc_nt(IMatrix x, IMatrix trans_y, IMatrix z)"""
    return _casadi_core.IMatrix_mul_no_alloc_nt(*args)

def IMatrix_mul_no_alloc_tn(*args):
    """
    mul_no_alloc_tn(IMatrix trans_x, IMatrix y, IMatrix z)
    IMatrix_mul_no_alloc_tn(IMatrix trans_x, IVector y, IVector z)
    """
    return _casadi_core.IMatrix_mul_no_alloc_tn(*args)

def IMatrix_mul_no_alloc_nn(*args):
    """
    mul_no_alloc_nn(IMatrix x, IMatrix y, IMatrix z)
    mul_no_alloc_nn(IMatrix x, IMatrix y, IMatrix z, IVector work)
    IMatrix_mul_no_alloc_nn(IMatrix x, IVector y, IVector z)
    """
    return _casadi_core.IMatrix_mul_no_alloc_nn(*args)

def IMatrix_quad_form(*args):
    """IMatrix_quad_form(IVector x, IMatrix A) -> int"""
    return _casadi_core.IMatrix_quad_form(*args)

def IMatrix_setMaxNumCallsInPrint(*args):
    """IMatrix_setMaxNumCallsInPrint(long num=10000)"""
    return _casadi_core.IMatrix_setMaxNumCallsInPrint(*args)

def IMatrix_getMaxNumCallsInPrint(*args):
    """IMatrix_getMaxNumCallsInPrint() -> long"""
    return _casadi_core.IMatrix_getMaxNumCallsInPrint(*args)

def IMatrix_setEqualityCheckingDepth(*args):
    """IMatrix_setEqualityCheckingDepth(int eq_depth=1)"""
    return _casadi_core.IMatrix_setEqualityCheckingDepth(*args)

def IMatrix_getEqualityCheckingDepth(*args):
    """IMatrix_getEqualityCheckingDepth() -> int"""
    return _casadi_core.IMatrix_getEqualityCheckingDepth(*args)

def IMatrix_className(*args):
    """IMatrix_className() -> std::string"""
    return _casadi_core.IMatrix_className(*args)

def IMatrix_triplet(*args):
    """
    triplet(IVector row, IVector col, IVector d) -> IMatrix
    triplet(IVector row, IVector col, IVector d, int nrow, int ncol) -> IMatrix
    IMatrix_triplet(IVector row, IVector col, IVector d, Pair_Int_Int rc) -> IMatrix

    [INTERNAL] 
    """
    return _casadi_core.IMatrix_triplet(*args)

def IMatrix_inf(*args):
    """
    inf(Sparsity sp) -> IMatrix
    inf(int nrow=1, int ncol=1) -> IMatrix
    IMatrix_inf(Pair_Int_Int rc) -> IMatrix

    [INTERNAL]  create a matrix with
    all inf


    """
    return _casadi_core.IMatrix_inf(*args)

def IMatrix_nan(*args):
    """
    nan(Sparsity sp) -> IMatrix
    nan(int nrow=1, int ncol=1) -> IMatrix
    IMatrix_nan(Pair_Int_Int rc) -> IMatrix

    [INTERNAL]  create a matrix with
    all nan


    """
    return _casadi_core.IMatrix_nan(*args)

def IMatrix_repmat(*args):
    """
    repmat(int const & x, Sparsity sp) -> IMatrix
    repmat(IMatrix x, Sparsity sp) -> IMatrix
    repmat(IMatrix x, int nrow, int ncol=1) -> IMatrix
    IMatrix_repmat(IMatrix x, Pair_Int_Int rc) -> IMatrix

    [INTERNAL]  create a matrix
    by repeating an existing matrix


    """
    return _casadi_core.IMatrix_repmat(*args)

def IMatrix_eye(*args):
    """IMatrix_eye(int ncol) -> IMatrix"""
    return _casadi_core.IMatrix_eye(*args)

def IMatrix_setPrecision(*args):
    """
    IMatrix_setPrecision(int precision)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.IMatrix_setPrecision(*args)

def IMatrix_setWidth(*args):
    """
    IMatrix_setWidth(int width)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.IMatrix_setWidth(*args)

def IMatrix_setScientific(*args):
    """
    IMatrix_setScientific(bool scientific)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.IMatrix_setScientific(*args)

class DMatrix(ExpDMatrix, GenDMatrix, PrintDMatrix):
    """


    Sparse matrix class. SX and DMatrix are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero. Matrix<DataType> is polymorphic with a
    std::vector<DataType> that contain all non- identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [ExpDMatrix, GenDMatrix, PrintDMatrix]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpDMatrix, GenDMatrix, PrintDMatrix]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DMatrix, name)
    __repr__ = _swig_repr

    def sanityCheck(self, *args):
        """
        sanityCheck(DMatrix self, bool complete=False)

         [INTERNAL]  Check if
        the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi_core.DMatrix_sanityCheck(self, *args)


    def toScalar(self, *args):
        """
        toScalar(DMatrix self) -> double const

        [INTERNAL]  Convert to
        scalar type.


        """
        return _casadi_core.DMatrix_toScalar(self, *args)


    def at(self, *args):
        """
        at(DMatrix self, int k) -> double



        >  const DataType& casadi::Matrix< T >::at(int k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a non-zero element.

        >  DataType& casadi::Matrix< T >::at(int k)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access a non-zero element.


        """
        return _casadi_core.DMatrix_at(self, *args)


    def elem(self, *args):
        """
        elem(DMatrix self, int rr, int cc=0) -> double



        >  const DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get an element

        >  DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a reference to an element


        """
        return _casadi_core.DMatrix_elem(self, *args)


    def getElement(self, *args):
        """
        getElement(DMatrix self, int rr, int cc=0) -> double const



        get an element, do not allocate


        """
        return _casadi_core.DMatrix_getElement(self, *args)


    def hasNZ(self, *args):
        """
        hasNZ(DMatrix self, int rr, int cc) -> bool



        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi_core.DMatrix_hasNZ(self, *args)


    def __nonzero__(self, *args):
        """
        __nonzero__(DMatrix self) -> bool



        >  bool casadi::Matrix< DataType >::__nonzero__() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Returns the truth value of a Matrix.

        >  bool casadi::Matrix< SXElement >::__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.DMatrix___nonzero__(self, *args)


    def sub(self, *args):
        """
        sub(DMatrix self, int rr, int cc) -> DMatrix
        sub(DMatrix self, IVector rr, int cc) -> DMatrix
        sub(DMatrix self, int rr, IVector cc) -> DMatrix
        sub(DMatrix self, IVector rr, IVector cc) -> DMatrix
        sub(DMatrix self, Slice rr, IVector cc) -> DMatrix
        sub(DMatrix self, IVector rr, Slice cc) -> DMatrix
        sub(DMatrix self, Slice rr, Slice cc) -> DMatrix
        sub(DMatrix self, Slice rr, int cc) -> DMatrix
        sub(DMatrix self, int rr, Slice cc) -> DMatrix
        sub(DMatrix self, IMatrix rr, IVector cc) -> DMatrix
        sub(DMatrix self, IMatrix rr, int cc) -> DMatrix
        sub(DMatrix self, IVector rr, IMatrix cc) -> DMatrix
        sub(DMatrix self, int rr, IMatrix cc) -> DMatrix
        sub(DMatrix self, IMatrix rr, Slice cc) -> DMatrix
        sub(DMatrix self, Slice rr, IMatrix cc) -> DMatrix
        sub(DMatrix self, IMatrix rr, IMatrix cc) -> DMatrix
        sub(DMatrix self, Sparsity sp, int dummy=0) -> DMatrix

        [INTERNAL]  Get a submatrix


        """
        return _casadi_core.DMatrix_sub(self, *args)


    def setSub(self, *args):
        """
        setSub(DMatrix self, DMatrix m, int rr, int cc)
        setSub(DMatrix self, DMatrix m, IVector rr, int cc)
        setSub(DMatrix self, DMatrix m, int rr, IVector cc)
        setSub(DMatrix self, DMatrix m, IVector rr, IVector cc)
        setSub(DMatrix self, DMatrix m, Slice rr, IVector cc)
        setSub(DMatrix self, DMatrix m, IVector rr, Slice cc)
        setSub(DMatrix self, DMatrix m, Slice rr, Slice cc)
        setSub(DMatrix self, DMatrix m, IMatrix rr, IVector cc)
        setSub(DMatrix self, DMatrix m, IMatrix rr, int cc)
        setSub(DMatrix self, DMatrix m, IVector rr, IMatrix cc)
        setSub(DMatrix self, DMatrix m, int rr, IMatrix cc)
        setSub(DMatrix self, DMatrix m, IMatrix rr, Slice cc)
        setSub(DMatrix self, DMatrix m, Slice rr, IMatrix cc)
        setSub(DMatrix self, DMatrix m, IMatrix rr, IMatrix cc)
        setSub(DMatrix self, DMatrix m, Slice rr, int cc)
        setSub(DMatrix self, DMatrix m, int const rr, Slice cc)
        setSub(DMatrix self, DMatrix m, Sparsity sp, int dummy)

        [INTERNAL]  Set a submatrix


        """
        return _casadi_core.DMatrix_setSub(self, *args)


    def getNZ(self, *args):
        """
        getNZ(DMatrix self, int k) -> DMatrix
        getNZ(DMatrix self, IVector k) -> DMatrix
        getNZ(DMatrix self, Slice k) -> DMatrix
        getNZ(DMatrix self, IMatrix k) -> DMatrix



        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(int k) const

        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(const Slice &k) const 
        ------------------------------------------------------------------------

        Get a set of nonzeros

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const std::vector< int > &k) const

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a set of nonzeros


        """
        return _casadi_core.DMatrix_getNZ(self, *args)


    def setNZ(self, *args):
        """
        setNZ(DMatrix self, int k, DMatrix m)
        setNZ(DMatrix self, IVector k, DMatrix m)
        setNZ(DMatrix self, Slice k, DMatrix m)
        setNZ(DMatrix self, IMatrix k, DMatrix m)



        >  void casadi::Matrix< DataType >::setNZ(int k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const std::vector< int > &k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set a set of nonzeros

        >  void casadi::Matrix< T >::setNZ(const Slice &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------

        Set a set of nonzeros


        """
        return _casadi_core.DMatrix_setNZ(self, *args)


    def append(self, *args):
        """
        append(DMatrix self, DMatrix y)

        [INTERNAL]  Append a matrix
        vertically (NOTE: only efficient if vector)


        """
        return _casadi_core.DMatrix_append(self, *args)


    def appendColumns(self, *args):
        """
        appendColumns(DMatrix self, DMatrix y)

        [INTERNAL]  Append a
        matrix horizontally.


        """
        return _casadi_core.DMatrix_appendColumns(self, *args)


    def nz_indexed_one_based(self, *args):
        """
        nz_indexed_one_based(DMatrix self, int k) -> DMatrix
        nz_indexed_one_based(DMatrix self, IMatrix k) -> DMatrix

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.DMatrix_nz_indexed_one_based(self, *args)


    def __NZgetitem__(self, *args):
        """
        __NZgetitem__(DMatrix self, int k) -> DMatrix
        __NZgetitem__(DMatrix self, IMatrix k) -> DMatrix
        __NZgetitem__(DMatrix self, Slice k) -> DMatrix
        __NZgetitem__(DMatrix self, IndexList k) -> DMatrix

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.DMatrix___NZgetitem__(self, *args)


    def indexed_one_based(self, *args):
        """
        indexed_one_based(DMatrix self, IMatrix k) -> DMatrix
        indexed_one_based(DMatrix self, int rr, int cc) -> DMatrix
        indexed_one_based(DMatrix self, int rr) -> DMatrix



        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr, int cc) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a matrix element

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a vector element.


        """
        return _casadi_core.DMatrix_indexed_one_based(self, *args)


    def __Cgetitem__(self, *args):
        """
        __Cgetitem__(DMatrix self, IMatrix k) -> DMatrix
        __Cgetitem__(DMatrix self, int rr, int cc) -> DMatrix
        __Cgetitem__(DMatrix self, Slice rr, Slice cc) -> DMatrix
        __Cgetitem__(DMatrix self, IndexList rr, IndexList cc) -> DMatrix
        __Cgetitem__(DMatrix self, Slice rr, IMatrix cc) -> DMatrix
        __Cgetitem__(DMatrix self, IMatrix rr, IndexList cc) -> DMatrix
        __Cgetitem__(DMatrix self, IMatrix rr, Slice cc) -> DMatrix
        __Cgetitem__(DMatrix self, IndexList rr, IMatrix cc) -> DMatrix
        __Cgetitem__(DMatrix self, IMatrix rr, IMatrix cc) -> DMatrix
        __Cgetitem__(DMatrix self, Sparsity sp) -> DMatrix
        __Cgetitem__(DMatrix self, int rr) -> DMatrix
        __Cgetitem__(DMatrix self, Slice rr) -> DMatrix
        __Cgetitem__(DMatrix self, IndexList rr) -> DMatrix

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.DMatrix___Cgetitem__(self, *args)


    def nz_indexed_one_based_assignment(self, *args):
        """
        nz_indexed_one_based_assignment(DMatrix self, int k, double const & m)
        nz_indexed_one_based_assignment(DMatrix self, IMatrix k, DMatrix m)



        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(int k, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a non-zero

        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.DMatrix_nz_indexed_one_based_assignment(self, *args)


    def __NZsetitem__(self, *args):
        """
        __NZsetitem__(DMatrix self, int k, double const & m)
        __NZsetitem__(DMatrix self, Slice k, DMatrix m)
        __NZsetitem__(DMatrix self, IMatrix k, DMatrix m)
        __NZsetitem__(DMatrix self, IndexList k, DMatrix m)

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.DMatrix___NZsetitem__(self, *args)


    def indexed_one_based_assignment(self, *args):
        """
        indexed_one_based_assignment(DMatrix self, IMatrix k, DMatrix m)
        indexed_one_based_assignment(DMatrix self, int rr, int cc, double const & m)
        indexed_one_based_assignment(DMatrix self, int rr, double const & m)



        >  void casadi::Matrix< T >::indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, int cc, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a matrix element

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a vector element


        """
        return _casadi_core.DMatrix_indexed_one_based_assignment(self, *args)


    def __Csetitem__(self, *args):
        """
        __Csetitem__(DMatrix self, IMatrix k, DMatrix m)
        __Csetitem__(DMatrix self, int rr, int cc, double const & m)
        __Csetitem__(DMatrix self, Slice rr, Slice cc, DMatrix m)
        __Csetitem__(DMatrix self, IndexList rr, IndexList cc, DMatrix m)
        __Csetitem__(DMatrix self, Slice rr, IMatrix cc, DMatrix m)
        __Csetitem__(DMatrix self, IMatrix rr, Slice cc, DMatrix m)
        __Csetitem__(DMatrix self, IMatrix rr, IndexList cc, DMatrix m)
        __Csetitem__(DMatrix self, IndexList rr, IMatrix cc, DMatrix m)
        __Csetitem__(DMatrix self, IMatrix rr, IMatrix cc, DMatrix m)
        __Csetitem__(DMatrix self, Sparsity sp, DMatrix m)
        __Csetitem__(DMatrix self, int rr, double const & m)
        __Csetitem__(DMatrix self, Slice rr, DMatrix m)
        __Csetitem__(DMatrix self, IndexList rr, DMatrix m)



        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Sparsity &sp, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.DMatrix___Csetitem__(self, *args)


    def setZero(self, *args):
        """
        setZero(DMatrix self)

        [INTERNAL]  Set all elements
        to zero.


        """
        return _casadi_core.DMatrix_setZero(self, *args)


    def setAll(self, *args):
        """
        setAll(DMatrix self, double const & val)

        [INTERNAL]  Set all elements
        to a value.


        """
        return _casadi_core.DMatrix_setAll(self, *args)


    def setSparse(self, *args):
        """
        setSparse(DMatrix self, Sparsity sp, bool intersect=False) -> DMatrix

        [INTERNAL]  Set sparse.


        """
        return _casadi_core.DMatrix_setSparse(self, *args)


    def densify(self, *args):
        """
        densify(DMatrix self, double const & val=0)

        [INTERNAL]  Make the matrix
        dense.


        """
        return _casadi_core.DMatrix_densify(self, *args)


    def sparsify(self, *args):
        """
        sparsify(DMatrix self, double tol=0)

        [INTERNAL]  Make a matrix
        sparse by removing numerical zeros smaller in absolute value than a
        specified tolerance.


        """
        return _casadi_core.DMatrix_sparsify(self, *args)


    def __pos__(self, *args):
        """__pos__(DMatrix self) -> DMatrix"""
        return _casadi_core.DMatrix___pos__(self, *args)


    def __neg__(self, *args):
        """__neg__(DMatrix self) -> DMatrix"""
        return _casadi_core.DMatrix___neg__(self, *args)


    def binary(*args):
        """
        binary(int op, DMatrix x, DMatrix y) -> DMatrix

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.DMatrix_binary(*args)

    if _newclass:
        binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary

    def unary(*args):
        """
        unary(int op, DMatrix x) -> DMatrix

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.DMatrix_unary(*args)

    if _newclass:
        unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary

    def scalar_matrix(*args):
        """
        scalar_matrix(int op, DMatrix x, DMatrix y) -> DMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.DMatrix_scalar_matrix(*args)

    if _newclass:
        scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix

    def matrix_scalar(*args):
        """
        matrix_scalar(int op, DMatrix x, DMatrix y) -> DMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.DMatrix_matrix_scalar(*args)

    if _newclass:
        matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar

    def matrix_matrix(*args):
        """
        matrix_matrix(int op, DMatrix x, DMatrix y) -> DMatrix

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.DMatrix_matrix_matrix(*args)

    if _newclass:
        matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix

    def mul_full(self, *args):
        """
        mul_full(DMatrix self, DMatrix y, Sparsity sp_z) -> DMatrix

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.DMatrix_mul_full(self, *args)


    def mul_no_alloc_nt(*args):
        """mul_no_alloc_nt(DMatrix x, DMatrix trans_y, DMatrix z)"""
        return _casadi_core.DMatrix_mul_no_alloc_nt(*args)

    if _newclass:
        mul_no_alloc_nt = staticmethod(mul_no_alloc_nt)
    __swig_getmethods__["mul_no_alloc_nt"] = lambda x: mul_no_alloc_nt

    def mul_no_alloc_tn(*args):
        """
        mul_no_alloc_tn(DMatrix trans_x, DMatrix y, DMatrix z)
        mul_no_alloc_tn(DMatrix trans_x, DVector y, DVector z)
        """
        return _casadi_core.DMatrix_mul_no_alloc_tn(*args)

    if _newclass:
        mul_no_alloc_tn = staticmethod(mul_no_alloc_tn)
    __swig_getmethods__["mul_no_alloc_tn"] = lambda x: mul_no_alloc_tn

    def mul_no_alloc_nn(*args):
        """
        mul_no_alloc_nn(DMatrix x, DMatrix y, DMatrix z)
        mul_no_alloc_nn(DMatrix x, DMatrix y, DMatrix z, DVector work)
        mul_no_alloc_nn(DMatrix x, DVector y, DVector z)
        """
        return _casadi_core.DMatrix_mul_no_alloc_nn(*args)

    if _newclass:
        mul_no_alloc_nn = staticmethod(mul_no_alloc_nn)
    __swig_getmethods__["mul_no_alloc_nn"] = lambda x: mul_no_alloc_nn

    def quad_form(*args):
        """quad_form(DVector x, DMatrix A) -> double"""
        return _casadi_core.DMatrix_quad_form(*args)

    if _newclass:
        quad_form = staticmethod(quad_form)
    __swig_getmethods__["quad_form"] = lambda x: quad_form

    def trans(self, *args):
        """
        trans(DMatrix self) -> DMatrix

        [INTERNAL]   Transpose the
        matrix.


        """
        return _casadi_core.DMatrix_trans(self, *args)


    def sin(self, *args):
        """
        sin(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_sin(self, *args)


    def cos(self, *args):
        """
        cos(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_cos(self, *args)


    def tan(self, *args):
        """
        tan(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_tan(self, *args)


    def arcsin(self, *args):
        """
        arcsin(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arcsin(self, *args)


    def arccos(self, *args):
        """
        arccos(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arccos(self, *args)


    def arctan(self, *args):
        """
        arctan(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arctan(self, *args)


    def exp(self, *args):
        """
        exp(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_exp(self, *args)


    def log(self, *args):
        """
        log(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_log(self, *args)


    def sqrt(self, *args):
        """
        sqrt(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_sqrt(self, *args)


    def floor(self, *args):
        """
        floor(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_floor(self, *args)


    def ceil(self, *args):
        """
        ceil(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_ceil(self, *args)


    def fmod(self, *args):
        """
        fmod(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_fmod(self, *args)


    def fabs(self, *args):
        """
        fabs(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_fabs(self, *args)


    def sign(self, *args):
        """
        sign(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_sign(self, *args)


    def erfinv(self, *args):
        """
        erfinv(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_erfinv(self, *args)


    def fmin(self, *args):
        """
        fmin(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_fmin(self, *args)


    def fmax(self, *args):
        """
        fmax(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_fmax(self, *args)


    def erf(self, *args):
        """
        erf(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_erf(self, *args)


    def sinh(self, *args):
        """
        sinh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_sinh(self, *args)


    def cosh(self, *args):
        """
        cosh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_cosh(self, *args)


    def tanh(self, *args):
        """
        tanh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_tanh(self, *args)


    def arcsinh(self, *args):
        """
        arcsinh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arcsinh(self, *args)


    def arccosh(self, *args):
        """
        arccosh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arccosh(self, *args)


    def arctanh(self, *args):
        """
        arctanh(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arctanh(self, *args)


    def arctan2(self, *args):
        """
        arctan2(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_arctan2(self, *args)


    def log10(self, *args):
        """
        log10(DMatrix self) -> DMatrix

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.DMatrix_log10(self, *args)


    def printme(self, *args):
        """
        printme(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_printme(self, *args)


    def logic_not(self, *args):
        """
        logic_not(DMatrix self) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_logic_not(self, *args)


    def logic_and(self, *args):
        """
        logic_and(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_logic_and(self, *args)


    def logic_or(self, *args):
        """
        logic_or(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_logic_or(self, *args)


    def if_else_zero(self, *args):
        """
        if_else_zero(DMatrix self, DMatrix y) -> DMatrix

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix_if_else_zero(self, *args)


    def setMaxNumCallsInPrint(*args):
        """setMaxNumCallsInPrint(long num=10000)"""
        return _casadi_core.DMatrix_setMaxNumCallsInPrint(*args)

    if _newclass:
        setMaxNumCallsInPrint = staticmethod(setMaxNumCallsInPrint)
    __swig_getmethods__["setMaxNumCallsInPrint"] = lambda x: setMaxNumCallsInPrint

    def getMaxNumCallsInPrint(*args):
        """getMaxNumCallsInPrint() -> long"""
        return _casadi_core.DMatrix_getMaxNumCallsInPrint(*args)

    if _newclass:
        getMaxNumCallsInPrint = staticmethod(getMaxNumCallsInPrint)
    __swig_getmethods__["getMaxNumCallsInPrint"] = lambda x: getMaxNumCallsInPrint

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi_core.DMatrix_setEqualityCheckingDepth(*args)

    if _newclass:
        setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth

    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi_core.DMatrix_getEqualityCheckingDepth(*args)

    if _newclass:
        getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth

    def className(*args):
        """className() -> std::string"""
        return _casadi_core.DMatrix_className(*args)

    if _newclass:
        className = staticmethod(className)
    __swig_getmethods__["className"] = lambda x: className

    def printScalar(self, *args):
        """
        printScalar(DMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        scalar.


        """
        return _casadi_core.DMatrix_printScalar(self, *args)


    def printVector(self, *args):
        """
        printVector(DMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        vector-style.


        """
        return _casadi_core.DMatrix_printVector(self, *args)


    def printDense(self, *args):
        """
        printDense(DMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print dense
        matrix-stype.


        """
        return _casadi_core.DMatrix_printDense(self, *args)


    def printSparse(self, *args):
        """
        printSparse(DMatrix self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print sparse
        matrix style.


        """
        return _casadi_core.DMatrix_printSparse(self, *args)


    def row(self, *args):
        """
        row(DMatrix self) -> IVector
        row(DMatrix self, int el) -> int

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_row(self, *args)


    def colind(self, *args):
        """
        colind(DMatrix self) -> IVector
        colind(DMatrix self, int col) -> int

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_colind(self, *args)


    def clear(self, *args):
        """
        clear(DMatrix self)

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_clear(self, *args)


    def resize(self, *args):
        """
        resize(DMatrix self, int nrow, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_resize(self, *args)


    def reserve(self, *args):
        """
        reserve(DMatrix self, int nnz)
        reserve(DMatrix self, int nnz, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_reserve(self, *args)


    def erase(self, *args):
        """
        erase(DMatrix self, IVector rr, IVector cc)

        [INTERNAL]  Erase a submatrix
        Erase rows and/or columns of a matrix.


        """
        return _casadi_core.DMatrix_erase(self, *args)


    def remove(self, *args):
        """
        remove(DMatrix self, IVector rr, IVector cc)

        [INTERNAL]  Remove cols or
        rows Rremove/delete rows and/or columns of a matrix.


        """
        return _casadi_core.DMatrix_remove(self, *args)


    def enlarge(self, *args):
        """
        enlarge(DMatrix self, int nrow, int ncol, IVector rr, IVector cc)

        [INTERNAL]  Enlarge matrix
        Make the matrix larger by inserting empty rows and columns, keeping the
        existing non-zeros.


        """
        return _casadi_core.DMatrix_enlarge(self, *args)


    def data(self, *args):
        """
        data(DMatrix self) -> DVector
        data(DMatrix self) -> DVector



        >  std::vector< DataType > & casadi::Matrix< DataType >::data()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access the non-zero elements.

        >  const std::vector< DataType > & casadi::Matrix< DataType >::data() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Const access the non-zero elements.


        """
        return _casadi_core.DMatrix_data(self, *args)


    def ptr(self, *args):
        """
        ptr(DMatrix self) -> double
        ptr(DMatrix self) -> double const *



        >  DataType* casadi::Matrix< T >::ptr()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a pointer to the data

        >  const DataType* casadi::Matrix< T >::ptr() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a const pointer to the data.


        """
        return _casadi_core.DMatrix_ptr(self, *args)


    def sparsity(self, *args):
        """
        sparsity(DMatrix self) -> Sparsity



        Const access the sparsity - reference to data member.


        """
        return _casadi_core.DMatrix_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(DMatrix self) -> Sparsity

        [INTERNAL]  Access the
        sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.DMatrix_sparsityRef(self, *args)


    def getArray(self, *args):
        """
        getArray(DMatrix self, double * val, int len, casadi::SparsityType sp)
        getArray(DMatrix self, double * val)



        >  void casadi::Matrix< DataType >::getArray(DataType *val, int len, SparsityType sp=SPARSE) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array.

        >  void casadi::Matrix< DataType >::getArray(DataType *val) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.DMatrix_getArray(self, *args)


    def set(self, *args):
        """
        set(DMatrix self, double val, casadi::SparsityType sp)
        set(DMatrix self, DVector val, casadi::SparsityType sp)
        set(DMatrix self, DMatrix val, casadi::SparsityType sp)
        set(DMatrix self, double const * val)
        set(DMatrix self, double const * val)



        >  void casadi::Matrix< DataType >::setArray(const DataType *val, int len, SparsityType sp=SPARSE)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array.

        >  void casadi::Matrix< DataType >::setArray(const DataType *val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.DMatrix_set(self, *args)


    def get(self, *args):
        """
        get(DMatrix self, double & val, casadi::SparsityType sp)
        get(DMatrix self, DVector val, casadi::SparsityType sp)
        get(DMatrix self, DMatrix val, casadi::SparsityType sp)
        get(DMatrix self, double * val)

        [INTERNAL]  Get the
        non-zero elements, strided array.

        Set stride to zero for unstrided acces


        """
        return _casadi_core.DMatrix_get(self, *args)


    def getBand(self, *args):
        """
        getBand(DMatrix self, int kl, int ku, int ldres, double * res)

        [INTERNAL]  Save the result
        to the LAPACK banded format see LAPACK documentation kl: The number of
        subdiagonals in res ku: The number of superdiagonals in res ldres: The
        leading dimension in res res: The number of superdiagonals.


        """
        return _casadi_core.DMatrix_getBand(self, *args)


    def triplet(*args):
        """
        triplet(IVector row, IVector col, DVector d) -> DMatrix
        triplet(IVector row, IVector col, DVector d, int nrow, int ncol) -> DMatrix
        triplet(IVector row, IVector col, DVector d, Pair_Int_Int rc) -> DMatrix

        [INTERNAL] 
        """
        return _casadi_core.DMatrix_triplet(*args)

    if _newclass:
        triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet

    def inf(*args):
        """
        inf(Sparsity sp) -> DMatrix
        inf(int nrow=1, int ncol=1) -> DMatrix
        inf(Pair_Int_Int rc) -> DMatrix

        [INTERNAL]  create a matrix with
        all inf


        """
        return _casadi_core.DMatrix_inf(*args)

    if _newclass:
        inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf

    def nan(*args):
        """
        nan(Sparsity sp) -> DMatrix
        nan(int nrow=1, int ncol=1) -> DMatrix
        nan(Pair_Int_Int rc) -> DMatrix

        [INTERNAL]  create a matrix with
        all nan


        """
        return _casadi_core.DMatrix_nan(*args)

    if _newclass:
        nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan

    def repmat(*args):
        """
        repmat(double const & x, Sparsity sp) -> DMatrix
        repmat(DMatrix x, Sparsity sp) -> DMatrix
        repmat(DMatrix x, int nrow, int ncol=1) -> DMatrix
        repmat(DMatrix x, Pair_Int_Int rc) -> DMatrix

        [INTERNAL]  create a matrix
        by repeating an existing matrix


        """
        return _casadi_core.DMatrix_repmat(*args)

    if _newclass:
        repmat = staticmethod(repmat)
    __swig_getmethods__["repmat"] = lambda x: repmat

    def eye(*args):
        """eye(int ncol) -> DMatrix"""
        return _casadi_core.DMatrix_eye(*args)

    if _newclass:
        eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye

    def isRegular(self, *args):
        """
        isRegular(DMatrix self) -> bool

        [INTERNAL]  Checks if
        expression does not contain NaN or Inf.


        """
        return _casadi_core.DMatrix_isRegular(self, *args)


    def isSmooth(self, *args):
        """
        isSmooth(DMatrix self) -> bool

        [INTERNAL]  Check if
        smooth.


        """
        return _casadi_core.DMatrix_isSmooth(self, *args)


    def isSymbolic(self, *args):
        """
        isSymbolic(DMatrix self) -> bool

        [INTERNAL]  Check if
        symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi_core.DMatrix_isSymbolic(self, *args)


    def isSymbolicSparse(self, *args):
        """
        isSymbolicSparse(DMatrix self) -> bool

        [INTERNAL]  Check
        if symbolic Sparse matrices can return true if all non-zero elements are
        symbolic.


        """
        return _casadi_core.DMatrix_isSymbolicSparse(self, *args)


    def isConstant(self, *args):
        """
        isConstant(DMatrix self) -> bool

        [INTERNAL]  Check if the
        matrix is constant (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isConstant(self, *args)


    def isInteger(self, *args):
        """
        isInteger(DMatrix self) -> bool

        [INTERNAL]  Check if the
        matrix is integer-valued (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isInteger(self, *args)


    def isZero(self, *args):
        """
        isZero(DMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is 0 (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isZero(self, *args)


    def isOne(self, *args):
        """
        isOne(DMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is 1 (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isOne(self, *args)


    def isMinusOne(self, *args):
        """
        isMinusOne(DMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is -1 (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isMinusOne(self, *args)


    def isIdentity(self, *args):
        """
        isIdentity(DMatrix self) -> bool

        [INTERNAL]  check if the
        matrix is an identity matrix (note that false negative answers are possible)


        """
        return _casadi_core.DMatrix_isIdentity(self, *args)


    def isEqual(self, *args):
        """
        isEqual(DMatrix self, DMatrix ex2) -> bool

        [INTERNAL]  Check if two
        expressions are equal May give false negatives.

        Note: does not work when CasadiOptions.setSimplificationOnTheFly(False) was
        called


        """
        return _casadi_core.DMatrix_isEqual(self, *args)


    def hasNonStructuralZeros(self, *args):
        """
        hasNonStructuralZeros(DMatrix self) -> bool

        [INTERNAL]
        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi_core.DMatrix_hasNonStructuralZeros(self, *args)


    def getValue(self, *args):
        """
        getValue(DMatrix self) -> double

        [INTERNAL]  Get double
        value (only if constant)


        """
        return _casadi_core.DMatrix_getValue(self, *args)


    def getName(self, *args):
        """
        getName(DMatrix self) -> std::string

        [INTERNAL]  Get name (only
        if symbolic scalar)


        """
        return _casadi_core.DMatrix_getName(self, *args)


    def setPrecision(*args):
        """
        setPrecision(int precision)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.DMatrix_setPrecision(*args)

    if _newclass:
        setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision

    def setWidth(*args):
        """
        setWidth(int width)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.DMatrix_setWidth(*args)

    if _newclass:
        setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth

    def setScientific(*args):
        """
        setScientific(bool scientific)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.DMatrix_setScientific(*args)

    if _newclass:
        setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific

    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)



    def __init__(self, *args):
        """
        __init__(casadi::Matrix<(double)> self) -> DMatrix
        __init__(casadi::Matrix<(double)> self, DMatrix m) -> DMatrix
        __init__(casadi::Matrix<(double)> self, DVectorVector m) -> DMatrix
        __init__(casadi::Matrix<(double)> self, Sparsity sparsity, double const & val) -> DMatrix
        __init__(casadi::Matrix<(double)> self, Sparsity sparsity, DVector d) -> DMatrix
        __init__(casadi::Matrix<(double)> self, double val) -> DMatrix
        __init__(casadi::Matrix<(double)> self, DVector x) -> DMatrix
        __init__(casadi::Matrix<(double)> self, DVector x, int nrow, int ncol) -> DMatrix
        __init__(casadi::Matrix<(double)> self, IMatrix x) -> DMatrix
        __init__(casadi::Matrix<(double)> self, IVector x) -> DMatrix
        __init__(casadi::Matrix<(double)> self, IVector x, int nrow, int ncol) -> DMatrix



        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const DataType &val=DataType(0))
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity

        >  casadi::Matrix< DataType >::Matrix()
        ------------------------------------------------------------------------
        [INTERNAL] 
        constructors

        empty 0-by-0 matrix constructor

        >  casadi::Matrix< DataType >::Matrix(const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Copy constructor.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< std::vector< DataType > > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Dense matrix constructor with data given as vector of vectors.

        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const std::vector< DataType > &d)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity and non-zero elements.

        >  casadi::Matrix< DataType >::Matrix(double val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        This constructor enables implicit type conversion from a numeric type.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct from a vector.

        Thanks to implicit conversion, you can pretend that Matrix(const SXElement&
        x); exists. Note: above remark applies only to C++, not python or octave
        interfaces

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x, int nrow, int ncol)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct dense matrix from a vector with the elements in column major
        ordering.

        >  casadi::Matrix< T >::Matrix(const Matrix< A > &x)
        ------------------------------------------------------------------------

        Create a matrix from a matrix with a different type of matrix entries
        (assuming that the scalar conversion is valid)

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x)
        ------------------------------------------------------------------------

        Create an expression from an stl vector.

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x, int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a non-vector expression from an stl vector.


        """
        this = _casadi_core.new_DMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def assign(self, *args):
        """assign(DMatrix self, DMatrix rhs)"""
        return _casadi_core.DMatrix_assign(self, *args)



    def toMatrix(self):
        import numpy as n
        return n.matrix(self.toArray())

    def __iter__(self):
      for k in self.nz:
        yield k



    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi_core.reshape(self,arg)

    @property
    def T(self):
        return _casadi_core.transpose(self)

    def __getitem__(self,s):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Cgetitem__(s[0],s[1])  
        return self.__Cgetitem__(s)

    def __setitem__(self,s,val):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Csetitem__(s[0],s[1],val)  
        return self.__Csetitem__(s,val)

    @property
    def nz(self):
      return NZproxy(self)

    def prod(self,*args):
        raise Exception("'prod' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")



    def arrayView(self, *args):
        """arrayView(DMatrix self) -> PyObject *"""
        return _casadi_core.DMatrix_arrayView(self, *args)


    def toArray(self,shared=False):
      import numpy as n
      if shared:
        if self.size()!=self.numel():
          raise Expection("toArray(shared=True) only possible for dense arrays.")
        return self.arrayView()
      else:
        r = n.zeros((self.size1(),self.size2()))
        self.get(r)
      return r



    __array_priority__ = 999.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.toArray()



    def __array_custom__(self,*args,**kwargs):
      if "dtype" in kwargs and not(isinstance(kwargs["dtype"],n.double)):
        return n.array(self.toArray(),dtype=kwargs["dtype"])
      else:
        return self.toArray()


    def toCsc_matrix(self):
      import numpy as n
      import warnings
      with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        from scipy.sparse import csc_matrix
      return csc_matrix( (list(self.data()),self.row(),self.colind()), shape = self.shape, dtype=n.double )

    def tocsc(self):
      return self.toCsc_matrix()



    def __float__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to a float")
      if self.size()==0:
        return 0.0
      return self.toScalar()


    def __int__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to an int")
      if self.size()==0:
        return 0
      return int(self.toScalar())


    def __nonzero__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to a float")
      if self.size()==0:
        return 0
      return self.toScalar()!=0


    def __abs__(self):
      return abs(self.__float__())


    def __rfmin__(self, *args):
        """
        __rfmin__(DMatrix self, DMatrix b) -> DMatrix
        __rfmin__(DMatrix self, SX b) -> SX
        __rfmin__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rfmin__(self, *args)


    def __rfmax__(self, *args):
        """
        __rfmax__(DMatrix self, DMatrix b) -> DMatrix
        __rfmax__(DMatrix self, SX b) -> SX
        __rfmax__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rfmax__(self, *args)


    def __constpow__(self, *args):
        """
        __constpow__(DMatrix self, DMatrix y) -> DMatrix
        __constpow__(DMatrix self, SX b) -> SX
        __constpow__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___constpow__(self, *args)


    def __rconstpow__(self, *args):
        """
        __rconstpow__(DMatrix self, DMatrix b) -> DMatrix
        __rconstpow__(DMatrix self, SX b) -> SX
        __rconstpow__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rconstpow__(self, *args)


    def __rarctan2__(self, *args):
        """
        __rarctan2__(DMatrix self, DMatrix b) -> DMatrix
        __rarctan2__(DMatrix self, SX b) -> SX
        __rarctan2__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rarctan2__(self, *args)


    def __copysign__(self, *args):
        """
        __copysign__(DMatrix self, DMatrix y) -> DMatrix
        __copysign__(DMatrix self, SX b) -> SX
        __copysign__(DMatrix self, MX b) -> MX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.DMatrix___copysign__(self, *args)


    def __rcopysign__(self, *args):
        """
        __rcopysign__(DMatrix self, DMatrix b) -> DMatrix
        __rcopysign__(DMatrix self, SX b) -> SX
        __rcopysign__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rcopysign__(self, *args)


    def __pow__(self, *args):
        """
        __pow__(DMatrix self, DMatrix y) -> DMatrix
        __pow__(DMatrix self, SX b) -> SX
        __pow__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___pow__(self, *args)


    def __rpow__(self, *args):
        """
        __rpow__(DMatrix self, DMatrix b) -> DMatrix
        __rpow__(DMatrix self, SX b) -> SX
        __rpow__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rpow__(self, *args)


    def __add__(self, *args):
        """
        __add__(DMatrix self, DMatrix y) -> DMatrix
        __add__(DMatrix self, SX b) -> SX
        __add__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___add__(self, *args)


    def __radd__(self, *args):
        """
        __radd__(DMatrix self, DMatrix b) -> DMatrix
        __radd__(DMatrix self, SX b) -> SX
        __radd__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___radd__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(DMatrix self, DMatrix y) -> DMatrix
        __sub__(DMatrix self, SX b) -> SX
        __sub__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___sub__(self, *args)


    def __rsub__(self, *args):
        """
        __rsub__(DMatrix self, DMatrix b) -> DMatrix
        __rsub__(DMatrix self, SX b) -> SX
        __rsub__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rsub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(DMatrix self, DMatrix y) -> DMatrix
        __mul__(DMatrix self, SX b) -> SX
        __mul__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___mul__(self, *args)


    def __rmul__(self, *args):
        """
        __rmul__(DMatrix self, DMatrix b) -> DMatrix
        __rmul__(DMatrix self, SX b) -> SX
        __rmul__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rmul__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(DMatrix self, DMatrix y) -> DMatrix
        __ge__(DMatrix self, SX b) -> SX
        __ge__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___ge__(self, *args)


    def __rge__(self, *args):
        """
        __rge__(DMatrix self, DMatrix b) -> DMatrix
        __rge__(DMatrix self, SX b) -> SX
        __rge__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rge__(self, *args)


    def __le__(self, *args):
        """
        __le__(DMatrix self, DMatrix y) -> DMatrix
        __le__(DMatrix self, SX b) -> SX
        __le__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___le__(self, *args)


    def __rle__(self, *args):
        """
        __rle__(DMatrix self, DMatrix b) -> DMatrix
        __rle__(DMatrix self, SX b) -> SX
        __rle__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rle__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(DMatrix self, DMatrix y) -> DMatrix
        __gt__(DMatrix self, SX b) -> SX
        __gt__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___gt__(self, *args)


    def __rgt__(self, *args):
        """
        __rgt__(DMatrix self, DMatrix b) -> DMatrix
        __rgt__(DMatrix self, SX b) -> SX
        __rgt__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rgt__(self, *args)


    def __lt__(self, *args):
        """
        __lt__(DMatrix self, DMatrix y) -> DMatrix
        __lt__(DMatrix self, SX b) -> SX
        __lt__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___lt__(self, *args)


    def __rlt__(self, *args):
        """
        __rlt__(DMatrix self, DMatrix b) -> DMatrix
        __rlt__(DMatrix self, SX b) -> SX
        __rlt__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rlt__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(DMatrix self, DMatrix y) -> DMatrix
        __eq__(DMatrix self, SX b) -> SX
        __eq__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___eq__(self, *args)


    def __req__(self, *args):
        """
        __req__(DMatrix self, DMatrix b) -> DMatrix
        __req__(DMatrix self, SX b) -> SX
        __req__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___req__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(DMatrix self, DMatrix y) -> DMatrix
        __ne__(DMatrix self, SX b) -> SX
        __ne__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___ne__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(DMatrix self, DMatrix b) -> DMatrix
        __rne__(DMatrix self, SX b) -> SX
        __rne__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rne__(self, *args)


    def mul(self, *args):
        """
        mul(DMatrix self, DMatrix y, Sparsity sp_z) -> DMatrix
        mul(DMatrix self, SX b) -> SX
        mul(DMatrix self, MX b) -> MX

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.DMatrix_mul(self, *args)


    def rmul(self, *args):
        """
        rmul(DMatrix self, DMatrix b) -> DMatrix
        rmul(DMatrix self, SX b) -> SX
        rmul(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix_rmul(self, *args)


    def __div__(self, *args):
        """
        __div__(DMatrix self, DMatrix y) -> DMatrix
        __div__(DMatrix self, SX b) -> SX
        __div__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___div__(self, *args)


    def __rdiv__(self, *args):
        """
        __rdiv__(DMatrix self, DMatrix b) -> DMatrix
        __rdiv__(DMatrix self, SX b) -> SX
        __rdiv__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rdiv__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(DMatrix self, DMatrix y) -> DMatrix
        __truediv__(DMatrix self, SX b) -> SX
        __truediv__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___truediv__(self, *args)


    def __rtruediv__(self, *args):
        """
        __rtruediv__(DMatrix self, DMatrix b) -> DMatrix
        __rtruediv__(DMatrix self, SX b) -> SX
        __rtruediv__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rtruediv__(self, *args)


    def __mldivide__(self, *args):
        """
        __mldivide__(DMatrix self, SX b) -> SX
        __mldivide__(DMatrix self, MX b) -> MX



        Matrix division from left.


        """
        return _casadi_core.DMatrix___mldivide__(self, *args)


    def __rmldivide__(self, *args):
        """
        __rmldivide__(DMatrix self, DMatrix b) -> DMatrix
        __rmldivide__(DMatrix self, SX b) -> SX
        __rmldivide__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rmldivide__(self, *args)


    def __mrdivide__(self, *args):
        """
        __mrdivide__(DMatrix self, DMatrix y) -> DMatrix
        __mrdivide__(DMatrix self, SX b) -> SX
        __mrdivide__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___mrdivide__(self, *args)


    def __rmrdivide__(self, *args):
        """
        __rmrdivide__(DMatrix self, DMatrix b) -> DMatrix
        __rmrdivide__(DMatrix self, SX b) -> SX
        __rmrdivide__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rmrdivide__(self, *args)


    def __mpower__(self, *args):
        """
        __mpower__(DMatrix self, DMatrix y) -> DMatrix
        __mpower__(DMatrix self, SX b) -> SX
        __mpower__(DMatrix self, MX b) -> MX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.DMatrix___mpower__(self, *args)


    def __rmpower__(self, *args):
        """
        __rmpower__(DMatrix self, DMatrix b) -> DMatrix
        __rmpower__(DMatrix self, SX b) -> SX
        __rmpower__(DMatrix self, MX b) -> MX
        """
        return _casadi_core.DMatrix___rmpower__(self, *args)


    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.data(),dtype=float)}

    __swig_destroy__ = _casadi_core.delete_DMatrix
DMatrix_swigregister = _casadi_core.DMatrix_swigregister
DMatrix_swigregister(DMatrix)

def DMatrix_binary(*args):
    """
    DMatrix_binary(int op, DMatrix x, DMatrix y) -> DMatrix

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.DMatrix_binary(*args)

def DMatrix_unary(*args):
    """
    DMatrix_unary(int op, DMatrix x) -> DMatrix

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.DMatrix_unary(*args)

def DMatrix_scalar_matrix(*args):
    """
    DMatrix_scalar_matrix(int op, DMatrix x, DMatrix y) -> DMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.DMatrix_scalar_matrix(*args)

def DMatrix_matrix_scalar(*args):
    """
    DMatrix_matrix_scalar(int op, DMatrix x, DMatrix y) -> DMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.DMatrix_matrix_scalar(*args)

def DMatrix_matrix_matrix(*args):
    """
    DMatrix_matrix_matrix(int op, DMatrix x, DMatrix y) -> DMatrix

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.DMatrix_matrix_matrix(*args)

def DMatrix_mul_no_alloc_nt(*args):
    """DMatrix_mul_no_alloc_nt(DMatrix x, DMatrix trans_y, DMatrix z)"""
    return _casadi_core.DMatrix_mul_no_alloc_nt(*args)

def DMatrix_mul_no_alloc_tn(*args):
    """
    mul_no_alloc_tn(DMatrix trans_x, DMatrix y, DMatrix z)
    DMatrix_mul_no_alloc_tn(DMatrix trans_x, DVector y, DVector z)
    """
    return _casadi_core.DMatrix_mul_no_alloc_tn(*args)

def DMatrix_mul_no_alloc_nn(*args):
    """
    mul_no_alloc_nn(DMatrix x, DMatrix y, DMatrix z)
    mul_no_alloc_nn(DMatrix x, DMatrix y, DMatrix z, DVector work)
    DMatrix_mul_no_alloc_nn(DMatrix x, DVector y, DVector z)
    """
    return _casadi_core.DMatrix_mul_no_alloc_nn(*args)

def DMatrix_quad_form(*args):
    """DMatrix_quad_form(DVector x, DMatrix A) -> double"""
    return _casadi_core.DMatrix_quad_form(*args)

def DMatrix_setMaxNumCallsInPrint(*args):
    """DMatrix_setMaxNumCallsInPrint(long num=10000)"""
    return _casadi_core.DMatrix_setMaxNumCallsInPrint(*args)

def DMatrix_getMaxNumCallsInPrint(*args):
    """DMatrix_getMaxNumCallsInPrint() -> long"""
    return _casadi_core.DMatrix_getMaxNumCallsInPrint(*args)

def DMatrix_setEqualityCheckingDepth(*args):
    """DMatrix_setEqualityCheckingDepth(int eq_depth=1)"""
    return _casadi_core.DMatrix_setEqualityCheckingDepth(*args)

def DMatrix_getEqualityCheckingDepth(*args):
    """DMatrix_getEqualityCheckingDepth() -> int"""
    return _casadi_core.DMatrix_getEqualityCheckingDepth(*args)

def DMatrix_className(*args):
    """DMatrix_className() -> std::string"""
    return _casadi_core.DMatrix_className(*args)

def DMatrix_triplet(*args):
    """
    triplet(IVector row, IVector col, DVector d) -> DMatrix
    triplet(IVector row, IVector col, DVector d, int nrow, int ncol) -> DMatrix
    DMatrix_triplet(IVector row, IVector col, DVector d, Pair_Int_Int rc) -> DMatrix

    [INTERNAL] 
    """
    return _casadi_core.DMatrix_triplet(*args)

def DMatrix_inf(*args):
    """
    inf(Sparsity sp) -> DMatrix
    inf(int nrow=1, int ncol=1) -> DMatrix
    DMatrix_inf(Pair_Int_Int rc) -> DMatrix

    [INTERNAL]  create a matrix with
    all inf


    """
    return _casadi_core.DMatrix_inf(*args)

def DMatrix_nan(*args):
    """
    nan(Sparsity sp) -> DMatrix
    nan(int nrow=1, int ncol=1) -> DMatrix
    DMatrix_nan(Pair_Int_Int rc) -> DMatrix

    [INTERNAL]  create a matrix with
    all nan


    """
    return _casadi_core.DMatrix_nan(*args)

def DMatrix_repmat(*args):
    """
    repmat(double const & x, Sparsity sp) -> DMatrix
    repmat(DMatrix x, Sparsity sp) -> DMatrix
    repmat(DMatrix x, int nrow, int ncol=1) -> DMatrix
    DMatrix_repmat(DMatrix x, Pair_Int_Int rc) -> DMatrix

    [INTERNAL]  create a matrix
    by repeating an existing matrix


    """
    return _casadi_core.DMatrix_repmat(*args)

def DMatrix_eye(*args):
    """DMatrix_eye(int ncol) -> DMatrix"""
    return _casadi_core.DMatrix_eye(*args)

def DMatrix_setPrecision(*args):
    """
    DMatrix_setPrecision(int precision)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.DMatrix_setPrecision(*args)

def DMatrix_setWidth(*args):
    """
    DMatrix_setWidth(int width)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.DMatrix_setWidth(*args)

def DMatrix_setScientific(*args):
    """
    DMatrix_setScientific(bool scientific)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.DMatrix_setScientific(*args)

class SXElement(ExpSXElement, PrintSXElement):
    """


    The basic scalar symbolic class of CasADi.

    Joel Andersson

    C++ includes: sx_element.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [ExpSXElement, PrintSXElement]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElement, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpSXElement, PrintSXElement]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SXElement, name)
    __repr__ = _swig_repr

    def sym(*args):
        """sym(std::string const & name) -> SXElement"""
        return _casadi_core.SXElement_sym(*args)

    if _newclass:
        sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym

    def binary(*args):
        """binary(int op, SXElement x, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_binary(*args)

    if _newclass:
        binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary

    def unary(*args):
        """unary(int op, SXElement x) -> SXElement"""
        return _casadi_core.SXElement_unary(*args)

    if _newclass:
        unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary

    def __nonzero__(self, *args):
        """
        __nonzero__(SXElement self) -> bool



        Check the truth value of this node Introduced to catch bool(x) situations in
        python.


        """
        return _casadi_core.SXElement___nonzero__(self, *args)


    def isLeaf(self, *args):
        """
        isLeaf(SXElement self) -> bool



        check if this SXElement is a leaf of the SX graph

        An SXElement qualifies as leaf when it has no dependencies.


        """
        return _casadi_core.SXElement_isLeaf(self, *args)


    def isConstant(self, *args):
        """isConstant(SXElement self) -> bool"""
        return _casadi_core.SXElement_isConstant(self, *args)


    def isInteger(self, *args):
        """isInteger(SXElement self) -> bool"""
        return _casadi_core.SXElement_isInteger(self, *args)


    def isSymbolic(self, *args):
        """isSymbolic(SXElement self) -> bool"""
        return _casadi_core.SXElement_isSymbolic(self, *args)


    def hasDep(self, *args):
        """hasDep(SXElement self) -> bool"""
        return _casadi_core.SXElement_hasDep(self, *args)


    def isCommutative(self, *args):
        """
        isCommutative(SXElement self) -> bool



        Check whether a binary SXElement is commutative.


        """
        return _casadi_core.SXElement_isCommutative(self, *args)


    def isZero(self, *args):
        """isZero(SXElement self) -> bool"""
        return _casadi_core.SXElement_isZero(self, *args)


    def isAlmostZero(self, *args):
        """isAlmostZero(SXElement self, double tol) -> bool"""
        return _casadi_core.SXElement_isAlmostZero(self, *args)


    def isOne(self, *args):
        """isOne(SXElement self) -> bool"""
        return _casadi_core.SXElement_isOne(self, *args)


    def isMinusOne(self, *args):
        """isMinusOne(SXElement self) -> bool"""
        return _casadi_core.SXElement_isMinusOne(self, *args)


    def isNan(self, *args):
        """isNan(SXElement self) -> bool"""
        return _casadi_core.SXElement_isNan(self, *args)


    def isInf(self, *args):
        """isInf(SXElement self) -> bool"""
        return _casadi_core.SXElement_isInf(self, *args)


    def isMinusInf(self, *args):
        """isMinusInf(SXElement self) -> bool"""
        return _casadi_core.SXElement_isMinusInf(self, *args)


    def getName(self, *args):
        """getName(SXElement self) -> std::string const &"""
        return _casadi_core.SXElement_getName(self, *args)


    def getOp(self, *args):
        """getOp(SXElement self) -> int"""
        return _casadi_core.SXElement_getOp(self, *args)


    def isOp(self, *args):
        """isOp(SXElement self, int op) -> bool"""
        return _casadi_core.SXElement_isOp(self, *args)


    def isRegular(self, *args):
        """
        isRegular(SXElement self) -> bool



        Checks if expression does not contain NaN or Inf.


        """
        return _casadi_core.SXElement_isRegular(self, *args)


    def isEqual(self, *args):
        """
        isEqual(SXElement self, SXElement scalar, int depth=0) -> bool



        Check if two nodes are equivalent up to a given depth. Depth=0 checks if the
        expressions are identical, i.e. points to the same node.

        a = x*x b = x*x

        a.isEqual(b, 0) will return false, but a.isEqual(b, 1) will return true


        """
        return _casadi_core.SXElement_isEqual(self, *args)


    def isNonNegative(self, *args):
        """
        isNonNegative(SXElement self) -> bool



        Check if a value is always nonnegative (false negatives are allowed)


        """
        return _casadi_core.SXElement_isNonNegative(self, *args)


    def getValue(self, *args):
        """getValue(SXElement self) -> double"""
        return _casadi_core.SXElement_getValue(self, *args)


    def getIntValue(self, *args):
        """getIntValue(SXElement self) -> int"""
        return _casadi_core.SXElement_getIntValue(self, *args)


    def getDep(self, *args):
        """getDep(SXElement self, int ch=0) -> SXElement"""
        return _casadi_core.SXElement_getDep(self, *args)


    def isDoubled(self, *args):
        """
        isDoubled(SXElement self) -> bool



        Check if the node is the sum of two equal expressions.


        """
        return _casadi_core.SXElement_isDoubled(self, *args)


    def getNdeps(self, *args):
        """
        getNdeps(SXElement self) -> int



        Get the number of dependencies of a binary SXElement.


        """
        return _casadi_core.SXElement_getNdeps(self, *args)


    def __hash__(self, *args):
        """
        __hash__(SXElement self) -> long



        Returns a number that is unique for a given SXNode. If the SXElement does
        not point to any node, 0 is returned.


        """
        return _casadi_core.SXElement___hash__(self, *args)


    def __neg__(self, *args):
        """__neg__(SXElement self) -> SXElement"""
        return _casadi_core.SXElement___neg__(self, *args)


    def trans(self, *args):
        """trans(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_trans(self, *args)


    def exp(self, *args):
        """exp(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_exp(self, *args)


    def log(self, *args):
        """log(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_log(self, *args)


    def sqrt(self, *args):
        """sqrt(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_sqrt(self, *args)


    def sq(self, *args):
        """sq(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_sq(self, *args)


    def sin(self, *args):
        """sin(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_sin(self, *args)


    def cos(self, *args):
        """cos(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_cos(self, *args)


    def tan(self, *args):
        """tan(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_tan(self, *args)


    def arcsin(self, *args):
        """arcsin(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arcsin(self, *args)


    def arccos(self, *args):
        """arccos(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arccos(self, *args)


    def arctan(self, *args):
        """arctan(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arctan(self, *args)


    def floor(self, *args):
        """floor(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_floor(self, *args)


    def ceil(self, *args):
        """ceil(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_ceil(self, *args)


    def fmod(self, *args):
        """fmod(SXElement self, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_fmod(self, *args)


    def erf(self, *args):
        """erf(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_erf(self, *args)


    def erfinv(self, *args):
        """erfinv(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_erfinv(self, *args)


    def fabs(self, *args):
        """fabs(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_fabs(self, *args)


    def inv(self, *args):
        """inv(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_inv(self, *args)


    def sinh(self, *args):
        """sinh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_sinh(self, *args)


    def cosh(self, *args):
        """cosh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_cosh(self, *args)


    def tanh(self, *args):
        """tanh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_tanh(self, *args)


    def arcsinh(self, *args):
        """arcsinh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arcsinh(self, *args)


    def arccosh(self, *args):
        """arccosh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arccosh(self, *args)


    def arctanh(self, *args):
        """arctanh(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_arctanh(self, *args)


    def log10(self, *args):
        """log10(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_log10(self, *args)


    def printme(self, *args):
        """printme(SXElement self, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_printme(self, *args)


    def sign(self, *args):
        """sign(SXElement self) -> SXElement"""
        return _casadi_core.SXElement_sign(self, *args)


    def logic_not(self, *args):
        """
        logic_not(SXElement self) -> SXElement


        """
        return _casadi_core.SXElement_logic_not(self, *args)


    def logic_and(self, *args):
        """logic_and(SXElement self, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_logic_and(self, *args)


    def logic_or(self, *args):
        """logic_or(SXElement self, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_logic_or(self, *args)


    def if_else_zero(self, *args):
        """if_else_zero(SXElement self, SXElement y) -> SXElement"""
        return _casadi_core.SXElement_if_else_zero(self, *args)


    def fmin(self, *args):
        """
        fmin(SXElement self, SXElement y) -> SXElement
        fmin(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement_fmin(self, *args)


    def fmax(self, *args):
        """
        fmax(SXElement self, SXElement y) -> SXElement
        fmax(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement_fmax(self, *args)


    def constpow(self, *args):
        """
        constpow(SXElement self, SXElement y) -> SXElement
        constpow(SXElement self, SX n) -> SX
        """
        return _casadi_core.SXElement_constpow(self, *args)


    def arctan2(self, *args):
        """
        arctan2(SXElement self, SXElement y) -> SXElement
        arctan2(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement_arctan2(self, *args)


    def getTemp(self, *args):
        """
        getTemp(SXElement self) -> int

        [INTERNAL]  Get the
        temporary variable


        """
        return _casadi_core.SXElement_getTemp(self, *args)


    def setTemp(self, *args):
        """
        setTemp(SXElement self, int t)

        [INTERNAL]  Set the
        temporary variable.


        """
        return _casadi_core.SXElement_setTemp(self, *args)


    def marked(self, *args):
        """
        marked(SXElement self) -> bool

        [INTERNAL]  Check if
        marked (i.e. temporary is negative)


        """
        return _casadi_core.SXElement_marked(self, *args)


    def mark(self, *args):
        """
        mark(SXElement self)

        [INTERNAL]  Mark by flipping
        the sign of the temporary and decreasing by one.


        """
        return _casadi_core.SXElement_mark(self, *args)


    def assignIfDuplicate(self, *args):
        """
        assignIfDuplicate(SXElement self, SXElement scalar, int depth=1)

        [INTERNAL]
        Assign to another expression, if a duplicate. Check for equality up to a
        given depth.


        """
        return _casadi_core.SXElement_assignIfDuplicate(self, *args)


    def assignNoDelete(self, *args):
        """
        assignNoDelete(SXElement self, SXElement scalar) -> casadi::SXNode *

        [INTERNAL]  Assign
        the node to something, without invoking the deletion of the node, if the
        count reaches 0.


        """
        return _casadi_core.SXElement_assignNoDelete(self, *args)


    def isNull(self, *args):
        """
        isNull(SXElement self) -> bool



        SXElement nodes are not allowed to be null.


        """
        return _casadi_core.SXElement_isNull(self, *args)



    __array_priority__ = 1000.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.toArray()




    def toArray(self):
      import numpy as n
      r = n.array((),dtype=object)
      r.resize(1,1)
      r[0,0] = self
      return r


    def __rfmin__(self, *args):
        """
        __rfmin__(SXElement self, SXElement b) -> SXElement
        __rfmin__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rfmin__(self, *args)


    def __rfmax__(self, *args):
        """
        __rfmax__(SXElement self, SXElement b) -> SXElement
        __rfmax__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rfmax__(self, *args)


    def __constpow__(self, *args):
        """
        __constpow__(SXElement self, SXElement b) -> SXElement
        __constpow__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___constpow__(self, *args)


    def __rconstpow__(self, *args):
        """
        __rconstpow__(SXElement self, SXElement b) -> SXElement
        __rconstpow__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rconstpow__(self, *args)


    def __rarctan2__(self, *args):
        """
        __rarctan2__(SXElement self, SXElement b) -> SXElement
        __rarctan2__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rarctan2__(self, *args)


    def __copysign__(self, *args):
        """
        __copysign__(SXElement self, SXElement y) -> SXElement
        __copysign__(SXElement self, SX n) -> SX
        __copysign__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___copysign__(self, *args)


    def __rcopysign__(self, *args):
        """
        __rcopysign__(SXElement self, SXElement b) -> SXElement
        __rcopysign__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rcopysign__(self, *args)


    def __pow__(self, *args):
        """
        __pow__(SXElement self, SXElement b) -> SXElement
        __pow__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___pow__(self, *args)


    def __rpow__(self, *args):
        """
        __rpow__(SXElement self, SXElement b) -> SXElement
        __rpow__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rpow__(self, *args)


    def __add__(self, *args):
        """
        __add__(SXElement self, SXElement y) -> SXElement
        __add__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___add__(self, *args)


    def __radd__(self, *args):
        """
        __radd__(SXElement self, SXElement b) -> SXElement
        __radd__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___radd__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(SXElement self, SXElement y) -> SXElement
        __sub__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___sub__(self, *args)


    def __rsub__(self, *args):
        """
        __rsub__(SXElement self, SXElement b) -> SXElement
        __rsub__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rsub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(SXElement self, SXElement y) -> SXElement
        __mul__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___mul__(self, *args)


    def __rmul__(self, *args):
        """
        __rmul__(SXElement self, SXElement b) -> SXElement
        __rmul__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rmul__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(SXElement self, SXElement y) -> SXElement
        __ge__(SXElement self, SX b) -> SX



        No need to have both <= and >=.


        """
        return _casadi_core.SXElement___ge__(self, *args)


    def __rge__(self, *args):
        """
        __rge__(SXElement self, SXElement b) -> SXElement
        __rge__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rge__(self, *args)


    def __le__(self, *args):
        """
        __le__(SXElement self, SXElement y) -> SXElement
        __le__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___le__(self, *args)


    def __rle__(self, *args):
        """
        __rle__(SXElement self, SXElement b) -> SXElement
        __rle__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rle__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(SXElement self, SXElement y) -> SXElement
        __gt__(SXElement self, SX b) -> SX



        No need to have both < and >


        """
        return _casadi_core.SXElement___gt__(self, *args)


    def __rgt__(self, *args):
        """
        __rgt__(SXElement self, SXElement b) -> SXElement
        __rgt__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rgt__(self, *args)


    def __lt__(self, *args):
        """
        __lt__(SXElement self, SXElement y) -> SXElement
        __lt__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___lt__(self, *args)


    def __rlt__(self, *args):
        """
        __rlt__(SXElement self, SXElement b) -> SXElement
        __rlt__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rlt__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(SXElement self, SXElement y) -> SXElement
        __eq__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___eq__(self, *args)


    def __req__(self, *args):
        """
        __req__(SXElement self, SXElement b) -> SXElement
        __req__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___req__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(SXElement self, SXElement y) -> SXElement
        __ne__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___ne__(self, *args)


    def __rne__(self, *args):
        """
        __rne__(SXElement self, SXElement b) -> SXElement
        __rne__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rne__(self, *args)


    def mul(self, *args):
        """
        mul(SXElement self, SXElement y) -> SXElement
        mul(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement_mul(self, *args)


    def rmul(self, *args):
        """
        rmul(SXElement self, SXElement b) -> SXElement
        rmul(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement_rmul(self, *args)


    def __div__(self, *args):
        """
        __div__(SXElement self, SXElement y) -> SXElement
        __div__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___div__(self, *args)


    def __rdiv__(self, *args):
        """
        __rdiv__(SXElement self, SXElement b) -> SXElement
        __rdiv__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rdiv__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(SXElement self, SXElement y) -> SXElement
        __truediv__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___truediv__(self, *args)


    def __rtruediv__(self, *args):
        """
        __rtruediv__(SXElement self, SXElement b) -> SXElement
        __rtruediv__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rtruediv__(self, *args)


    def __mldivide__(self, *args):
        """
        __mldivide__(SXElement self, SXElement y) -> SXElement
        __mldivide__(SXElement self, SX b) -> SX



        Matrix division from left.


        """
        return _casadi_core.SXElement___mldivide__(self, *args)


    def __rmldivide__(self, *args):
        """
        __rmldivide__(SXElement self, SXElement b) -> SXElement
        __rmldivide__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rmldivide__(self, *args)


    def __mrdivide__(self, *args):
        """
        __mrdivide__(SXElement self, SXElement b) -> SXElement
        __mrdivide__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___mrdivide__(self, *args)


    def __rmrdivide__(self, *args):
        """
        __rmrdivide__(SXElement self, SXElement b) -> SXElement
        __rmrdivide__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rmrdivide__(self, *args)


    def __mpower__(self, *args):
        """
        __mpower__(SXElement self, SXElement b) -> SXElement
        __mpower__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___mpower__(self, *args)


    def __rmpower__(self, *args):
        """
        __rmpower__(SXElement self, SXElement b) -> SXElement
        __rmpower__(SXElement self, SX b) -> SX
        """
        return _casadi_core.SXElement___rmpower__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::SXElement self) -> SXElement
        __init__(casadi::SXElement self, double val) -> SXElement
        __init__(casadi::SXElement self, SXElement other) -> SXElement



        >  casadi::SXElement::SXElement()
        ------------------------------------------------------------------------

        Default constructor (not-a-number) Object is initialized as not-a-number.

        >  casadi::SXElement::SXElement(double val)
        ------------------------------------------------------------------------

        Numerical constant constructor.

        Parameters:
        -----------

        val:  Numerical value

        >  casadi::SXElement::SXElement(SXNode *node, bool dummy)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Create an expression from a node: extra dummy argument to avoid
        ambiguity for 0/NULL

        >  casadi::SXElement::SXElement(const SXElement &scalar)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Copy constructor.


        """
        this = _casadi_core.new_SXElement(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXElement
SXElement_swigregister = _casadi_core.SXElement_swigregister
SXElement_swigregister(SXElement)

def SXElement_sym(*args):
    """SXElement_sym(std::string const & name) -> SXElement"""
    return _casadi_core.SXElement_sym(*args)

def SXElement_binary(*args):
    """SXElement_binary(int op, SXElement x, SXElement y) -> SXElement"""
    return _casadi_core.SXElement_binary(*args)

def SXElement_unary(*args):
    """SXElement_unary(int op, SXElement x) -> SXElement"""
    return _casadi_core.SXElement_unary(*args)


try:
# This following code attempts to make constpow to work.
# We use numpy's ufunc functionality for that.
#
#   myfunc = numpy.frompyfunc(myfunction,2,1)    creates a ufunc.
#
#   What happens when we do myfunc(x,y)?
#
#     The ufunc will call myfunction(x.__array__(),y.__array__())
#        It is an error if __array__ does not return a numpy.array/numpy.matrix
#        This is problematic since e.g. MX is not expandable in a numpy matrix
#        We let __array__() return a dummy 1x1 numpy.array.
#        Since the arguments to myfunction are dummy, there is no reason to implement myfunction.
#     
#     Great, so we have a ufunctor that takes its arguments, makes dummy values of it
#     and feeds those dummies to a function that does nothing whatsoever with them?
#     Hold on, this is not the end of the story.
#
#     The ufunc functionality has a provision to post-process the result that was made from myfunction.
#       It first checks which of the arguments x, y has the largest __array_priority__.
#       We made it such that casadi types always have the highest priority.
#       From the argument with the largest priority, the __array_wrap__ member is called.
#       The __array__wrap__ method can have a 'context' argument, which gives information about the ufunctor.
#       What we do is check the name of the ufunctor and try to call x.name(y) x.__name__(y) y.__rname__(x)
#       It's the result of this call that is finally returned to the user.
#
#  Why don't you just let __array__() return a 1x1 object numpy.array with the casadi
#  object as its only element, and implement myfunction so that it unwraps from the 1x1
#  and returns a 1x1 wrapped result?
#
#  Good question. The problem is broadcasting.
#  Consider myfunc(array([[4,5],[6,7]]),MX("x",2,2)).
#   Because the y argument is wrapped in a 1x1, numpy will expand it to 2x2 to match the dimensions of argument x.
#   The result will be 4 calls to myfunction: myfunction(4,MX("x,2,2")),  myfunction(4,MX("x,2,2"))
#
#  Why do you use ufunc in the first places? What's wrong with just global functions?       
#
#  Good point. The problem is user-friendliness.
#  We don't want a mere 'from numpy import *' statement to destroy functionality of x**y for example.
#  Come to think of it, this is not really a terrific argument.
#  We might as well have an __array__() that warns the user if he should have overloaded the global functions.
#
#     In fact, we should refactor and forget about this awful mess.

  import numpy
  def constpow(x,y):
    pass

  constpow=numpy.frompyfunc(constpow,2,1)

  def fmin(x,y):
    pass

  def fmax(x,y):
    pass

  _min_ufunc = numpy.frompyfunc(fmin,2,1)
  _max_ufunc = numpy.frompyfunc(fmax,2,1)

  _defaultmin = min
  def min(*args,**kwargs):
    if len(args)==2 and len(kwargs)==0 and (hasattr(args[0],'fmin') or hasattr(args[1],'fmin')):
      return _min_ufunc(*args)
    else:
      return _defaultmin(*args,**kwargs)

  _defaultmax = max
  def max(*args,**kwargs):
    if len(args)==2 and len(kwargs)==0 and (hasattr(args[0],'fmax') or hasattr(args[1],'fmax')):
      return _max_ufunc(*args)
    else:
      return _defaultmax(*args,**kwargs)
except:
  pass

class SX(ExpSX, GenSX, PrintSX):
    """


    Sparse matrix class. SX and DMatrix are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero. Matrix<DataType> is polymorphic with a
    std::vector<DataType> that contain all non- identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [ExpSX, GenSX, PrintSX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SX, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpSX, GenSX, PrintSX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SX, name)
    __repr__ = _swig_repr

    def sanityCheck(self, *args):
        """
        sanityCheck(SX self, bool complete=False)

         [INTERNAL]  Check if
        the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi_core.SX_sanityCheck(self, *args)


    def toScalar(self, *args):
        """
        toScalar(SX self) -> SXElement

        [INTERNAL]  Convert to
        scalar type.


        """
        return _casadi_core.SX_toScalar(self, *args)


    def at(self, *args):
        """
        at(SX self, int k) -> SXElement



        >  const DataType& casadi::Matrix< T >::at(int k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a non-zero element.

        >  DataType& casadi::Matrix< T >::at(int k)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access a non-zero element.


        """
        return _casadi_core.SX_at(self, *args)


    def elem(self, *args):
        """
        elem(SX self, int rr, int cc=0) -> SXElement



        >  const DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get an element

        >  DataType & casadi::Matrix< DataType >::elem(int rr, int cc=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a reference to an element


        """
        return _casadi_core.SX_elem(self, *args)


    def getElement(self, *args):
        """
        getElement(SX self, int rr, int cc=0) -> SXElement



        get an element, do not allocate


        """
        return _casadi_core.SX_getElement(self, *args)


    def hasNZ(self, *args):
        """
        hasNZ(SX self, int rr, int cc) -> bool



        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi_core.SX_hasNZ(self, *args)


    def __nonzero__(self, *args):
        """
        __nonzero__(SX self) -> bool



        >  bool casadi::Matrix< DataType >::__nonzero__() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Returns the truth value of a Matrix.

        >  bool casadi::Matrix< SXElement >::__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.SX___nonzero__(self, *args)


    def sub(self, *args):
        """
        sub(SX self, int rr, int cc) -> SX
        sub(SX self, IVector rr, int cc) -> SX
        sub(SX self, int rr, IVector cc) -> SX
        sub(SX self, IVector rr, IVector cc) -> SX
        sub(SX self, Slice rr, IVector cc) -> SX
        sub(SX self, IVector rr, Slice cc) -> SX
        sub(SX self, Slice rr, Slice cc) -> SX
        sub(SX self, Slice rr, int cc) -> SX
        sub(SX self, int rr, Slice cc) -> SX
        sub(SX self, IMatrix rr, IVector cc) -> SX
        sub(SX self, IMatrix rr, int cc) -> SX
        sub(SX self, IVector rr, IMatrix cc) -> SX
        sub(SX self, int rr, IMatrix cc) -> SX
        sub(SX self, IMatrix rr, Slice cc) -> SX
        sub(SX self, Slice rr, IMatrix cc) -> SX
        sub(SX self, IMatrix rr, IMatrix cc) -> SX
        sub(SX self, Sparsity sp, int dummy=0) -> SX

        [INTERNAL]  Get a submatrix


        """
        return _casadi_core.SX_sub(self, *args)


    def setSub(self, *args):
        """
        setSub(SX self, SX m, int rr, int cc)
        setSub(SX self, SX m, IVector rr, int cc)
        setSub(SX self, SX m, int rr, IVector cc)
        setSub(SX self, SX m, IVector rr, IVector cc)
        setSub(SX self, SX m, Slice rr, IVector cc)
        setSub(SX self, SX m, IVector rr, Slice cc)
        setSub(SX self, SX m, Slice rr, Slice cc)
        setSub(SX self, SX m, IMatrix rr, IVector cc)
        setSub(SX self, SX m, IMatrix rr, int cc)
        setSub(SX self, SX m, IVector rr, IMatrix cc)
        setSub(SX self, SX m, int rr, IMatrix cc)
        setSub(SX self, SX m, IMatrix rr, Slice cc)
        setSub(SX self, SX m, Slice rr, IMatrix cc)
        setSub(SX self, SX m, IMatrix rr, IMatrix cc)
        setSub(SX self, SX m, Slice rr, int cc)
        setSub(SX self, SX m, int const rr, Slice cc)
        setSub(SX self, SX m, Sparsity sp, int dummy)

        [INTERNAL]  Set a submatrix


        """
        return _casadi_core.SX_setSub(self, *args)


    def getNZ(self, *args):
        """
        getNZ(SX self, int k) -> SX
        getNZ(SX self, IVector k) -> SX
        getNZ(SX self, Slice k) -> SX
        getNZ(SX self, IMatrix k) -> SX



        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(int k) const

        >  const Matrix<DataType> casadi::Matrix< T >::getNZ(const Slice &k) const 
        ------------------------------------------------------------------------

        Get a set of nonzeros

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const std::vector< int > &k) const

        >  const Matrix< DataType > casadi::Matrix< DataType >::getNZ(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a set of nonzeros


        """
        return _casadi_core.SX_getNZ(self, *args)


    def setNZ(self, *args):
        """
        setNZ(SX self, int k, SX m)
        setNZ(SX self, IVector k, SX m)
        setNZ(SX self, Slice k, SX m)
        setNZ(SX self, IMatrix k, SX m)



        >  void casadi::Matrix< DataType >::setNZ(int k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const std::vector< int > &k, const Matrix< DataType > &m)

        >  void casadi::Matrix< DataType >::setNZ(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set a set of nonzeros

        >  void casadi::Matrix< T >::setNZ(const Slice &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------

        Set a set of nonzeros


        """
        return _casadi_core.SX_setNZ(self, *args)


    def append(self, *args):
        """
        append(SX self, SX y)

        [INTERNAL]  Append a matrix
        vertically (NOTE: only efficient if vector)


        """
        return _casadi_core.SX_append(self, *args)


    def appendColumns(self, *args):
        """
        appendColumns(SX self, SX y)

        [INTERNAL]  Append a
        matrix horizontally.


        """
        return _casadi_core.SX_appendColumns(self, *args)


    def nz_indexed_one_based(self, *args):
        """
        nz_indexed_one_based(SX self, int k) -> SX
        nz_indexed_one_based(SX self, IMatrix k) -> SX

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.SX_nz_indexed_one_based(self, *args)


    def __NZgetitem__(self, *args):
        """
        __NZgetitem__(SX self, int k) -> SX
        __NZgetitem__(SX self, IMatrix k) -> SX
        __NZgetitem__(SX self, Slice k) -> SX
        __NZgetitem__(SX self, IndexList k) -> SX

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.SX___NZgetitem__(self, *args)


    def indexed_one_based(self, *args):
        """
        indexed_one_based(SX self, IMatrix k) -> SX
        indexed_one_based(SX self, int rr, int cc) -> SX
        indexed_one_based(SX self, int rr) -> SX



        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(const Matrix< int > &k) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr, int cc) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        get a matrix element

        >  const Matrix<DataType> casadi::Matrix< T >::indexed_one_based(int rr) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a vector element.


        """
        return _casadi_core.SX_indexed_one_based(self, *args)


    def __Cgetitem__(self, *args):
        """
        __Cgetitem__(SX self, IMatrix k) -> SX
        __Cgetitem__(SX self, int rr, int cc) -> SX
        __Cgetitem__(SX self, Slice rr, Slice cc) -> SX
        __Cgetitem__(SX self, IndexList rr, IndexList cc) -> SX
        __Cgetitem__(SX self, Slice rr, IMatrix cc) -> SX
        __Cgetitem__(SX self, IMatrix rr, IndexList cc) -> SX
        __Cgetitem__(SX self, IMatrix rr, Slice cc) -> SX
        __Cgetitem__(SX self, IndexList rr, IMatrix cc) -> SX
        __Cgetitem__(SX self, IMatrix rr, IMatrix cc) -> SX
        __Cgetitem__(SX self, Sparsity sp) -> SX
        __Cgetitem__(SX self, int rr) -> SX
        __Cgetitem__(SX self, Slice rr) -> SX
        __Cgetitem__(SX self, IndexList rr) -> SX

        [INTERNAL]  Indexing for
        interfaced languages get a non-zero


        """
        return _casadi_core.SX___Cgetitem__(self, *args)


    def nz_indexed_one_based_assignment(self, *args):
        """
        nz_indexed_one_based_assignment(SX self, int k, SXElement m)
        nz_indexed_one_based_assignment(SX self, IMatrix k, SX m)



        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(int k, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a non-zero

        >  void casadi::Matrix< T >::nz_indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.SX_nz_indexed_one_based_assignment(self, *args)


    def __NZsetitem__(self, *args):
        """
        __NZsetitem__(SX self, int k, SXElement m)
        __NZsetitem__(SX self, Slice k, SX m)
        __NZsetitem__(SX self, IMatrix k, SX m)
        __NZsetitem__(SX self, IndexList k, SX m)

        [INTERNAL]
        Indexing for interfaced languages get a non-zero


        """
        return _casadi_core.SX___NZsetitem__(self, *args)


    def indexed_one_based_assignment(self, *args):
        """
        indexed_one_based_assignment(SX self, IMatrix k, SX m)
        indexed_one_based_assignment(SX self, int rr, int cc, SXElement m)
        indexed_one_based_assignment(SX self, int rr, SXElement m)



        >  void casadi::Matrix< T >::indexed_one_based_assignment(const Matrix< int > &k, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, int cc, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a matrix element

        >  void casadi::Matrix< T >::indexed_one_based_assignment(int rr, const DataType &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        set a vector element


        """
        return _casadi_core.SX_indexed_one_based_assignment(self, *args)


    def __Csetitem__(self, *args):
        """
        __Csetitem__(SX self, IMatrix k, SX m)
        __Csetitem__(SX self, int rr, int cc, SXElement m)
        __Csetitem__(SX self, Slice rr, Slice cc, SX m)
        __Csetitem__(SX self, IndexList rr, IndexList cc, SX m)
        __Csetitem__(SX self, Slice rr, IMatrix cc, SX m)
        __Csetitem__(SX self, IMatrix rr, Slice cc, SX m)
        __Csetitem__(SX self, IMatrix rr, IndexList cc, SX m)
        __Csetitem__(SX self, IndexList rr, IMatrix cc, SX m)
        __Csetitem__(SX self, IMatrix rr, IMatrix cc, SX m)
        __Csetitem__(SX self, Sparsity sp, SX m)
        __Csetitem__(SX self, int rr, SXElement m)
        __Csetitem__(SX self, Slice rr, SX m)
        __Csetitem__(SX self, IndexList rr, SX m)



        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Slice &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const IndexList &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Matrix< int > &rr, const Matrix< int > &cc, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const Sparsity &sp, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Indexing for interfaced languages get a non-zero

        >  void casadi::Matrix< T >::indexed_assignment(const Slice &rr, const Matrix< DataType > &m)

        >  void casadi::Matrix< T >::indexed_assignment(const IndexList &rr, const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.SX___Csetitem__(self, *args)


    def setZero(self, *args):
        """
        setZero(SX self)

        [INTERNAL]  Set all elements
        to zero.


        """
        return _casadi_core.SX_setZero(self, *args)


    def setAll(self, *args):
        """
        setAll(SX self, SXElement val)

        [INTERNAL]  Set all elements
        to a value.


        """
        return _casadi_core.SX_setAll(self, *args)


    def setSparse(self, *args):
        """
        setSparse(SX self, Sparsity sp, bool intersect=False) -> SX

        [INTERNAL]  Set sparse.


        """
        return _casadi_core.SX_setSparse(self, *args)


    def densify(self, *args):
        """
        densify(SX self, SXElement val=0)

        [INTERNAL]  Make the matrix
        dense.


        """
        return _casadi_core.SX_densify(self, *args)


    def sparsify(self, *args):
        """
        sparsify(SX self, double tol=0)

        [INTERNAL]  Make a matrix
        sparse by removing numerical zeros smaller in absolute value than a
        specified tolerance.


        """
        return _casadi_core.SX_sparsify(self, *args)


    def __pos__(self, *args):
        """__pos__(SX self) -> SX"""
        return _casadi_core.SX___pos__(self, *args)


    def __neg__(self, *args):
        """__neg__(SX self) -> SX"""
        return _casadi_core.SX___neg__(self, *args)


    def binary(*args):
        """
        binary(int op, SX x, SX y) -> SX

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.SX_binary(*args)

    if _newclass:
        binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary

    def unary(*args):
        """
        unary(int op, SX x) -> SX

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi_core.SX_unary(*args)

    if _newclass:
        unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary

    def scalar_matrix(*args):
        """
        scalar_matrix(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.SX_scalar_matrix(*args)

    if _newclass:
        scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix

    def matrix_scalar(*args):
        """
        matrix_scalar(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.SX_matrix_scalar(*args)

    if _newclass:
        matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar

    def matrix_matrix(*args):
        """
        matrix_matrix(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi_core.SX_matrix_matrix(*args)

    if _newclass:
        matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix

    def __add__(self, *args):
        """
        __add__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___add__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___sub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___mul__(self, *args)


    def __div__(self, *args):
        """
        __div__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___div__(self, *args)


    def __lt__(self, *args):
        """
        __lt__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___lt__(self, *args)


    def __le__(self, *args):
        """
        __le__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___le__(self, *args)


    def __gt__(self, *args):
        """
        __gt__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___gt__(self, *args)


    def __ge__(self, *args):
        """
        __ge__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___ge__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___ne__(self, *args)


    def __truediv__(self, *args):
        """
        __truediv__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___truediv__(self, *args)


    def __pow__(self, *args):
        """
        __pow__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___pow__(self, *args)


    def __constpow__(self, *args):
        """
        __constpow__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___constpow__(self, *args)


    def __mpower__(self, *args):
        """
        __mpower__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___mpower__(self, *args)


    def __mrdivide__(self, *args):
        """
        __mrdivide__(SX self, SX y) -> SX

        [INTERNAL]  Elementwise
        operations Octave/Python naming


        """
        return _casadi_core.SX___mrdivide__(self, *args)


    def mul_full(self, *args):
        """
        mul_full(SX self, SX y, Sparsity sp_z) -> SX

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.SX_mul_full(self, *args)


    def mul(self, *args):
        """
        mul(SX self, SX y, Sparsity sp_z) -> SX

        [INTERNAL]  Matrix-matrix
        product.


        """
        return _casadi_core.SX_mul(self, *args)


    def mul_no_alloc_nt(*args):
        """mul_no_alloc_nt(SX x, SX trans_y, SX z)"""
        return _casadi_core.SX_mul_no_alloc_nt(*args)

    if _newclass:
        mul_no_alloc_nt = staticmethod(mul_no_alloc_nt)
    __swig_getmethods__["mul_no_alloc_nt"] = lambda x: mul_no_alloc_nt

    def mul_no_alloc_tn(*args):
        """
        mul_no_alloc_tn(SX trans_x, SX y, SX z)
        mul_no_alloc_tn(SX trans_x, SXElementVector y, SXElementVector z)
        """
        return _casadi_core.SX_mul_no_alloc_tn(*args)

    if _newclass:
        mul_no_alloc_tn = staticmethod(mul_no_alloc_tn)
    __swig_getmethods__["mul_no_alloc_tn"] = lambda x: mul_no_alloc_tn

    def mul_no_alloc_nn(*args):
        """
        mul_no_alloc_nn(SX x, SX y, SX z)
        mul_no_alloc_nn(SX x, SX y, SX z, SXElementVector work)
        mul_no_alloc_nn(SX x, SXElementVector y, SXElementVector z)
        """
        return _casadi_core.SX_mul_no_alloc_nn(*args)

    if _newclass:
        mul_no_alloc_nn = staticmethod(mul_no_alloc_nn)
    __swig_getmethods__["mul_no_alloc_nn"] = lambda x: mul_no_alloc_nn

    def quad_form(*args):
        """quad_form(SXElementVector x, SX A) -> SXElement"""
        return _casadi_core.SX_quad_form(*args)

    if _newclass:
        quad_form = staticmethod(quad_form)
    __swig_getmethods__["quad_form"] = lambda x: quad_form

    def trans(self, *args):
        """
        trans(SX self) -> SX

        [INTERNAL]   Transpose the
        matrix.


        """
        return _casadi_core.SX_trans(self, *args)


    def sin(self, *args):
        """
        sin(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_sin(self, *args)


    def cos(self, *args):
        """
        cos(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_cos(self, *args)


    def tan(self, *args):
        """
        tan(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_tan(self, *args)


    def arcsin(self, *args):
        """
        arcsin(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arcsin(self, *args)


    def arccos(self, *args):
        """
        arccos(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arccos(self, *args)


    def arctan(self, *args):
        """
        arctan(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arctan(self, *args)


    def exp(self, *args):
        """
        exp(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_exp(self, *args)


    def log(self, *args):
        """
        log(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_log(self, *args)


    def sqrt(self, *args):
        """
        sqrt(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_sqrt(self, *args)


    def floor(self, *args):
        """
        floor(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_floor(self, *args)


    def ceil(self, *args):
        """
        ceil(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_ceil(self, *args)


    def fmod(self, *args):
        """
        fmod(SX self, SX y) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_fmod(self, *args)


    def fabs(self, *args):
        """
        fabs(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_fabs(self, *args)


    def sign(self, *args):
        """
        sign(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_sign(self, *args)


    def __copysign__(self, *args):
        """
        __copysign__(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX___copysign__(self, *args)


    def erfinv(self, *args):
        """
        erfinv(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_erfinv(self, *args)


    def fmin(self, *args):
        """
        fmin(SX self, SX y) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_fmin(self, *args)


    def fmax(self, *args):
        """
        fmax(SX self, SX y) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_fmax(self, *args)


    def erf(self, *args):
        """
        erf(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_erf(self, *args)


    def sinh(self, *args):
        """
        sinh(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_sinh(self, *args)


    def cosh(self, *args):
        """
        cosh(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_cosh(self, *args)


    def tanh(self, *args):
        """
        tanh(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_tanh(self, *args)


    def arcsinh(self, *args):
        """
        arcsinh(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arcsinh(self, *args)


    def arccosh(self, *args):
        """
        arccosh(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arccosh(self, *args)


    def arctanh(self, *args):
        """
        arctanh(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arctanh(self, *args)


    def arctan2(self, *args):
        """
        arctan2(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_arctan2(self, *args)


    def log10(self, *args):
        """
        log10(SX self) -> SX

        [INTERNAL]  Operations defined
        in the standard namespace for unambiguous access and Numpy compatibility


        """
        return _casadi_core.SX_log10(self, *args)


    def printme(self, *args):
        """
        printme(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_printme(self, *args)


    def logic_not(self, *args):
        """
        logic_not(SX self) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_logic_not(self, *args)


    def logic_and(self, *args):
        """
        logic_and(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_logic_and(self, *args)


    def logic_or(self, *args):
        """
        logic_or(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_logic_or(self, *args)


    def if_else_zero(self, *args):
        """
        if_else_zero(SX self, SX y) -> SX

        [INTERNAL]  Operations
        defined in the standard namespace for unambiguous access and Numpy
        compatibility


        """
        return _casadi_core.SX_if_else_zero(self, *args)


    def setMaxNumCallsInPrint(*args):
        """setMaxNumCallsInPrint(long num=10000)"""
        return _casadi_core.SX_setMaxNumCallsInPrint(*args)

    if _newclass:
        setMaxNumCallsInPrint = staticmethod(setMaxNumCallsInPrint)
    __swig_getmethods__["setMaxNumCallsInPrint"] = lambda x: setMaxNumCallsInPrint

    def getMaxNumCallsInPrint(*args):
        """getMaxNumCallsInPrint() -> long"""
        return _casadi_core.SX_getMaxNumCallsInPrint(*args)

    if _newclass:
        getMaxNumCallsInPrint = staticmethod(getMaxNumCallsInPrint)
    __swig_getmethods__["getMaxNumCallsInPrint"] = lambda x: getMaxNumCallsInPrint

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi_core.SX_setEqualityCheckingDepth(*args)

    if _newclass:
        setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth

    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi_core.SX_getEqualityCheckingDepth(*args)

    if _newclass:
        getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth

    def className(*args):
        """className() -> std::string"""
        return _casadi_core.SX_className(*args)

    if _newclass:
        className = staticmethod(className)
    __swig_getmethods__["className"] = lambda x: className

    def printScalar(self, *args):
        """
        printScalar(SX self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        scalar.


        """
        return _casadi_core.SX_printScalar(self, *args)


    def printVector(self, *args):
        """
        printVector(SX self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print
        vector-style.


        """
        return _casadi_core.SX_printVector(self, *args)


    def printDense(self, *args):
        """
        printDense(SX self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print dense
        matrix-stype.


        """
        return _casadi_core.SX_printDense(self, *args)


    def printSparse(self, *args):
        """
        printSparse(SX self, std::ostream & stream, bool trailing_newline=True)

        [INTERNAL]  Print sparse
        matrix style.


        """
        return _casadi_core.SX_printSparse(self, *args)


    def row(self, *args):
        """
        row(SX self) -> IVector
        row(SX self, int el) -> int

        [INTERNAL] 
        """
        return _casadi_core.SX_row(self, *args)


    def colind(self, *args):
        """
        colind(SX self) -> IVector
        colind(SX self, int col) -> int

        [INTERNAL] 
        """
        return _casadi_core.SX_colind(self, *args)


    def clear(self, *args):
        """
        clear(SX self)

        [INTERNAL] 
        """
        return _casadi_core.SX_clear(self, *args)


    def resize(self, *args):
        """
        resize(SX self, int nrow, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.SX_resize(self, *args)


    def reserve(self, *args):
        """
        reserve(SX self, int nnz)
        reserve(SX self, int nnz, int ncol)

        [INTERNAL] 
        """
        return _casadi_core.SX_reserve(self, *args)


    def erase(self, *args):
        """
        erase(SX self, IVector rr, IVector cc)

        [INTERNAL]  Erase a submatrix
        Erase rows and/or columns of a matrix.


        """
        return _casadi_core.SX_erase(self, *args)


    def remove(self, *args):
        """
        remove(SX self, IVector rr, IVector cc)

        [INTERNAL]  Remove cols or
        rows Rremove/delete rows and/or columns of a matrix.


        """
        return _casadi_core.SX_remove(self, *args)


    def enlarge(self, *args):
        """
        enlarge(SX self, int nrow, int ncol, IVector rr, IVector cc)

        [INTERNAL]  Enlarge matrix
        Make the matrix larger by inserting empty rows and columns, keeping the
        existing non-zeros.


        """
        return _casadi_core.SX_enlarge(self, *args)


    def data(self, *args):
        """
        data(SX self) -> SXElementVector
        data(SX self) -> SXElementVector



        >  std::vector< DataType > & casadi::Matrix< DataType >::data()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Access the non-zero elements.

        >  const std::vector< DataType > & casadi::Matrix< DataType >::data() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Const access the non-zero elements.


        """
        return _casadi_core.SX_data(self, *args)


    def ptr(self, *args):
        """
        ptr(SX self) -> SXElement
        ptr(SX self) -> SXElement



        >  DataType* casadi::Matrix< T >::ptr()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a pointer to the data

        >  const DataType* casadi::Matrix< T >::ptr() const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get a const pointer to the data.


        """
        return _casadi_core.SX_ptr(self, *args)


    def sparsity(self, *args):
        """
        sparsity(SX self) -> Sparsity



        Const access the sparsity - reference to data member.


        """
        return _casadi_core.SX_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(SX self) -> Sparsity

        [INTERNAL]  Access the
        sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.SX_sparsityRef(self, *args)


    def getArray(self, *args):
        """
        getArray(SX self, SXElement val, int len, casadi::SparsityType sp)
        getArray(SX self, SXElement val)



        >  void casadi::Matrix< DataType >::getArray(DataType *val, int len, SparsityType sp=SPARSE) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array.

        >  void casadi::Matrix< DataType >::getArray(DataType *val) const 
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.SX_getArray(self, *args)


    def set(self, *args):
        """
        set(SX self, SXElement val, casadi::SparsityType sp)
        set(SX self, SXElementVector val, casadi::SparsityType sp)
        set(SX self, SX val, casadi::SparsityType sp)
        set(SX self, SXElement val, int len, casadi::SparsityType sp)
        set(SX self, SXElement val)



        >  void casadi::Matrix< DataType >::setArray(const DataType *val, int len, SparsityType sp=SPARSE)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array.

        >  void casadi::Matrix< DataType >::setArray(const DataType *val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Set the non-zero elements, array, sparse and correct length.


        """
        return _casadi_core.SX_set(self, *args)


    def get(self, *args):
        """
        get(SX self, SXElement val, casadi::SparsityType sp)
        get(SX self, SXElementVector val, casadi::SparsityType sp)
        get(SX self, SX val, casadi::SparsityType sp)
        get(SX self, SXElement val, int len, int stride1, int stride2, casadi::SparsityType sp)

        [INTERNAL]  Get the
        non-zero elements, strided array.

        Set stride to zero for unstrided acces


        """
        return _casadi_core.SX_get(self, *args)


    def getBand(self, *args):
        """
        getBand(SX self, int kl, int ku, int ldres, SXElement res)

        [INTERNAL]  Save the result
        to the LAPACK banded format see LAPACK documentation kl: The number of
        subdiagonals in res ku: The number of superdiagonals in res ldres: The
        leading dimension in res res: The number of superdiagonals.


        """
        return _casadi_core.SX_getBand(self, *args)


    def triplet(*args):
        """
        triplet(IVector row, IVector col, SXElementVector d) -> SX
        triplet(IVector row, IVector col, SXElementVector d, int nrow, int ncol) -> SX
        triplet(IVector row, IVector col, SXElementVector d, Pair_Int_Int rc) -> SX

        [INTERNAL] 
        """
        return _casadi_core.SX_triplet(*args)

    if _newclass:
        triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet

    def inf(*args):
        """
        inf(Sparsity sp) -> SX
        inf(int nrow=1, int ncol=1) -> SX
        inf(Pair_Int_Int rc) -> SX

        [INTERNAL]  create a matrix with
        all inf


        """
        return _casadi_core.SX_inf(*args)

    if _newclass:
        inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf

    def nan(*args):
        """
        nan(Sparsity sp) -> SX
        nan(int nrow=1, int ncol=1) -> SX
        nan(Pair_Int_Int rc) -> SX

        [INTERNAL]  create a matrix with
        all nan


        """
        return _casadi_core.SX_nan(*args)

    if _newclass:
        nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan

    def repmat(*args):
        """
        repmat(SXElement x, Sparsity sp) -> SX
        repmat(SX x, Sparsity sp) -> SX
        repmat(SX x, int nrow, int ncol=1) -> SX
        repmat(SX x, Pair_Int_Int rc) -> SX

        [INTERNAL]  create a matrix
        by repeating an existing matrix


        """
        return _casadi_core.SX_repmat(*args)

    if _newclass:
        repmat = staticmethod(repmat)
    __swig_getmethods__["repmat"] = lambda x: repmat

    def eye(*args):
        """eye(int ncol) -> SX"""
        return _casadi_core.SX_eye(*args)

    if _newclass:
        eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye

    def isRegular(self, *args):
        """
        isRegular(SX self) -> bool

        [INTERNAL]  Checks if
        expression does not contain NaN or Inf.


        """
        return _casadi_core.SX_isRegular(self, *args)


    def isSmooth(self, *args):
        """
        isSmooth(SX self) -> bool

        [INTERNAL]  Check if
        smooth.


        """
        return _casadi_core.SX_isSmooth(self, *args)


    def isSymbolic(self, *args):
        """
        isSymbolic(SX self) -> bool

        [INTERNAL]  Check if
        symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi_core.SX_isSymbolic(self, *args)


    def isSymbolicSparse(self, *args):
        """
        isSymbolicSparse(SX self) -> bool

        [INTERNAL]  Check
        if symbolic Sparse matrices can return true if all non-zero elements are
        symbolic.


        """
        return _casadi_core.SX_isSymbolicSparse(self, *args)


    def isConstant(self, *args):
        """
        isConstant(SX self) -> bool

        [INTERNAL]  Check if the
        matrix is constant (note that false negative answers are possible)


        """
        return _casadi_core.SX_isConstant(self, *args)


    def isInteger(self, *args):
        """
        isInteger(SX self) -> bool

        [INTERNAL]  Check if the
        matrix is integer-valued (note that false negative answers are possible)


        """
        return _casadi_core.SX_isInteger(self, *args)


    def isZero(self, *args):
        """
        isZero(SX self) -> bool

        [INTERNAL]  check if the
        matrix is 0 (note that false negative answers are possible)


        """
        return _casadi_core.SX_isZero(self, *args)


    def isOne(self, *args):
        """
        isOne(SX self) -> bool

        [INTERNAL]  check if the
        matrix is 1 (note that false negative answers are possible)


        """
        return _casadi_core.SX_isOne(self, *args)


    def isMinusOne(self, *args):
        """
        isMinusOne(SX self) -> bool

        [INTERNAL]  check if the
        matrix is -1 (note that false negative answers are possible)


        """
        return _casadi_core.SX_isMinusOne(self, *args)


    def isIdentity(self, *args):
        """
        isIdentity(SX self) -> bool

        [INTERNAL]  check if the
        matrix is an identity matrix (note that false negative answers are possible)


        """
        return _casadi_core.SX_isIdentity(self, *args)


    def isEqual(self, *args):
        """
        isEqual(SX self, SX ex2) -> bool

        [INTERNAL]  Check if two
        expressions are equal May give false negatives.

        Note: does not work when CasadiOptions.setSimplificationOnTheFly(False) was
        called


        """
        return _casadi_core.SX_isEqual(self, *args)


    def hasNonStructuralZeros(self, *args):
        """
        hasNonStructuralZeros(SX self) -> bool

        [INTERNAL]
        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi_core.SX_hasNonStructuralZeros(self, *args)


    def getValue(self, *args):
        """
        getValue(SX self) -> double

        [INTERNAL]  Get double
        value (only if constant)


        """
        return _casadi_core.SX_getValue(self, *args)


    def getName(self, *args):
        """
        getName(SX self) -> std::string

        [INTERNAL]  Get name (only
        if symbolic scalar)


        """
        return _casadi_core.SX_getName(self, *args)


    def setPrecision(*args):
        """
        setPrecision(int precision)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.SX_setPrecision(*args)

    if _newclass:
        setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision

    def setWidth(*args):
        """
        setWidth(int width)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.SX_setWidth(*args)

    if _newclass:
        setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth

    def setScientific(*args):
        """
        setScientific(bool scientific)



        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi_core.SX_setScientific(*args)

    if _newclass:
        setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific

    def __del__(self):
      if not(_casadi_core is None):
         _casadi_core.PyDECREFParent(self)




    def toMatrix(self):
        import numpy as n
        return n.matrix(self.toArray())

    def __iter__(self):
      for k in self.nz:
        yield k



    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi_core.reshape(self,arg)

    @property
    def T(self):
        return _casadi_core.transpose(self)

    def __getitem__(self,s):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Cgetitem__(s[0],s[1])  
        return self.__Cgetitem__(s)

    def __setitem__(self,s,val):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Csetitem__(s[0],s[1],val)  
        return self.__Csetitem__(s,val)

    @property
    def nz(self):
      return NZproxy(self)

    def prod(self,*args):
        raise Exception("'prod' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")



    def toArray(self):
      import numpy as n
      r = n.array((),dtype=object)
      r.resize(self.size1(),self.size2())
      for j in range(self.size2()):  # loop over columns
        for el in range(self.colind(j),self.colind(j+1)): # loop over the non-zero elements
          i=self.row(el)  # column
          r[i,j] = self.at(el) # add the non-zero element

      return r



    __array_priority__ = 1001.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.toArray()



    def __rpow__(self, *args):
        """__rpow__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rpow__(self, *args)


    def __radd__(self, *args):
        """__radd__(SX self, SX b) -> SX"""
        return _casadi_core.SX___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rdiv__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rtruediv__(self, *args)


    def __rmldivide__(self, *args):
        """__rmldivide__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rmldivide__(self, *args)


    def __rmrdivide__(self, *args):
        """__rmrdivide__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rmrdivide__(self, *args)


    def __rmpower__(self, *args):
        """__rmpower__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rmpower__(self, *args)


    def __rconstpow__(self, *args):
        """__rconstpow__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rconstpow__(self, *args)


    def __rge__(self, *args):
        """__rge__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rge__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rgt__(self, *args)


    def __rle__(self, *args):
        """__rle__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rle__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rlt__(self, *args)


    def __req__(self, *args):
        """__req__(SX self, SX b) -> SX"""
        return _casadi_core.SX___req__(self, *args)


    def __rne__(self, *args):
        """__rne__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rne__(self, *args)


    def __rfmin__(self, *args):
        """__rfmin__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rfmin__(self, *args)


    def __rfmax__(self, *args):
        """__rfmax__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rfmax__(self, *args)


    def rmul(self, *args):
        """rmul(SX self, SX b) -> SX"""
        return _casadi_core.SX_rmul(self, *args)


    def __rarctan2__(self, *args):
        """__rarctan2__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rarctan2__(self, *args)


    def __rcopysign__(self, *args):
        """__rcopysign__(SX self, SX b) -> SX"""
        return _casadi_core.SX___rcopysign__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::Matrix<(casadi::SXElement)> self) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, SX m) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, SXElementVectorVector m) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, Sparsity sparsity, SXElement val) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, Sparsity sparsity, SXElementVector d) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, double val) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, SXElementVector x) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, SXElementVector x, int nrow, int ncol) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, IMatrix x) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, IVector x) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, IVector x, int nrow, int ncol) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, DMatrix x) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, DVector x) -> SX
        __init__(casadi::Matrix<(casadi::SXElement)> self, DVector x, int nrow, int ncol) -> SX



        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const DataType &val=DataType(0))
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity

        >  casadi::Matrix< DataType >::Matrix()
        ------------------------------------------------------------------------
        [INTERNAL] 
        constructors

        empty 0-by-0 matrix constructor

        >  casadi::Matrix< DataType >::Matrix(const Matrix< DataType > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Copy constructor.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< std::vector< DataType > > &m)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Dense matrix constructor with data given as vector of vectors.

        >  casadi::Matrix< DataType >::Matrix(const Sparsity &sparsity, const std::vector< DataType > &d)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Sparse matrix with a given sparsity and non-zero elements.

        >  casadi::Matrix< DataType >::Matrix(double val)
        ------------------------------------------------------------------------
        [INTERNAL] 
        This constructor enables implicit type conversion from a numeric type.

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct from a vector.

        Thanks to implicit conversion, you can pretend that Matrix(const SXElement&
        x); exists. Note: above remark applies only to C++, not python or octave
        interfaces

        >  casadi::Matrix< DataType >::Matrix(const std::vector< DataType > &x, int nrow, int ncol)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct dense matrix from a vector with the elements in column major
        ordering.

        >  casadi::Matrix< T >::Matrix(const Matrix< A > &x)
        ------------------------------------------------------------------------

        Create a matrix from a matrix with a different type of matrix entries
        (assuming that the scalar conversion is valid)

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x)
        ------------------------------------------------------------------------

        Create an expression from an stl vector.

        >  casadi::Matrix< T >::Matrix(const std::vector< A > &x, int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a non-vector expression from an stl vector.


        """
        this = _casadi_core.new_SX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SX
SX_swigregister = _casadi_core.SX_swigregister
SX_swigregister(SX)

def SX_binary(*args):
    """
    SX_binary(int op, SX x, SX y) -> SX

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.SX_binary(*args)

def SX_unary(*args):
    """
    SX_unary(int op, SX x) -> SX

    [INTERNAL]  Create nodes by
    their ID.


    """
    return _casadi_core.SX_unary(*args)

def SX_scalar_matrix(*args):
    """
    SX_scalar_matrix(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.SX_scalar_matrix(*args)

def SX_matrix_scalar(*args):
    """
    SX_matrix_scalar(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.SX_matrix_scalar(*args)

def SX_matrix_matrix(*args):
    """
    SX_matrix_matrix(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
    return _casadi_core.SX_matrix_matrix(*args)

def SX_mul_no_alloc_nt(*args):
    """SX_mul_no_alloc_nt(SX x, SX trans_y, SX z)"""
    return _casadi_core.SX_mul_no_alloc_nt(*args)

def SX_mul_no_alloc_tn(*args):
    """
    mul_no_alloc_tn(SX trans_x, SX y, SX z)
    SX_mul_no_alloc_tn(SX trans_x, SXElementVector y, SXElementVector z)
    """
    return _casadi_core.SX_mul_no_alloc_tn(*args)

def SX_mul_no_alloc_nn(*args):
    """
    mul_no_alloc_nn(SX x, SX y, SX z)
    mul_no_alloc_nn(SX x, SX y, SX z, SXElementVector work)
    SX_mul_no_alloc_nn(SX x, SXElementVector y, SXElementVector z)
    """
    return _casadi_core.SX_mul_no_alloc_nn(*args)

def SX_quad_form(*args):
    """SX_quad_form(SXElementVector x, SX A) -> SXElement"""
    return _casadi_core.SX_quad_form(*args)

def SX_setMaxNumCallsInPrint(*args):
    """SX_setMaxNumCallsInPrint(long num=10000)"""
    return _casadi_core.SX_setMaxNumCallsInPrint(*args)

def SX_getMaxNumCallsInPrint(*args):
    """SX_getMaxNumCallsInPrint() -> long"""
    return _casadi_core.SX_getMaxNumCallsInPrint(*args)

def SX_setEqualityCheckingDepth(*args):
    """SX_setEqualityCheckingDepth(int eq_depth=1)"""
    return _casadi_core.SX_setEqualityCheckingDepth(*args)

def SX_getEqualityCheckingDepth(*args):
    """SX_getEqualityCheckingDepth() -> int"""
    return _casadi_core.SX_getEqualityCheckingDepth(*args)

def SX_className(*args):
    """SX_className() -> std::string"""
    return _casadi_core.SX_className(*args)

def SX_triplet(*args):
    """
    triplet(IVector row, IVector col, SXElementVector d) -> SX
    triplet(IVector row, IVector col, SXElementVector d, int nrow, int ncol) -> SX
    SX_triplet(IVector row, IVector col, SXElementVector d, Pair_Int_Int rc) -> SX

    [INTERNAL] 
    """
    return _casadi_core.SX_triplet(*args)

def SX_inf(*args):
    """
    inf(Sparsity sp) -> SX
    inf(int nrow=1, int ncol=1) -> SX
    SX_inf(Pair_Int_Int rc) -> SX

    [INTERNAL]  create a matrix with
    all inf


    """
    return _casadi_core.SX_inf(*args)

def SX_nan(*args):
    """
    nan(Sparsity sp) -> SX
    nan(int nrow=1, int ncol=1) -> SX
    SX_nan(Pair_Int_Int rc) -> SX

    [INTERNAL]  create a matrix with
    all nan


    """
    return _casadi_core.SX_nan(*args)

def SX_repmat(*args):
    """
    repmat(SXElement x, Sparsity sp) -> SX
    repmat(SX x, Sparsity sp) -> SX
    repmat(SX x, int nrow, int ncol=1) -> SX
    SX_repmat(SX x, Pair_Int_Int rc) -> SX

    [INTERNAL]  create a matrix
    by repeating an existing matrix


    """
    return _casadi_core.SX_repmat(*args)

def SX_eye(*args):
    """SX_eye(int ncol) -> SX"""
    return _casadi_core.SX_eye(*args)

def SX_setPrecision(*args):
    """
    SX_setPrecision(int precision)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.SX_setPrecision(*args)

def SX_setWidth(*args):
    """
    SX_setWidth(int width)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.SX_setWidth(*args)

def SX_setScientific(*args):
    """
    SX_setScientific(bool scientific)



    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
    return _casadi_core.SX_setScientific(*args)

class MX(ExpMX, GenMX, SharedObject):
    """


    MX - Matrix expression.

    The MX class is used to build up trees made up from MXNodes. It is a more
    general graph representation than the scalar expression, SX, and much less
    efficient for small objects. On the other hand, the class allows much more
    general operations than does SX, in particular matrix valued operations and
    calls to arbitrary differentiable functions.

    The MX class is designed to have identical syntax with the Matrix<> template
    class, and uses Matrix<double> as its internal representation of the values
    at a node. By keeping the syntaxes identical, it is possible to switch from
    one class to the other, as well as inlining MX functions to SXElement
    functions.

    Note that an operation is always "lazy", making a matrix multiplication
    will create a matrix multiplication node, not perform the actual
    multiplication.

    Joel Andersson

    C++ includes: mx.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [ExpMX, GenMX, SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MX, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpMX, GenMX, SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MX, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::MX self) -> MX
        __init__(casadi::MX self, Sparsity sp, int val=0) -> MX
        __init__(casadi::MX self, Sparsity sp, double val) -> MX
        __init__(casadi::MX self, Sparsity sp, MX val) -> MX
        __init__(casadi::MX self, double x) -> MX
        __init__(casadi::MX self, MX x) -> MX
        __init__(casadi::MX self, DVector x) -> MX
        __init__(casadi::MX self, DMatrix x) -> MX



        >  casadi::MX::MX(const Sparsity &sp, int val=0)

        >  casadi::MX::MX(const Sparsity &sp, double val)

        >  casadi::MX::MX(const Sparsity &sp, const MX &val)
        ------------------------------------------------------------------------

        Construct constant matrix with a given sparsity.

        >  casadi::MX::MX()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::MX::MX(double x)
        ------------------------------------------------------------------------

        Create scalar constant (also implicit type conversion)

        >  casadi::MX::MX(const MX &x)
        ------------------------------------------------------------------------

        Copy constructor.

        >  casadi::MX::MX(const std::vector< double > &x)
        ------------------------------------------------------------------------

        Create vector constant (also implicit type conversion)

        >  casadi::MX::MX(const Matrix< double > &x)
        ------------------------------------------------------------------------

        Create sparse matrix constant (also implicit type conversion)


        """
        this = _casadi_core.new_MX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MX

    def __nonzero__(self, *args):
        """
        __nonzero__(MX self) -> bool



        Returns the truth value of an MX expression.


        """
        return _casadi_core.MX___nonzero__(self, *args)


    def nz_indexed_one_based(self, *args):
        """
        nz_indexed_one_based(MX self, int k) -> MX



        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX_nz_indexed_one_based(self, *args)


    def __NZgetitem__(self, *args):
        """
        __NZgetitem__(MX self, int k) -> MX
        __NZgetitem__(MX self, IndexList k) -> MX
        __NZgetitem__(MX self, Slice k) -> MX
        __NZgetitem__(MX self, IMatrix k) -> MX



        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX___NZgetitem__(self, *args)


    def indexed_one_based(self, *args):
        """
        indexed_one_based(MX self, int rr, int cc) -> MX
        indexed_one_based(MX self, int rr) -> MX



        >  const MX casadi::MX::indexed_one_based(int rr, int cc) const 
        ------------------------------------------------------------------------

        get a matrix element

        >  const MX casadi::MX::indexed_one_based(int rr) const 
        ------------------------------------------------------------------------

        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX_indexed_one_based(self, *args)


    def __Cgetitem__(self, *args):
        """
        __Cgetitem__(MX self, int rr, int cc) -> MX
        __Cgetitem__(MX self, IndexList rr, IndexList cc) -> MX
        __Cgetitem__(MX self, Slice rr, Slice cc) -> MX
        __Cgetitem__(MX self, IMatrix k) -> MX
        __Cgetitem__(MX self, Sparsity sp) -> MX
        __Cgetitem__(MX self, Slice rr, IMatrix cc) -> MX
        __Cgetitem__(MX self, IMatrix rr, IndexList cc) -> MX
        __Cgetitem__(MX self, IMatrix rr, Slice cc) -> MX
        __Cgetitem__(MX self, IndexList rr, IMatrix cc) -> MX
        __Cgetitem__(MX self, IMatrix rr, IMatrix cc) -> MX
        __Cgetitem__(MX self, int rr) -> MX
        __Cgetitem__(MX self, IndexList rr) -> MX
        __Cgetitem__(MX self, Slice rr) -> MX



        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX___Cgetitem__(self, *args)


    def nz_indexed_one_based_assignment(self, *args):
        """
        nz_indexed_one_based_assignment(MX self, int k, MX m)



        set a non-zero


        """
        return _casadi_core.MX_nz_indexed_one_based_assignment(self, *args)


    def __NZsetitem__(self, *args):
        """
        __NZsetitem__(MX self, int k, MX m)
        __NZsetitem__(MX self, IndexList k, MX m)
        __NZsetitem__(MX self, Slice k, MX m)
        __NZsetitem__(MX self, IMatrix k, MX m)



        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX___NZsetitem__(self, *args)


    def indexed_one_based_assignment(self, *args):
        """
        indexed_one_based_assignment(MX self, int rr, int cc, MX m)
        indexed_one_based_assignment(MX self, int rr, MX m)



        >  void casadi::MX::indexed_one_based_assignment(int rr, int cc, const MX &m)
        ------------------------------------------------------------------------

        set a matrix element


        """
        return _casadi_core.MX_indexed_one_based_assignment(self, *args)


    def __Csetitem__(self, *args):
        """
        __Csetitem__(MX self, int rr, int cc, MX m)
        __Csetitem__(MX self, IndexList rr, IndexList cc, MX m)
        __Csetitem__(MX self, Slice rr, Slice cc, MX m)
        __Csetitem__(MX self, IMatrix k, MX m)
        __Csetitem__(MX self, Sparsity sp, MX m)
        __Csetitem__(MX self, IMatrix rr, Slice cc, MX m)
        __Csetitem__(MX self, Slice rr, IMatrix cc, MX m)
        __Csetitem__(MX self, IMatrix rr, IndexList cc, MX m)
        __Csetitem__(MX self, IndexList rr, IMatrix cc, MX m)
        __Csetitem__(MX self, IMatrix rr, IMatrix cc, MX m)
        __Csetitem__(MX self, int rr, MX m)
        __Csetitem__(MX self, IndexList rr, MX m)
        __Csetitem__(MX self, Slice rr, MX m)



        >  void casadi::MX::indexed_assignment(const IndexList &rr, const IndexList &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const Slice &rr, const Slice &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const Sparsity &sp, const MX &m)

        >  void casadi::MX::indexed_assignment(const Matrix< int > &rr, const Slice &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const Slice &rr, const Matrix< int > &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const Matrix< int > &rr, const IndexList &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const IndexList &rr, const Matrix< int > &cc, const MX &m)

        >  void casadi::MX::indexed_assignment(const Matrix< int > &rr, const Matrix< int > &cc, const MX &m)
        ------------------------------------------------------------------------

        get a non-zero

        Indexing for interfaced languages


        """
        return _casadi_core.MX___Csetitem__(self, *args)


    def sparsity(self, *args):
        """
        sparsity(MX self) -> Sparsity



        Get the sparsity pattern.


        """
        return _casadi_core.MX_sparsity(self, *args)


    def sparsityRef(self, *args):
        """
        sparsityRef(MX self) -> Sparsity



        Access the sparsity, make a copy if there are multiple references to it.


        """
        return _casadi_core.MX_sparsityRef(self, *args)


    def erase(self, *args):
        """
        erase(MX self, IVector rr, IVector cc)



        Erase a submatrix.


        """
        return _casadi_core.MX_erase(self, *args)


    def enlarge(self, *args):
        """
        enlarge(MX self, int nrow, int ncol, IVector rr, IVector cc)



        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.


        """
        return _casadi_core.MX_enlarge(self, *args)


    def __neg__(self, *args):
        """__neg__(MX self) -> MX"""
        return _casadi_core.MX___neg__(self, *args)


    def getDep(self, *args):
        """
        getDep(MX self, int ch=0) -> MX



        Get the nth dependency as MX.


        """
        return _casadi_core.MX_getDep(self, *args)


    def getNumOutputs(self, *args):
        """
        getNumOutputs(MX self) -> int



        Number of outputs.


        """
        return _casadi_core.MX_getNumOutputs(self, *args)


    def getOutput(self, *args):
        """
        getOutput(MX self, int oind=0) -> MX



        Get an output.


        """
        return _casadi_core.MX_getOutput(self, *args)


    def getNdeps(self, *args):
        """
        getNdeps(MX self) -> int



        Get the number of dependencies of a binary SXElement.


        """
        return _casadi_core.MX_getNdeps(self, *args)


    def getName(self, *args):
        """
        getName(MX self) -> std::string



        Get the name.


        """
        return _casadi_core.MX_getName(self, *args)


    def getValue(self, *args):
        """
        getValue(MX self) -> double



        Get the value (only for scalar constant nodes)


        """
        return _casadi_core.MX_getValue(self, *args)


    def getMatrixValue(self, *args):
        """
        getMatrixValue(MX self) -> DMatrix



        Get the value (only for constant nodes)


        """
        return _casadi_core.MX_getMatrixValue(self, *args)


    def isSymbolic(self, *args):
        """
        isSymbolic(MX self) -> bool



        Check if symbolic.


        """
        return _casadi_core.MX_isSymbolic(self, *args)


    def isConstant(self, *args):
        """
        isConstant(MX self) -> bool



        Check if constant.


        """
        return _casadi_core.MX_isConstant(self, *args)


    def isEvaluation(self, *args):
        """
        isEvaluation(MX self) -> bool



        Check if evaluation.


        """
        return _casadi_core.MX_isEvaluation(self, *args)


    def isEvaluationOutput(self, *args):
        """
        isEvaluationOutput(MX self) -> bool



        Check if evaluation output.


        """
        return _casadi_core.MX_isEvaluationOutput(self, *args)


    def getEvaluationOutput(self, *args):
        """
        getEvaluationOutput(MX self) -> int



        Get the index of evaluation output - only valid when isEvaluationoutput() is
        true.


        """
        return _casadi_core.MX_getEvaluationOutput(self, *args)


    def isOperation(self, *args):
        """
        isOperation(MX self, int op) -> bool



        Is it a certain operation.


        """
        return _casadi_core.MX_isOperation(self, *args)


    def isMultiplication(self, *args):
        """
        isMultiplication(MX self) -> bool



        Check if multiplication.


        """
        return _casadi_core.MX_isMultiplication(self, *args)


    def isCommutative(self, *args):
        """
        isCommutative(MX self) -> bool



        Check if commutative operation.


        """
        return _casadi_core.MX_isCommutative(self, *args)


    def isNorm(self, *args):
        """
        isNorm(MX self) -> bool



        Check if norm.


        """
        return _casadi_core.MX_isNorm(self, *args)


    def isSymbolicSparse(self, *args):
        """
        isSymbolicSparse(MX self) -> bool



        check if all nonzeros are symbolic (this function is currently identical to
        isSymbolic)


        """
        return _casadi_core.MX_isSymbolicSparse(self, *args)


    def isIdentity(self, *args):
        """
        isIdentity(MX self) -> bool



        check if identity


        """
        return _casadi_core.MX_isIdentity(self, *args)


    def isZero(self, *args):
        """
        isZero(MX self) -> bool



        check if zero (note that false negative answers are possible)


        """
        return _casadi_core.MX_isZero(self, *args)


    def isOne(self, *args):
        """
        isOne(MX self) -> bool



        check if zero (note that false negative answers are possible)


        """
        return _casadi_core.MX_isOne(self, *args)


    def isMinusOne(self, *args):
        """
        isMinusOne(MX self) -> bool



        check if zero (note that false negative answers are possible)


        """
        return _casadi_core.MX_isMinusOne(self, *args)


    def isTranspose(self, *args):
        """
        isTranspose(MX self) -> bool



        Is the expression a transpose?


        """
        return _casadi_core.MX_isTranspose(self, *args)


    def isRegular(self, *args):
        """
        isRegular(MX self) -> bool



        Checks if expression does not contain NaN or Inf.


        """
        return _casadi_core.MX_isRegular(self, *args)


    def getFunction(self, *args):
        """
        getFunction(MX self) -> Function



        Get function.


        """
        return _casadi_core.MX_getFunction(self, *args)


    def isBinary(self, *args):
        """
        isBinary(MX self) -> bool



        Is binary operation.


        """
        return _casadi_core.MX_isBinary(self, *args)


    def isUnary(self, *args):
        """
        isUnary(MX self) -> bool



        Is unary operation.


        """
        return _casadi_core.MX_isUnary(self, *args)


    def getOp(self, *args):
        """
        getOp(MX self) -> int



        Get operation type.


        """
        return _casadi_core.MX_getOp(self, *args)


    def isEqual(self, *args):
        """
        isEqual(MX self, MX y, int depth=0) -> bool



        >  bool casadi::MX::isEqual(const MX &y, int depth=0) const 
        ------------------------------------------------------------------------

        Check if two nodes are equivalent up to a given depth. Depth=0 checks if the
        expressions are identical, i.e. points to the same node.

        a = x*x b = x*x

        a.isEqual(b, 0) will return false, but a.isEqual(b, 1) will return true

        >  bool casadi::MX::isEqual(const MXNode *y, int depth=0) const 
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi_core.MX_isEqual(self, *args)


    def __hash__(self, *args):
        """
        __hash__(MX self) -> long



        Returns a number that is unique for a given MXNode. If the MX does not point
        to any node, 0 is returned.


        """
        return _casadi_core.MX___hash__(self, *args)


    def getTemp(self, *args):
        """
        getTemp(MX self) -> int

        [INTERNAL]  Get the temporary
        variable


        """
        return _casadi_core.MX_getTemp(self, *args)


    def setTemp(self, *args):
        """
        setTemp(MX self, int t)

        [INTERNAL]  Set the temporary
        variable.


        """
        return _casadi_core.MX_setTemp(self, *args)


    def binary(*args):
        """
        binary(int op, MX x, MX y) -> MX



        Create nodes by their ID.


        """
        return _casadi_core.MX_binary(*args)

    if _newclass:
        binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary

    def unary(*args):
        """
        unary(int op, MX x) -> MX



        Create nodes by their ID.


        """
        return _casadi_core.MX_unary(*args)

    if _newclass:
        unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary

    def inf(*args):
        """
        inf(Sparsity sp) -> MX
        inf(int nrow=1, int ncol=1) -> MX
        inf(Pair_Int_Int rc) -> MX



        create a matrix with all inf


        """
        return _casadi_core.MX_inf(*args)

    if _newclass:
        inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf

    def nan(*args):
        """
        nan(Sparsity sp) -> MX
        nan(int nrow=1, int ncol=1) -> MX
        nan(Pair_Int_Int rc) -> MX



        create a matrix with all nan


        """
        return _casadi_core.MX_nan(*args)

    if _newclass:
        nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan

    def repmat(*args):
        """
        repmat(MX x, Sparsity sp) -> MX
        repmat(MX x, int nrow, int ncol=1) -> MX
        repmat(MX x, Pair_Int_Int rc) -> MX



        create a matrix by repeating an existing matrix


        """
        return _casadi_core.MX_repmat(*args)

    if _newclass:
        repmat = staticmethod(repmat)
    __swig_getmethods__["repmat"] = lambda x: repmat

    def eye(*args):
        """eye(int ncol) -> MX"""
        return _casadi_core.MX_eye(*args)

    if _newclass:
        eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye

    def sub(self, *args):
        """
        sub(MX self, int rr, int cc) -> MX
        sub(MX self, IVector rr, int cc) -> MX
        sub(MX self, int rr, IVector cc) -> MX
        sub(MX self, IVector rr, IVector cc) -> MX
        sub(MX self, Sparsity sp, int dummy=0) -> MX
        sub(MX self, IMatrix rr, int cc) -> MX
        sub(MX self, IMatrix rr, IVector cc) -> MX
        sub(MX self, IVector rr, IMatrix cc) -> MX
        sub(MX self, int rr, Slice cc) -> MX
        sub(MX self, Slice rr, int cc) -> MX
        sub(MX self, Slice rr, Slice cc) -> MX
        sub(MX self, IMatrix rr, Slice cc) -> MX
        sub(MX self, Slice rr, IMatrix cc) -> MX
        sub(MX self, IMatrix rr, IMatrix cc) -> MX
        sub(MX self, int rr, IMatrix cc) -> MX

        [INTERNAL] 
        """
        return _casadi_core.MX_sub(self, *args)


    def setSub(self, *args):
        """
        setSub(MX self, MX m, int rr, int cc)
        setSub(MX self, MX m, IVector rr, int cc)
        setSub(MX self, MX m, int rr, IVector cc)
        setSub(MX self, MX m, IVector rr, IVector cc)
        setSub(MX self, MX m, IVector rr, Slice cc)
        setSub(MX self, MX m, IMatrix rr, IVector cc)
        setSub(MX self, MX m, IMatrix rr, int cc)
        setSub(MX self, MX m, IVector rr, IMatrix cc)
        setSub(MX self, MX m, int rr, IMatrix cc)
        setSub(MX self, MX m, Slice rr, Slice cc)
        setSub(MX self, MX m, IMatrix rr, IMatrix cc)
        setSub(MX self, MX m, Sparsity sp, int dummy)

        [INTERNAL] 
        """
        return _casadi_core.MX_setSub(self, *args)


    def getNZ(self, *args):
        """
        getNZ(MX self, int k) -> MX
        getNZ(MX self, IVector k) -> MX
        getNZ(MX self, Slice k) -> MX
        getNZ(MX self, IMatrix k) -> MX

        [INTERNAL] 
        """
        return _casadi_core.MX_getNZ(self, *args)


    def setNZ(self, *args):
        """
        setNZ(MX self, int k, MX el)
        setNZ(MX self, IVector k, MX el)
        setNZ(MX self, Slice k, MX m)
        setNZ(MX self, IMatrix k, MX m)

        [INTERNAL] 
        """
        return _casadi_core.MX_setNZ(self, *args)


    def append(self, *args):
        """
        append(MX self, MX y)



        Append a matrix vertically (NOTE: only efficient if vector)


        """
        return _casadi_core.MX_append(self, *args)


    def appendColumns(self, *args):
        """
        appendColumns(MX self, MX y)



        Append a matrix horizontally.


        """
        return _casadi_core.MX_appendColumns(self, *args)


    def __add__(self, *args):
        """
        __add__(MX self, MX y) -> MX



        all binary operations


        """
        return _casadi_core.MX___add__(self, *args)


    def __sub__(self, *args):
        """__sub__(MX self, MX y) -> MX"""
        return _casadi_core.MX___sub__(self, *args)


    def __mul__(self, *args):
        """__mul__(MX self, MX y) -> MX"""
        return _casadi_core.MX___mul__(self, *args)


    def __div__(self, *args):
        """__div__(MX self, MX y) -> MX"""
        return _casadi_core.MX___div__(self, *args)


    def __lt__(self, *args):
        """__lt__(MX self, MX y) -> MX"""
        return _casadi_core.MX___lt__(self, *args)


    def __le__(self, *args):
        """__le__(MX self, MX y) -> MX"""
        return _casadi_core.MX___le__(self, *args)


    def __eq__(self, *args):
        """__eq__(MX self, MX y) -> MX"""
        return _casadi_core.MX___eq__(self, *args)


    def __ne__(self, *args):
        """__ne__(MX self, MX y) -> MX"""
        return _casadi_core.MX___ne__(self, *args)


    def __truediv__(self, *args):
        """__truediv__(MX self, MX y) -> MX"""
        return _casadi_core.MX___truediv__(self, *args)


    def __pow__(self, *args):
        """__pow__(MX self, MX b) -> MX"""
        return _casadi_core.MX___pow__(self, *args)


    def __constpow__(self, *args):
        """__constpow__(MX self, MX b) -> MX"""
        return _casadi_core.MX___constpow__(self, *args)


    def __mrdivide__(self, *args):
        """__mrdivide__(MX self, MX b) -> MX"""
        return _casadi_core.MX___mrdivide__(self, *args)


    def __mpower__(self, *args):
        """__mpower__(MX self, MX b) -> MX"""
        return _casadi_core.MX___mpower__(self, *args)


    def mul(self, *args):
        """mul(MX self, MX y, Sparsity sp_z) -> MX"""
        return _casadi_core.MX_mul(self, *args)


    def mul_full(self, *args):
        """mul_full(MX self, MX y, Sparsity sp_z) -> MX"""
        return _casadi_core.MX_mul_full(self, *args)


    def inner_prod(self, *args):
        """inner_prod(MX self, MX y) -> MX"""
        return _casadi_core.MX_inner_prod(self, *args)


    def outer_prod(self, *args):
        """outer_prod(MX self, MX y) -> MX"""
        return _casadi_core.MX_outer_prod(self, *args)


    def constpow(self, *args):
        """constpow(MX self, MX y) -> MX"""
        return _casadi_core.MX_constpow(self, *args)


    def fmin(self, *args):
        """fmin(MX self, MX y) -> MX"""
        return _casadi_core.MX_fmin(self, *args)


    def fmax(self, *args):
        """fmax(MX self, MX y) -> MX"""
        return _casadi_core.MX_fmax(self, *args)


    def fmod(self, *args):
        """fmod(MX self, MX y) -> MX"""
        return _casadi_core.MX_fmod(self, *args)


    def printme(self, *args):
        """printme(MX self, MX y) -> MX"""
        return _casadi_core.MX_printme(self, *args)


    def arctan2(self, *args):
        """arctan2(MX self, MX y) -> MX"""
        return _casadi_core.MX_arctan2(self, *args)


    def logic_and(self, *args):
        """logic_and(MX self, MX y) -> MX"""
        return _casadi_core.MX_logic_and(self, *args)


    def logic_or(self, *args):
        """logic_or(MX self, MX y) -> MX"""
        return _casadi_core.MX_logic_or(self, *args)


    def if_else_zero(self, *args):
        """if_else_zero(MX self, MX y) -> MX"""
        return _casadi_core.MX_if_else_zero(self, *args)


    def __copysign__(self, *args):
        """__copysign__(MX self, MX y) -> MX"""
        return _casadi_core.MX___copysign__(self, *args)


    def exp(self, *args):
        """exp(MX self) -> MX"""
        return _casadi_core.MX_exp(self, *args)


    def log(self, *args):
        """log(MX self) -> MX"""
        return _casadi_core.MX_log(self, *args)


    def log10(self, *args):
        """log10(MX self) -> MX"""
        return _casadi_core.MX_log10(self, *args)


    def sqrt(self, *args):
        """sqrt(MX self) -> MX"""
        return _casadi_core.MX_sqrt(self, *args)


    def sin(self, *args):
        """sin(MX self) -> MX"""
        return _casadi_core.MX_sin(self, *args)


    def cos(self, *args):
        """cos(MX self) -> MX"""
        return _casadi_core.MX_cos(self, *args)


    def tan(self, *args):
        """tan(MX self) -> MX"""
        return _casadi_core.MX_tan(self, *args)


    def arcsin(self, *args):
        """arcsin(MX self) -> MX"""
        return _casadi_core.MX_arcsin(self, *args)


    def arccos(self, *args):
        """arccos(MX self) -> MX"""
        return _casadi_core.MX_arccos(self, *args)


    def arctan(self, *args):
        """arctan(MX self) -> MX"""
        return _casadi_core.MX_arctan(self, *args)


    def floor(self, *args):
        """floor(MX self) -> MX"""
        return _casadi_core.MX_floor(self, *args)


    def ceil(self, *args):
        """ceil(MX self) -> MX"""
        return _casadi_core.MX_ceil(self, *args)


    def fabs(self, *args):
        """fabs(MX self) -> MX"""
        return _casadi_core.MX_fabs(self, *args)


    def sign(self, *args):
        """sign(MX self) -> MX"""
        return _casadi_core.MX_sign(self, *args)


    def erfinv(self, *args):
        """erfinv(MX self) -> MX"""
        return _casadi_core.MX_erfinv(self, *args)


    def erf(self, *args):
        """erf(MX self) -> MX"""
        return _casadi_core.MX_erf(self, *args)


    def sinh(self, *args):
        """sinh(MX self) -> MX"""
        return _casadi_core.MX_sinh(self, *args)


    def cosh(self, *args):
        """cosh(MX self) -> MX"""
        return _casadi_core.MX_cosh(self, *args)


    def tanh(self, *args):
        """tanh(MX self) -> MX"""
        return _casadi_core.MX_tanh(self, *args)


    def arcsinh(self, *args):
        """arcsinh(MX self) -> MX"""
        return _casadi_core.MX_arcsinh(self, *args)


    def arccosh(self, *args):
        """arccosh(MX self) -> MX"""
        return _casadi_core.MX_arccosh(self, *args)


    def arctanh(self, *args):
        """arctanh(MX self) -> MX"""
        return _casadi_core.MX_arctanh(self, *args)


    def logic_not(self, *args):
        """logic_not(MX self) -> MX"""
        return _casadi_core.MX_logic_not(self, *args)


    def attachAssert(self, *args):
        """
        attachAssert(MX self, MX y, std::string const & fail_message) -> MX



        returns itself, but with an assertion attached

        If y does not evaluate to 1, a runtime error is raised


        """
        return _casadi_core.MX_attachAssert(self, *args)


    def setSparse(self, *args):
        """
        setSparse(MX self, Sparsity sp, bool intersect=False) -> MX



        Set sparse.


        """
        return _casadi_core.MX_setSparse(self, *args)


    def densify(self, *args):
        """
        densify(MX self, MX val=0)



        Make the matrix dense.


        """
        return _casadi_core.MX_densify(self, *args)


    def lift(self, *args):
        """
        lift(MX self, MX x_guess)



        Lift an expression.


        """
        return _casadi_core.MX_lift(self, *args)


    def addToSum(self, *args):
        """
        addToSum(MX self, MX x)



        Add an expression to the expression if the expression is non-empty,
        otherwise assign.


        """
        return _casadi_core.MX_addToSum(self, *args)


    def trans(self, *args):
        """
        trans(MX self) -> MX



        Transpose the matrix.


        """
        return _casadi_core.MX_trans(self, *args)


    def mapping(self, *args):
        """
        mapping(MX self) -> IMatrix



        Get an IMatrix representation of a GetNonzeros or SetNonzeros node.


        """
        return _casadi_core.MX_mapping(self, *args)


    def setMaxNumCallsInPrint(*args):
        """setMaxNumCallsInPrint(long num=10000)"""
        return _casadi_core.MX_setMaxNumCallsInPrint(*args)

    if _newclass:
        setMaxNumCallsInPrint = staticmethod(setMaxNumCallsInPrint)
    __swig_getmethods__["setMaxNumCallsInPrint"] = lambda x: setMaxNumCallsInPrint

    def getMaxNumCallsInPrint(*args):
        """getMaxNumCallsInPrint() -> long"""
        return _casadi_core.MX_getMaxNumCallsInPrint(*args)

    if _newclass:
        getMaxNumCallsInPrint = staticmethod(getMaxNumCallsInPrint)
    __swig_getmethods__["getMaxNumCallsInPrint"] = lambda x: getMaxNumCallsInPrint

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi_core.MX_setEqualityCheckingDepth(*args)

    if _newclass:
        setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth

    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi_core.MX_getEqualityCheckingDepth(*args)

    if _newclass:
        getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.MX_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi_core.reshape(self,arg)

    @property
    def T(self):
        return _casadi_core.transpose(self)

    def __getitem__(self,s):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Cgetitem__(s[0],s[1])  
        return self.__Cgetitem__(s)

    def __setitem__(self,s,val):
        if isinstance(s,tuple) and len(s)==2:
          return self.__Csetitem__(s[0],s[1],val)  
        return self.__Csetitem__(s,val)

    @property
    def nz(self):
      return NZproxy(self)

    def prod(self,*args):
        raise Exception("'prod' is not supported anymore in CasADi. Use 'mul' to do matrix multiplication.")




    __array_priority__ = 1002.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.toArray()



    def __array_custom__(self,*args,**kwargs):
      import numpy as np
      if np.__version__=="1.8.1": #1083
        return np.array(np.nan)
      raise Exception("MX cannot be converted to an array. MX.__array__ purely exists to allow ufunc/numpy goodies")

    def __iter__(self):
      return self.nz.__iter__()



    def __rpow__(self, *args):
        """__rpow__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rpow__(self, *args)


    def __radd__(self, *args):
        """__radd__(MX self, MX b) -> MX"""
        return _casadi_core.MX___radd__(self, *args)


    def __rsub__(self, *args):
        """__rsub__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rsub__(self, *args)


    def __rmul__(self, *args):
        """__rmul__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rmul__(self, *args)


    def __rdiv__(self, *args):
        """__rdiv__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rdiv__(self, *args)


    def __rtruediv__(self, *args):
        """__rtruediv__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rtruediv__(self, *args)


    def __rmldivide__(self, *args):
        """__rmldivide__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rmldivide__(self, *args)


    def __rmrdivide__(self, *args):
        """__rmrdivide__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rmrdivide__(self, *args)


    def __rmpower__(self, *args):
        """__rmpower__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rmpower__(self, *args)


    def __rconstpow__(self, *args):
        """__rconstpow__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rconstpow__(self, *args)


    def __rge__(self, *args):
        """__rge__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rge__(self, *args)


    def __rgt__(self, *args):
        """__rgt__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rgt__(self, *args)


    def __rle__(self, *args):
        """__rle__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rle__(self, *args)


    def __rlt__(self, *args):
        """__rlt__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rlt__(self, *args)


    def __req__(self, *args):
        """__req__(MX self, MX b) -> MX"""
        return _casadi_core.MX___req__(self, *args)


    def __rne__(self, *args):
        """__rne__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rne__(self, *args)


    def __rfmin__(self, *args):
        """__rfmin__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rfmin__(self, *args)


    def __rfmax__(self, *args):
        """__rfmax__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rfmax__(self, *args)


    def rmul(self, *args):
        """rmul(MX self, MX b) -> MX"""
        return _casadi_core.MX_rmul(self, *args)


    def __rarctan2__(self, *args):
        """__rarctan2__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rarctan2__(self, *args)


    def __rcopysign__(self, *args):
        """__rcopysign__(MX self, MX b) -> MX"""
        return _casadi_core.MX___rcopysign__(self, *args)

MX_swigregister = _casadi_core.MX_swigregister
MX_swigregister(MX)

def MX_binary(*args):
    """
    MX_binary(int op, MX x, MX y) -> MX



    Create nodes by their ID.


    """
    return _casadi_core.MX_binary(*args)

def MX_unary(*args):
    """
    MX_unary(int op, MX x) -> MX



    Create nodes by their ID.


    """
    return _casadi_core.MX_unary(*args)

def MX_inf(*args):
    """
    inf(Sparsity sp) -> MX
    inf(int nrow=1, int ncol=1) -> MX
    MX_inf(Pair_Int_Int rc) -> MX



    create a matrix with all inf


    """
    return _casadi_core.MX_inf(*args)

def MX_nan(*args):
    """
    nan(Sparsity sp) -> MX
    nan(int nrow=1, int ncol=1) -> MX
    MX_nan(Pair_Int_Int rc) -> MX



    create a matrix with all nan


    """
    return _casadi_core.MX_nan(*args)

def MX_repmat(*args):
    """
    repmat(MX x, Sparsity sp) -> MX
    repmat(MX x, int nrow, int ncol=1) -> MX
    MX_repmat(MX x, Pair_Int_Int rc) -> MX



    create a matrix by repeating an existing matrix


    """
    return _casadi_core.MX_repmat(*args)

def MX_eye(*args):
    """MX_eye(int ncol) -> MX"""
    return _casadi_core.MX_eye(*args)

def MX_setMaxNumCallsInPrint(*args):
    """MX_setMaxNumCallsInPrint(long num=10000)"""
    return _casadi_core.MX_setMaxNumCallsInPrint(*args)

def MX_getMaxNumCallsInPrint(*args):
    """MX_getMaxNumCallsInPrint() -> long"""
    return _casadi_core.MX_getMaxNumCallsInPrint(*args)

def MX_setEqualityCheckingDepth(*args):
    """MX_setEqualityCheckingDepth(int eq_depth=1)"""
    return _casadi_core.MX_setEqualityCheckingDepth(*args)

def MX_getEqualityCheckingDepth(*args):
    """MX_getEqualityCheckingDepth() -> int"""
    return _casadi_core.MX_getEqualityCheckingDepth(*args)

def MX_testCast(*args):
    """MX_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.MX_testCast(*args)


def rank(*args):
    """
    rank(Sparsity a) -> int



    Obtain the structural rank of a sparsity-pattern.


    """
    return _casadi_core.rank(*args)

def norm_inf_mul_nn(*args):
    """
    norm_inf_mul_nn(DMatrix x, DMatrix y, DVector Dwork, IVector Iwork) -> double



    Inf-norm of a Matrix-matrix product, no memory allocation mul(x, y)

    Parameters:
    -----------

    Dwork:  A double work vector that you must allocate Minimum size: y.size1()

    Iwork:  A integer work vector that you must allocate Minimum size:
    y.size1()+x.size2()+1


    """
    return _casadi_core.norm_inf_mul_nn(*args)

def getMinor(*args):
    """
    getMinor(IMatrix x, int i, int j) -> int
    getMinor(DMatrix x, int i, int j) -> double
    getMinor(SX x, int i, int j) -> SXElement



    Transpose of a matrix.


    """
    return _casadi_core.getMinor(*args)

def cofactor(*args):
    """
    cofactor(IMatrix x, int i, int j) -> int
    cofactor(DMatrix x, int i, int j) -> double
    cofactor(SX x, int i, int j) -> SXElement



    Transpose of a matrix.


    """
    return _casadi_core.cofactor(*args)

def adj(*args):
    """
    adj(IMatrix a) -> IMatrix
    adj(DMatrix a) -> DMatrix
    adj(SX a) -> SX



    Transpose of a matrix.


    """
    return _casadi_core.adj(*args)

def norm_0_mul_nn(*args):
    """
    norm_0_mul_nn(IMatrix x, IMatrix y, BVector Bwork, IVector Iwork) -> int
    norm_0_mul_nn(DMatrix x, DMatrix y, BVector Bwork, IVector Iwork) -> int
    norm_0_mul_nn(SX x, SX y, BVector Bwork, IVector Iwork) -> int



    0-norm (nonzero count) of a Matrix-matrix product, no memory allocation
    mul(x, y)

    Parameters:
    -----------

    Bwork:  A boolean work vector that you must allocate Minimum size: y.size1()

    Iwork:  A integer work vector that you must allocate Minimum size:
    y.size1()+x.size2()+1


    """
    return _casadi_core.norm_0_mul_nn(*args)

def qr(*args):
    """
    qr(IMatrix A)
    qr(DMatrix A)
    qr(SX A)

    [INTERNAL]  QR factorization using the
    modified Gram-Schmidt algorithm More stable than the classical Gram-Schmidt,
    but may break down if the rows of A are nearly linearly dependent See J.
    Demmel: Applied Numerical Linear Algebra (algorithm 3.1.). Note that in
    SWIG, Q and R are returned by value.


    """
    return _casadi_core.qr(*args)

def addMultiple(*args):
    """
    addMultiple(IMatrix A, IVector v, IVector res, bool trans_A=False)
    addMultiple(DMatrix A, DVector v, DVector res, bool trans_A=False)
    addMultiple(SX A, SXElementVector v, SXElementVector res, bool trans_A=False)



    same as: res += mul(A, v)


    """
    return _casadi_core.addMultiple(*args)

def project(*args):
    """
    project(IMatrix A, Sparsity sparsity) -> IMatrix
    project(DMatrix A, Sparsity sparsity) -> DMatrix
    project(SX A, Sparsity sparsity) -> SX



    Create a new matrix with a given sparsity pattern but with the nonzeros
    taken from an existing matrix.


    """
    return _casadi_core.project(*args)

def sprank(*args):
    """
    sprank(IMatrix A) -> int
    sprank(DMatrix A) -> int
    sprank(SX A) -> int



    Obtain the structural rank of a sparsity-pattern.


    """
    return _casadi_core.sprank(*args)

def sparse(*args):
    """
    sparse(IMatrix A, double tol=0) -> IMatrix
    sparse(DMatrix A, double tol=0) -> DMatrix
    sparse(SX A, double tol=0) -> SX



    Make a matrix sparse by removing numerical zeros.


    """
    return _casadi_core.sparse(*args)

def cross(*args):
    """
    cross(GenIMatrix a, GenIMatrix b, int dim=-1) -> IMatrix
    cross(GenDMatrix a, GenDMatrix b, int dim=-1) -> DMatrix
    cross(GenSX a, GenSX b, int dim=-1) -> SX
    cross(GenMX a, GenMX b, int dim=-1) -> MX



    Matlab's cross command.


    """
    return _casadi_core.cross(*args)

def quad_form(*args):
    """
    quad_form(GenIMatrix X, GenIMatrix A) -> IMatrix
    quad_form(GenIMatrix X) -> IMatrix
    quad_form(GenDMatrix X, GenDMatrix A) -> DMatrix
    quad_form(GenDMatrix X) -> DMatrix
    quad_form(GenSX X, GenSX A) -> SX
    quad_form(GenSX X) -> SX
    quad_form(GenMX X, GenMX A) -> MX
    quad_form(GenMX X) -> MX



    >  MatType casadi::quad_form(const GenericMatrix< MatType > &X, const GenericMatrix< MatType > &A)
    ------------------------------------------------------------------------

    Calculate quadratic form X^T A X.

    >  MatType casadi::quad_form(const GenericMatrix< MatType > &X)
    ------------------------------------------------------------------------

    Calculate quadratic form X^T X.


    """
    return _casadi_core.quad_form(*args)

def sum_square(*args):
    """
    sum_square(GenIMatrix X) -> IMatrix
    sum_square(GenDMatrix X) -> DMatrix
    sum_square(GenSX X) -> SX
    sum_square(GenMX X) -> MX



    Calculate some of squares: sum_ij X_ij^2.


    """
    return _casadi_core.sum_square(*args)

def tril2symm(*args):
    """
    tril2symm(GenIMatrix a) -> IMatrix
    tril2symm(GenDMatrix a) -> DMatrix
    tril2symm(GenSX a) -> SX
    tril2symm(GenMX a) -> MX



    Convert a lower triangular matrix to a symmetric one.


    """
    return _casadi_core.tril2symm(*args)

def triu2symm(*args):
    """
    triu2symm(GenIMatrix a) -> IMatrix
    triu2symm(GenDMatrix a) -> DMatrix
    triu2symm(GenSX a) -> SX
    triu2symm(GenMX a) -> MX



    Convert a upper triangular matrix to a symmetric one.


    """
    return _casadi_core.triu2symm(*args)

def triu(*args):
    """
    triu(Sparsity sp, bool includeDiagonal=True) -> Sparsity
    triu(GenIMatrix a) -> IMatrix
    triu(GenDMatrix a) -> DMatrix
    triu(GenSX a) -> SX
    triu(GenMX a) -> MX



    >  MatType casadi::triu(const GenericMatrix< MatType > &a)
    ------------------------------------------------------------------------

    Get the upper triangular part of a matrix.

    >  Sparsity casadi::triu(const Sparsity &sp, bool includeDiagonal=true)
    ------------------------------------------------------------------------

    Get upper triangular part.


    """
    return _casadi_core.triu(*args)

def tril(*args):
    """
    tril(Sparsity sp, bool includeDiagonal=True) -> Sparsity
    tril(GenIMatrix a) -> IMatrix
    tril(GenDMatrix a) -> DMatrix
    tril(GenSX a) -> SX
    tril(GenMX a) -> MX



    >  MatType casadi::tril(const GenericMatrix< MatType > &a)
    ------------------------------------------------------------------------

    Get the lower triangular part of a matrix.

    >  Sparsity casadi::tril(const Sparsity &sp, bool includeDiagonal=true)
    ------------------------------------------------------------------------

    Get lower triangular part.


    """
    return _casadi_core.tril(*args)

def isEqual(*args):
    """
    isEqual(GenIMatrix x, GenIMatrix y) -> bool
    isEqual(GenDMatrix x, GenDMatrix y) -> bool
    isEqual(GenSX x, GenSX y) -> bool
    isEqual(GenMX x, GenMX y) -> bool



    Check if two expressions are equal, assuming that they are comparable.


    """
    return _casadi_core.isEqual(*args)

def diagsplit(*args):
    """
    diagsplit(Sparsity sp, IVector output_offset1, IVector output_offset2) -> SparsityVector
    diagsplit(Sparsity x, int incr=1) -> SparsityVector
    diagsplit(Sparsity x, int incr1, int incr2) -> SparsityVector
    diagsplit(Sparsity x, IVector output_offset) -> SparsityVector
    diagsplit(GenIMatrix x, int incr=1) -> IMatrixVector
    diagsplit(GenIMatrix x, int incr1, int incr2) -> IMatrixVector
    diagsplit(GenIMatrix x, IVector output_offset) -> IMatrixVector
    diagsplit(GenIMatrix x, IVector output_offset1, IVector output_offset2) -> IMatrixVector
    diagsplit(GenDMatrix x, int incr=1) -> DMatrixVector
    diagsplit(GenDMatrix x, int incr1, int incr2) -> DMatrixVector
    diagsplit(GenDMatrix x, IVector output_offset) -> DMatrixVector
    diagsplit(GenDMatrix x, IVector output_offset1, IVector output_offset2) -> DMatrixVector
    diagsplit(GenSX x, int incr=1) -> SXVector
    diagsplit(GenSX x, int incr1, int incr2) -> SXVector
    diagsplit(GenSX x, IVector output_offset) -> SXVector
    diagsplit(GenSX x, IVector output_offset1, IVector output_offset2) -> SXVector
    diagsplit(GenMX x, int incr=1) -> MXVector
    diagsplit(GenMX x, int incr1, int incr2) -> MXVector
    diagsplit(GenMX x, IVector output_offset) -> MXVector
    diagsplit(GenMX x, IVector output_offset1, IVector output_offset2) -> MXVector



    >  std::vector< MatType > casadi::diagsplit(const GenericMatrix< MatType > &x, int incr=1)

    >  std::vector< Sparsity > casadi::diagsplit(const Sparsity &x, int incr=1)
    ------------------------------------------------------------------------

    split diagonally, retaining groups of square matrices

    Parameters:
    -----------

    incr:  Size of each matrix

    diagsplit(diagsplit(x, ...)) = x

    >  std::vector< MatType > casadi::diagsplit(const GenericMatrix< MatType > &x, int incr1, int incr2)

    >  std::vector< Sparsity > casadi::diagsplit(const Sparsity &x, int incr1, int incr2)
    ------------------------------------------------------------------------

    split diagonally, retaining fixed-sized matrices

    Parameters:
    -----------

    incr1:  Row dimension of each matrix

    incr2:  Column dimension of each matrix

    diagsplit(diagsplit(x, ...)) = x

    >  std::vector< MatType > casadi::diagsplit(const GenericMatrix< MatType > &x, const std::vector< int > &output_offset)

    >  std::vector< Sparsity > casadi::diagsplit(const Sparsity &x, const std::vector< int > &output_offset)
    ------------------------------------------------------------------------

    split diagonally, retaining square matrices

    Parameters:
    -----------

    output_offset:  List of all start locations for each group the last matrix
    will run to the end.

    diagcat(diagsplit(x, ...)) = x

    >  std::vector< MatType > casadi::diagsplit(const GenericMatrix< MatType > &x, const std::vector< int > &output_offset1, const std::vector< int > &output_offset2)
    ------------------------------------------------------------------------

    split diagonally, retaining square matrices

    Parameters:
    -----------

    output_offset1:  List of all start locations (row) for each group the last
    matrix will run to the end.

    output_offset2:  List of all start locations (row) for each group the last
    matrix will run to the end.

    diagcat(diagsplit(x, ...)) = x

    >  std::vector< Sparsity > casadi::diagsplit(const Sparsity &sp, const std::vector< int > &output_offset1, const std::vector< int > &output_offset2)
    ------------------------------------------------------------------------

    Split up a sparsity pattern diagonally.


    """
    return _casadi_core.diagsplit(*args)

def linspace(*args):
    """
    linspace(GenDMatrix a, GenDMatrix b, int nsteps) -> DMatrix
    linspace(GenSX a, GenSX b, int nsteps) -> SX
    linspace(GenMX a, GenMX b, int nsteps) -> MX



    >  MatType casadi::linspace(const GenericMatrix< MatType > &a, const GenericMatrix< MatType > &b, int nsteps)
    ------------------------------------------------------------------------

    Matlab's linspace command.

    >  void casadi::linspace(std::vector< T > &v, const F &first, const L &last)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Matlab's linspace.


    """
    return _casadi_core.linspace(*args)

def logic_and(*args):
    """
    logic_and(int const & x, int const & y) -> int
    logic_and(double const & x, double const & y) -> double
    logic_and(IMatrix x, IMatrix y) -> IMatrix
    logic_and(DMatrix x, DMatrix y) -> DMatrix
    logic_and(SX x, SX y) -> SX
    logic_and(MX x, MX y) -> MX
    logic_and(SXElement x, SXElement y) -> SXElement



    Logical and, returns (an expression evaluating to) 1 if both expressions are
    nonzero and 0 otherwise.


    """
    return _casadi_core.logic_and(*args)

def logic_or(*args):
    """
    logic_or(int const & x, int const & y) -> int
    logic_or(double const & x, double const & y) -> double
    logic_or(IMatrix x, IMatrix y) -> IMatrix
    logic_or(DMatrix x, DMatrix y) -> DMatrix
    logic_or(SX x, SX y) -> SX
    logic_or(MX x, MX y) -> MX
    logic_or(SXElement x, SXElement y) -> SXElement



    Logical or, returns (an expression evaluating to) 1 if at least one
    expression is nonzero and 0 otherwise.


    """
    return _casadi_core.logic_or(*args)

def logic_not(*args):
    """
    logic_not(int const & x) -> int
    logic_not(double const & x) -> double
    logic_not(IMatrix x) -> IMatrix
    logic_not(DMatrix x) -> DMatrix
    logic_not(SX x) -> SX
    logic_not(MX x) -> MX
    logic_not(SXElement x) -> SXElement



    Logical not, returns (an expression evaluating to) 1 if expression is zero
    and 0 otherwise.


    """
    return _casadi_core.logic_not(*args)

def expand(*args):
    """
    expand(SX ex, SX weights, SX terms)



    Expand the expression as a weighted sum (with constant weights)


    """
    return _casadi_core.expand(*args)

def pw_const(*args):
    """
    pw_const(SX t, SX tval, SX val) -> SX



    Create a piecewise constant function Create a piecewise constant function
    with n=val.size() intervals.

    Inputs:

    Parameters:
    -----------

    t:  a scalar variable (e.g. time)

    tval:  vector with the discrete values of t at the interval transitions
    (length n-1)

    val:  vector with the value of the function for each interval (length n)


    """
    return _casadi_core.pw_const(*args)

def pw_lin(*args):
    """
    pw_lin(SXElement t, SX tval, SX val) -> SX



    t a scalar variable (e.g. time)

    Create a piecewise linear function Create a piecewise linear function:

    Inputs: tval vector with the the discrete values of t (monotonically
    increasing) val vector with the corresponding function values (same length
    as tval)


    """
    return _casadi_core.pw_lin(*args)

def heaviside(*args):
    """
    heaviside(SX x) -> SX



    Heaviside function.

    \\[ \\begin {cases} H(x) = 0 & x<0 \\\\ H(x) = 1/2 & x=0 \\\\
    H(x) = 1 & x>0 \\\\ \\end {cases} \\]


    """
    return _casadi_core.heaviside(*args)

def rectangle(*args):
    """
    rectangle(SX x) -> SX



    rectangle function

    \\[ \\begin {cases} \\Pi(x) = 1 & |x| < 1/2 \\\\ \\Pi(x) = 1/2 &
    |x| = 1/2 \\\\ \\Pi(x) = 0 & |x| > 1/2 \\\\ \\end {cases} \\]

    Also called: gate function, block function, band function, pulse function,
    window function


    """
    return _casadi_core.rectangle(*args)

def triangle(*args):
    """
    triangle(SX x) -> SX



    triangle function

    \\[ \\begin {cases} \\Lambda(x) = 0 & |x| >= 1 \\\\ \\Lambda(x)
    = 1-|x| & |x| < 1 \\end {cases} \\]


    """
    return _casadi_core.triangle(*args)

def ramp(*args):
    """
    ramp(SX x) -> SX



    ramp function

    \\[ \\begin {cases} R(x) = 0 & x <= 1 \\\\ R(x) = x & x > 1 \\\\
    \\end {cases} \\]

    Also called: slope function


    """
    return _casadi_core.ramp(*args)

def gauss_quadrature(*args):
    """
    gauss_quadrature(SX f, SX x, SX a, SX b, int order=5, SX w) -> SX



    Integrate f from a to b using Gaussian quadrature with n points.


    """
    return _casadi_core.gauss_quadrature(*args)

def compress(*args):
    """
    compress(SX ex, int level=5)



    Remove identical calculations.


    """
    return _casadi_core.compress(*args)

def evalf(*args):
    """
    evalf(SX ex) -> DMatrix
    evalf(SX ex, SX v, DMatrix vdef) -> DMatrix



    >  Matrix< double > casadi::evalf(const SX &ex, const SX &v, const Matrix< double > &vdef)
    ------------------------------------------------------------------------

    Substitute variable v with value vdef in an expression ex, and evaluate
    numerically Note: this is not efficient. For critical parts (loops) of your
    code, always use SXFunction.

    >  Matrix< double > casadi::evalf(const SX &ex)
    ------------------------------------------------------------------------

    Evaluate an SX graph numerically Note: this is not efficient. For critical
    parts (loops) of your code, always use SXFunction.


    """
    return _casadi_core.evalf(*args)

def spy(*args):
    """
    spy(SX A) -> SX



    Get the sparsity pattern of a matrix.


    """
    return _casadi_core.spy(*args)

def hessian(*args):
    """
    hessian(SX ex, SX arg) -> SX
    hessian(SX ex, SX arg, SX H, SX g)



    Integrate f from a to b using Gaussian quadrature with n points.


    """
    return _casadi_core.hessian(*args)

def jacobianTimesVector(*args):
    """
    jacobianTimesVector(SX ex, SX arg, SX v, bool transpose_jacobian=False) -> SX



    Calculate the Jacobian and multiply by a vector from the right This is
    equivalent to mul(jacobian(ex, arg), v) or mul(jacobian(ex, arg).T, v) for
    transpose_jacobian set to false and true respectively. If contrast to these
    expressions, it will use directional derivatives which is typically (but not
    necessarily) more efficient if the complete Jacobian is not needed and v has
    few rows.


    """
    return _casadi_core.jacobianTimesVector(*args)

def taylor(*args):
    """
    taylor(SX ex, SX x, SX a, int order=1) -> SX



    univariate Taylor series expansion

    Calculate the Taylor expansion of expression 'ex' up to order 'order' with
    respect to variable 'x' around the point 'a'

    $(x)=f(a)+f'(a)(x-a)+f''(a)\\frac
    {(x-a)^2}{2!}+f'''(a)\\frac{(x-a)^3}{3!}+\\ldots$

    Example usage:

    ::

    >>   x




    """
    return _casadi_core.taylor(*args)

def mtaylor(*args):
    """
    mtaylor(SX ex, SX x, SX a, int order=1) -> SX
    mtaylor(SX ex, SX x, SX a, int order, IVector order_contributions) -> SX



    >  SX casadi::mtaylor(const SX &ex, const SX &x, const SX &a, int order=1)
    ------------------------------------------------------------------------

    multivariate Taylor series expansion

    Do Taylor expansions until the aggregated order of a term is equal to
    'order'. The aggregated order of $x^n y^m$ equals $n+m$.

    >  SX casadi::mtaylor(const SX &ex, const SX &x, const SX &a, int order, const std::vector< int > &order_contributions)
    ------------------------------------------------------------------------

    multivariate Taylor series expansion

    Do Taylor expansions until the aggregated order of a term is equal to
    'order'. The aggregated order of $x^n y^m$ equals $n+m$.

    The argument order_contributions can denote how match each variable
    contributes to the aggregated order. If x=[x, y] and order_contributions=[1,
    2], then the aggregated order of $x^n y^m$ equals $1n+2m$.

    Example usage

    $ \\sin(b+a)+\\cos(b+a)(x-a)+\\cos(b+a)(y-b) $ $ y+x-(x^3+3y x^2+3 y^2
    x+y^3)/6 $ $ (-3 x^2 y-x^3)/6+y+x $


    """
    return _casadi_core.mtaylor(*args)

def getFree(*args):
    """
    getFree(SX ex) -> SX



    Get all the free variables in an expression.


    """
    return _casadi_core.getFree(*args)

def poly_coeff(*args):
    """
    poly_coeff(SX ex, SX x) -> SX



    extracts polynomial coefficients from an expression

    ex Scalar expression that represents a polynomial  x Scalar symbol that the
    polynomial is build up with


    """
    return _casadi_core.poly_coeff(*args)

def poly_roots(*args):
    """
    poly_roots(SX p) -> SX



    Attempts to find the roots of a polynomial.

    This will only work for polynomials up to order 3 It is assumed that the
    roots are real.


    """
    return _casadi_core.poly_roots(*args)

def eig_symbolic(*args):
    """
    eig_symbolic(SX m) -> SX



    Attempts to find the eigenvalues of a symbolic matrix This will only work
    for up to 3x3 matrices.

    Bring m in block diagonal form, calculating eigenvalues of each block
    separately 
    """
    return _casadi_core.eig_symbolic(*args)

def horzcat(*args):
    """
    horzcat(SparsityVector v) -> Sparsity
    horzcat(IMatrixVector v) -> IMatrix
    horzcat(DMatrixVector v) -> DMatrix
    horzcat(SXVector v) -> SX
    horzcat(MXVector x) -> MX



    >  Matrix< DataType > casadi::horzcat(const std::vector< Matrix< DataType > > &v)
    ------------------------------------------------------------------------

    Concatenate a list of matrices horizontally Alternative terminology:
    horizontal stack, hstack, horizontal append, [a b].

    horzcat(horzsplit(x, ...)) = x

    >  Matrix< DataType > casadi::horzcat(const Matrix< DataType > &x, const Matrix< DataType > &y)
    ------------------------------------------------------------------------
    [INTERNAL] 
     Transpose of a matrix.

    >  Sparsity casadi::horzcat(const std::vector< Sparsity > &v)
    ------------------------------------------------------------------------

    Concatenate a list of sparsities horizontally Alternative terminology:
    horizontal stack, hstack, horizontal append, [a b].

    >  Sparsity casadi::horzcat(const Sparsity &a, const Sparsity &b)
    ------------------------------------------------------------------------
    [INTERNAL] 
     Reshape the sparsity pattern keeping the relative location of the nonzeros.

    >  MX casadi::horzcat(const MX &a, const MX &b)
    ------------------------------------------------------------------------
    [INTERNAL] 
    concatenate vertically, two matrices

    >  MX casadi::horzcat(const std::vector< MX > &x)
    ------------------------------------------------------------------------

    concatenate horizontally

    horzcat(horzsplit(x, ...)) = x


    """
    return _casadi_core.horzcat(*args)

def horzsplit(*args):
    """
    horzsplit(Sparsity sp, IVector output_offset) -> SparsityVector
    horzsplit(IMatrix v, IVector offset) -> IMatrixVector
    horzsplit(IMatrix v, int incr=1) -> IMatrixVector
    horzsplit(DMatrix v, IVector offset) -> DMatrixVector
    horzsplit(DMatrix v, int incr=1) -> DMatrixVector
    horzsplit(SX v, IVector offset) -> SXVector
    horzsplit(SX v, int incr=1) -> SXVector
    horzsplit(MX x, IVector output_offset) -> MXVector
    horzsplit(MX x, int incr=1) -> MXVector



    >  std::vector< Matrix< DataType > > casadi::horzsplit(const Matrix< DataType > &v, const std::vector< int > &offset)
    ------------------------------------------------------------------------

    split horizontally, retaining groups of columns

    Parameters:
    -----------

    offset:  List of all start columns for each group the last column group will
    run to the end.

    horzcat(horzsplit(x, ...)) = x

    >  std::vector< Matrix< DataType > > casadi::horzsplit(const Matrix< DataType > &v, int incr=1)
    ------------------------------------------------------------------------

    split horizontally, retaining fixed-sized groups of columns

    Parameters:
    -----------

    incr:  Size of each group of columns

    horzcat(horzsplit(x, ...)) = x

    >  std::vector< Sparsity > casadi::horzsplit(const Sparsity &sp, const std::vector< int > &output_offset)
    ------------------------------------------------------------------------

    Split up a sparsity pattern horizontally.

    >  std::vector< MX > casadi::horzsplit(const MX &x, const std::vector< int > &output_offset)
    ------------------------------------------------------------------------

    split horizontally, retaining groups of cols

    Parameters:
    -----------

    output_offset:  List of all start cols for each group the last col group
    will run to the end.

    horzcat(horzsplit(x, ...)) = x

    >  std::vector< MX > casadi::horzsplit(const MX &x, int incr=1)
    ------------------------------------------------------------------------

    split horizontally, retaining fixed-sized groups of cols

    Parameters:
    -----------

    incr:  Size of each group of cols

    horzcat(horzsplit(x, ...)) = x


    """
    return _casadi_core.horzsplit(*args)

def vertcat(*args):
    """
    vertcat(SparsityVector v) -> Sparsity
    vertcat(IMatrixVector v) -> IMatrix
    vertcat(DMatrixVector v) -> DMatrix
    vertcat(SXVector v) -> SX
    vertcat(MXVector comp) -> MX



    >  Matrix< DataType > casadi::vertcat(const std::vector< Matrix< DataType > > &v)
    ------------------------------------------------------------------------

    Concatenate a list of matrices vertically Alternative terminology: vertical
    stack, vstack, vertical append, [a;b].

    vertcat(vertsplit(x, ...)) = x

    >  Matrix< DataType > casadi::vertcat(const Matrix< DataType > &x, const Matrix< DataType > &y)
    ------------------------------------------------------------------------
    [INTERNAL] 
     Transpose of a matrix.

    >  Sparsity casadi::vertcat(const std::vector< Sparsity > &v)
    ------------------------------------------------------------------------

    Concatenate a list of sparsities vertically Alternative terminology:
    vertical stack, vstack, vertical append, [a;b].

    >  Sparsity casadi::vertcat(const Sparsity &a, const Sparsity &b)
    ------------------------------------------------------------------------
    [INTERNAL] 
     Reshape the sparsity pattern keeping the relative location of the nonzeros.

    >  MX casadi::vertcat(const MX &a, const MX &b)
    ------------------------------------------------------------------------
    [INTERNAL] 
    concatenate horizontally, two matrices

    >  MX casadi::vertcat(const std::vector< MX > &comp)
    ------------------------------------------------------------------------

    concatenate vertically

    vertcat(vertsplit(x, ...)) = x


    """
    return _casadi_core.vertcat(*args)

def vertsplit(*args):
    """
    vertsplit(Sparsity sp, IVector output_offset) -> SparsityVector
    vertsplit(IMatrix v, IVector offset) -> IMatrixVector
    vertsplit(IMatrix v, int incr=1) -> IMatrixVector
    vertsplit(DMatrix v, IVector offset) -> DMatrixVector
    vertsplit(DMatrix v, int incr=1) -> DMatrixVector
    vertsplit(SX v, IVector offset) -> SXVector
    vertsplit(SX v, int incr=1) -> SXVector
    vertsplit(MX x, IVector output_offset) -> MXVector
    vertsplit(MX x, int incr=1) -> MXVector



    >  std::vector< Matrix< DataType > > casadi::vertsplit(const Matrix< DataType > &v, const std::vector< int > &offset)

    >  std::vector< MX > casadi::vertsplit(const MX &x, const std::vector< int > &output_offset)
    ------------------------------------------------------------------------

    split vertically, retaining groups of rows

    Parameters:
    -----------

    output_offset:  List of all start rows for each group the last row group
    will run to the end.

    vertcat(vertsplit(x, ...)) = x

    >  std::vector< Matrix< DataType > > casadi::vertsplit(const Matrix< DataType > &v, int incr=1)

    >  std::vector< MX > casadi::vertsplit(const MX &x, int incr=1)
    ------------------------------------------------------------------------

    split vertically, retaining fixed-sized groups of rows

    Parameters:
    -----------

    incr:  Size of each group of rows

    vertcat(vertsplit(x, ...)) = x

    >  std::vector< Sparsity > casadi::vertsplit(const Sparsity &sp, const std::vector< int > &output_offset)
    ------------------------------------------------------------------------

    Split up a sparsity pattern vertically.


    """
    return _casadi_core.vertsplit(*args)

def blockcat(*args):
    """
    blockcat(SparsityVectorVector v) -> Sparsity
    blockcat(IMatrixVectorVector v) -> IMatrix
    blockcat(DMatrixVectorVector v) -> DMatrix
    blockcat(SXVectorVector v) -> SX
    blockcat(MXVectorVector v) -> MX



    >  Matrix< DataType > casadi::blockcat(const std::vector< std::vector< Matrix< DataType > > > &v)
    ------------------------------------------------------------------------

    Construct a matrix from a list of list of blocks.

    >  Matrix< DataType > casadi::blockcat(const Matrix< DataType > &A, const Matrix< DataType > &B, const Matrix< DataType > &C, const Matrix< DataType > &D)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Construct a matrix from 4 blocks.

    >  Sparsity casadi::blockcat(const std::vector< std::vector< Sparsity > > &v)
    ------------------------------------------------------------------------

    Construct a sparsity from a list of list of sparsities.

    >  MX casadi::blockcat(const std::vector< std::vector< MX > > &v)
    ------------------------------------------------------------------------

    Construct a matrix from a list of list of blocks.

    blockcat(blocksplit(x,..., ...)) = x

    >  MX casadi::blockcat(const MX &A, const MX &B, const MX &C, const MX &D)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Construct a matrix from a list of list of blocks.


    """
    return _casadi_core.blockcat(*args)

def blocksplit(*args):
    """
    blocksplit(IMatrix x, IVector vert_offset, IVector horz_offset) -> IMatrixVectorVector
    blocksplit(IMatrix x, int vert_incr=1, int horz_incr=1) -> IMatrixVectorVector
    blocksplit(DMatrix x, IVector vert_offset, IVector horz_offset) -> DMatrixVectorVector
    blocksplit(DMatrix x, int vert_incr=1, int horz_incr=1) -> DMatrixVectorVector
    blocksplit(SX x, IVector vert_offset, IVector horz_offset) -> SXVectorVector
    blocksplit(SX x, int vert_incr=1, int horz_incr=1) -> SXVectorVector
    blocksplit(MX x, IVector vert_offset, IVector horz_offset) -> MXVectorVector
    blocksplit(MX x, int vert_incr=1, int horz_incr=1) -> MXVectorVector



    >  std::vector< std::vector< Matrix< DataType > > > casadi::blocksplit(const Matrix< DataType > &x, const std::vector< int > &vert_offset, const std::vector< int > &horz_offset)
    ------------------------------------------------------------------------

    chop up into blocks

    Parameters:
    -----------

    vert_offset:  Defines the boundaries of the block rows

    horz_offset:  Defines the boundaries of the block columns

    blockcat(blocksplit(x,..., ...)) = x

    >  std::vector< std::vector< Matrix< DataType > > > casadi::blocksplit(const Matrix< DataType > &x, int vert_incr=1, int horz_incr=1)
    ------------------------------------------------------------------------

    chop up into blocks

    Parameters:
    -----------

    vert_incr:  Defines the increment for block boundaries in row dimension

    horz_incr:  Defines the increment for block boundaries in column dimension

    blockcat(blocksplit(x,..., ...)) = x

    >  std::vector< std::vector< MX > > casadi::blocksplit(const MX &x, const std::vector< int > &vert_offset, const std::vector< int > &horz_offset)
    ------------------------------------------------------------------------

    chop up into blocks

    vert_offset Defines the boundaries of the block cols horz_offset Defines the
    boundaries of the block rows

    blockcat(blocksplit(x,..., ...)) = x

    >  std::vector< std::vector< MX > > casadi::blocksplit(const MX &x, int vert_incr=1, int horz_incr=1)
    ------------------------------------------------------------------------

    chop up into blocks

    vert_incr Defines the increment for block boundaries in col dimension
    horz_incr Defines the increment for block boundaries in row dimension

    blockcat(blocksplit(x,..., ...)) = x


    """
    return _casadi_core.blocksplit(*args)

def diagcat(*args):
    """
    diagcat(MXVector x) -> MX



    >  MX casadi::diagcat(const std::vector< MX > &x)
    ------------------------------------------------------------------------

    concatenate diagonally

    diagcat(diagsplit(x, ...)) = x


    """
    return _casadi_core.diagcat(*args)

def veccat(*args):
    """
    veccat(IMatrixVector comp) -> IMatrix
    veccat(DMatrixVector comp) -> DMatrix
    veccat(SXVector comp) -> SX
    veccat(MXVector comp) -> MX



    >  Matrix< DataType > casadi::veccat(const std::vector< Matrix< DataType > > &comp)
    ------------------------------------------------------------------------

    concatenate vertically while vectorizing all arguments with vec

    >  MX casadi::veccat(const std::vector< MX > &comp)
    ------------------------------------------------------------------------

    Concatenate vertically while vectorizing all arguments.


    """
    return _casadi_core.veccat(*args)

def vecNZcat(*args):
    """
    vecNZcat(IMatrixVector comp) -> IMatrix
    vecNZcat(DMatrixVector comp) -> DMatrix
    vecNZcat(SXVector comp) -> SX
    vecNZcat(MXVector comp) -> MX



    >  Matrix< DataType > casadi::vecNZcat(const std::vector< Matrix< DataType > > &comp)
    ------------------------------------------------------------------------

    concatenate vertically while vectorizing all arguments with vecNZ

    >  MX casadi::vecNZcat(const std::vector< MX > &comp)
    ------------------------------------------------------------------------

    concatenate vertically while vecing all arguments with vecNZ


    """
    return _casadi_core.vecNZcat(*args)

def norm_F(*args):
    """
    norm_F(IMatrix x) -> IMatrix
    norm_F(DMatrix x) -> DMatrix
    norm_F(SX x) -> SX
    norm_F(MX x) -> MX



    Frobenius norm.


    """
    return _casadi_core.norm_F(*args)

def norm_2(*args):
    """
    norm_2(IMatrix x) -> IMatrix
    norm_2(DMatrix x) -> DMatrix
    norm_2(SX x) -> SX
    norm_2(MX x) -> MX



    >  Matrix< DataType > casadi::norm_2(const Matrix< DataType > &x)

    >  MX casadi::norm_2(const MX &x)
    ------------------------------------------------------------------------

    2-norm

    >  T casadi::norm_2(const std::vector< T > &x)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
    return _casadi_core.norm_2(*args)

def norm_1(*args):
    """
    norm_1(IMatrix x) -> IMatrix
    norm_1(DMatrix x) -> DMatrix
    norm_1(SX x) -> SX
    norm_1(MX x) -> MX



    >  Matrix< DataType > casadi::norm_1(const Matrix< DataType > &x)

    >  MX casadi::norm_1(const MX &x)
    ------------------------------------------------------------------------

    1-norm

    >  T casadi::norm_1(const std::vector< T > &x)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
    return _casadi_core.norm_1(*args)

def norm_inf(*args):
    """
    norm_inf(IMatrix x) -> IMatrix
    norm_inf(DMatrix x) -> DMatrix
    norm_inf(SX x) -> SX
    norm_inf(MX x) -> MX



    >  Matrix< DataType > casadi::norm_inf(const Matrix< DataType > &x)

    >  MX casadi::norm_inf(const MX &x)
    ------------------------------------------------------------------------

    Infinity-norm.

    >  T casadi::norm_inf(const std::vector< T > &x)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
    return _casadi_core.norm_inf(*args)

def transpose(*args):
    """
    transpose(Sparsity a) -> Sparsity
    transpose(IMatrix x) -> IMatrix
    transpose(DMatrix x) -> DMatrix
    transpose(SX x) -> SX
    transpose(MX x) -> MX



    >  Matrix< DataType > casadi::transpose(const Matrix< DataType > &x)
    ------------------------------------------------------------------------

    Transpose of a matrix.

    >  Sparsity casadi::transpose(const Sparsity &a)
    ------------------------------------------------------------------------

    Transpose the pattern.

    >  MX casadi::transpose(const MX &x)
    ------------------------------------------------------------------------

    Transpose an expression.


    """
    return _casadi_core.transpose(*args)

def mul(*args):
    """
    mul(Sparsity a, Sparsity b) -> Sparsity
    mul(SparsityVector s) -> Sparsity
    mul(IMatrix x, IMatrix y, Sparsity sp_z) -> IMatrix
    mul(IMatrixVector args) -> IMatrix
    mul(DMatrix x, DMatrix y, Sparsity sp_z) -> DMatrix
    mul(DMatrixVector args) -> DMatrix
    mul(SX x, SX y, Sparsity sp_z) -> SX
    mul(SXVector args) -> SX
    mul(MX x, MX y, Sparsity sp_z) -> MX
    mul(MXVector x) -> MX



    >  Matrix< DataType > casadi::mul(const Matrix< DataType > &x, const Matrix< DataType > &y, const Sparsity &sp_z=Sparsity())
    ------------------------------------------------------------------------

    Matrix product of two matrices.

    With optional sp_z you can specify the sparsity of the result A typical use
    case might be where the product is only constructed to inspect the trace of
    it. sp_z diagonal will be more efficient in that case.

    >  Matrix< DataType > casadi::mul(const std::vector< Matrix< DataType > > &args)
    ------------------------------------------------------------------------

    Matrix product of n matrices.

    >  Sparsity casadi::mul(const Sparsity &a, const Sparsity &b)
    ------------------------------------------------------------------------

    Get the sparsity resulting from a matrix multiplication.

    >  Sparsity casadi::mul(const std::vector< Sparsity > &s)
    ------------------------------------------------------------------------

    Get the sparsity resulting from a series of matrix multiplication.

    >  MX casadi::mul(const MX &x, const MX &y, const Sparsity &sp_z=Sparsity())
    ------------------------------------------------------------------------

    Take the matrix product of 2 MX objects.

    With optional sp_z you can specify the sparsity of the result A typical use
    case might be where the product is only constructed to inspect the trace of
    it. sp_z diagonal will be more efficient then.

    >  MX casadi::mul(const std::vector< MX > &x)
    ------------------------------------------------------------------------

    Take the matrix product of n MX objects.


    """
    return _casadi_core.mul(*args)

def inner_prod(*args):
    """
    inner_prod(IMatrix x, IMatrix y) -> IMatrix
    inner_prod(DMatrix x, DMatrix y) -> DMatrix
    inner_prod(SX x, SX y) -> SX
    inner_prod(MX x, MX y) -> MX



    >  Matrix< DataType > casadi::inner_prod(const Matrix< DataType > &x, const Matrix< DataType > &y)
    ------------------------------------------------------------------------

    Inner product of two matrices Equals.

    with x and y matrices of the same dimension

    >  MX casadi::inner_prod(const MX &x, const MX &y)
    ------------------------------------------------------------------------

    Take the inner product of two vectors Equals.

    with x and y vectors

    >  T casadi::inner_prod(const std::vector< T > &a, const std::vector< T > &b)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
    return _casadi_core.inner_prod(*args)

def outer_prod(*args):
    """
    outer_prod(IMatrix x, IMatrix y) -> IMatrix
    outer_prod(DMatrix x, DMatrix y) -> DMatrix
    outer_prod(SX x, SX y) -> SX
    outer_prod(MX x, MX y) -> MX



    >  Matrix< DataType > casadi::outer_prod(const Matrix< DataType > &x, const Matrix< DataType > &y)
    ------------------------------------------------------------------------

    Outer product of two vectors Equals.

    with x and y vectors

    >  MX casadi::outer_prod(const MX &x, const MX &y)
    ------------------------------------------------------------------------

    Take the outer product of two vectors Equals.

    with x and y vectors


    """
    return _casadi_core.outer_prod(*args)

def if_else(*args):
    """
    if_else(SX cond, SX if_true, SX if_false) -> SX
    if_else(MX cond, MX if_true, MX if_false) -> MX



    >  MX casadi::if_else(const MX &cond, const MX &if_true, const MX &if_false)
    ------------------------------------------------------------------------

    Branching on MX nodes Ternary operator, "cond ? if_true : if_false".

    >  SX casadi::if_else(const SX &cond, const SX &if_true, const SX &if_false)
    ------------------------------------------------------------------------

    Integrate f from a to b using Gaussian quadrature with n points.

    >  T casadi::if_else(const SXElement &cond, const T &if_true, const T &if_false)

    >  SX casadi::if_else(const SXElement &cond, const T &if_true, const T &if_false)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Expand the expression as a weighted sum (with constant weights)

    >  SXElement casadi::if_else(const SXElement &cond, const SXElement &if_true, const SXElement &if_false)
    ------------------------------------------------------------------------

    replaces the ternary conditional operator "?:", which cannot be overloaded


    """
    return _casadi_core.if_else(*args)

def reshape(*args):
    """
    reshape(Sparsity a, int nrow, int ncol) -> Sparsity
    reshape(IMatrix a, int nrow, int ncol) -> IMatrix
    reshape(IMatrix a, Pair_Int_Int rc) -> IMatrix
    reshape(IMatrix a, Sparsity sp) -> IMatrix
    reshape(DMatrix a, int nrow, int ncol) -> DMatrix
    reshape(DMatrix a, Pair_Int_Int rc) -> DMatrix
    reshape(DMatrix a, Sparsity sp) -> DMatrix
    reshape(SX a, int nrow, int ncol) -> SX
    reshape(SX a, Pair_Int_Int rc) -> SX
    reshape(SX a, Sparsity sp) -> SX
    reshape(MX x, Pair_Int_Int rc) -> MX
    reshape(MX x, Sparsity sp) -> MX



    >  Matrix< DataType > casadi::reshape(const Matrix< DataType > &a, int nrow, int ncol)

    >  Matrix< DataType > casadi::reshape(const Matrix< DataType > &a, std::pair< int, int > rc)

    >  Matrix< DataType > casadi::reshape(const Matrix< DataType > &a, const Sparsity &sp)
    ------------------------------------------------------------------------

    Transpose of a matrix.

    >  Sparsity casadi::reshape(const Sparsity &a, int nrow, int ncol)
    ------------------------------------------------------------------------

    Reshape the sparsity pattern keeping the relative location of the nonzeros.

    >  MX casadi::reshape(const MX &x, std::pair< int, int > rc)
    ------------------------------------------------------------------------

    Returns a reshaped version of the MX, dimensions as a vector.

    >  MX casadi::reshape(const MX &x, int nrow, int ncol)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Returns a reshaped version of the MX.

    >  MX casadi::reshape(const MX &x, const Sparsity &sp)
    ------------------------------------------------------------------------

    Reshape the MX.


    """
    return _casadi_core.reshape(*args)

def vec(*args):
    """
    vec(Sparsity a) -> Sparsity
    vec(IMatrix a) -> IMatrix
    vec(DMatrix a) -> DMatrix
    vec(SX a) -> SX
    vec(MX x) -> MX



    >  Matrix< DataType > casadi::vec(const Matrix< DataType > &a)
    ------------------------------------------------------------------------

    make a vector Reshapes/vectorizes the Matrix<DataType> such that the shape
    becomes (expr.numel(), 1). Columns are stacked on top of each other. Same as
    reshape(expr, expr.numel(), 1)

    a c b d  turns into

    a b c d

    >  Sparsity casadi::vec(const Sparsity &a)
    ------------------------------------------------------------------------

    Vectorize the pattern.

    >  MX casadi::vec(const MX &x)
    ------------------------------------------------------------------------

    Returns a vectorized version of the MX Same as reshape(x, x.numel(), 1)

    a c b d

    turns into

    a b c d


    """
    return _casadi_core.vec(*args)

def vecNZ(*args):
    """
    vecNZ(IMatrix a) -> IMatrix
    vecNZ(DMatrix a) -> DMatrix
    vecNZ(SX a) -> SX
    vecNZ(MX x) -> MX



    >  Matrix< DataType > casadi::vecNZ(const Matrix< DataType > &a)
    ------------------------------------------------------------------------

    Returns a flattened version of the Matrix, preserving only nonzeros.

    >  MX casadi::vecNZ(const MX &x)
    ------------------------------------------------------------------------

    Returns a vectorized version of the MX, preserving only nonzeros.


    """
    return _casadi_core.vecNZ(*args)

def unite(*args):
    """
    unite(IMatrix A, IMatrix B) -> IMatrix
    unite(DMatrix A, DMatrix B) -> DMatrix
    unite(SX A, SX B) -> SX
    unite(MX A, MX B) -> MX



    Unite two matrices no overlapping sparsity.


    """
    return _casadi_core.unite(*args)

def simplify(*args):
    """
    simplify(SXElement ex)
    simplify(SX ex)
    simplify(MX ex)



    >  void casadi::simplify(MX &ex)

    >  void casadi::simplify(SX &ex)
    ------------------------------------------------------------------------

    Simplify an expression.

    >  void casadi::simplify(SXElement &ex)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Simplify the expression: formulates the expression as and eliminates
    terms.


    """
    return _casadi_core.simplify(*args)

def trace(*args):
    """
    trace(IMatrix a) -> int
    trace(DMatrix a) -> double
    trace(SX a) -> SXElement
    trace(MX A) -> MX



    >  DataType casadi::trace(const Matrix< DataType > &a)
    ------------------------------------------------------------------------

    Transpose of a matrix.

    >  MX casadi::trace(const MX &A)
    ------------------------------------------------------------------------

    Matrix trace.


    """
    return _casadi_core.trace(*args)

def repmat(*args):
    """
    repmat(IMatrix A, int n, int m) -> IMatrix
    repmat(DMatrix A, int n, int m) -> DMatrix
    repmat(SX A, int n, int m) -> SX
    repmat(MX A, int n, int m) -> MX



    Repeat matrix A n times vertically and m times horizontally.


    """
    return _casadi_core.repmat(*args)

def dense(*args):
    """
    dense(IMatrix A) -> IMatrix
    dense(DMatrix A) -> DMatrix
    dense(SX A) -> SX
    dense(MX x) -> MX



    >  Matrix< DataType > casadi::dense(const Matrix< DataType > &A)
    ------------------------------------------------------------------------

    Make a matrix dense.

    >  MX casadi::dense(const MX &x)
    ------------------------------------------------------------------------

    create a clipped view into a matrix Create a sparse matrix from a dense
    matrix A, with sparsity pattern sp

    MX clip(const MX& A, const Sparsity& sp) { Join the sparsity patterns
    std::vector<int> mapping; Sparsity sp = A.sparsity().patternIntersection(sp,
    mapping);

    Split up the mapping std::vector<int> nzA, nzB;

    Copy sparsity for (int k=0; k<mapping.size(); ++k) { if (mapping[k]<0) {
    nzA.push_back(k); } else if (mapping[k]>0) { nzB.push_back(k); } else {
    throw CasadiException("Pattern intersection not empty"); } }

    Create mapping MX ret; ret.assignNode(new Mapping(sp)); ret->assign(A,
    range(nzA.size()), nzA); ret->assign(B, range(nzB.size()), nzB); return ret;

    }

    Make the matrix dense if not already


    """
    return _casadi_core.dense(*args)

def createParent(*args):
    """
    createParent(MXVector deps) -> MX
    createParent(MXVector deps) -> MX
    createParent(SparsityVector deps) -> MX



    >  MX casadi::createParent(std::vector< MX > &deps)
    ------------------------------------------------------------------------

    Create a parent MX on which all given MX's will depend.

    In some sense, this function is the inverse of

    Parameters:
    -----------

    deps:  Must all be symbolic matrices.

    >  MX casadi::createParent(const std::vector< Sparsity > &deps, std::vector< MX > &output_children)

    >  MX casadi::createParent(const std::vector< MX > &deps, std::vector< MX > &output_children)
    ------------------------------------------------------------------------

    Create a parent MX on which a bunch of MX's (sizes given as argument) will
    depend.


    """
    return _casadi_core.createParent(*args)

def countNodes(*args):
    """
    countNodes(SX A) -> int
    countNodes(MX A) -> int



    >  int casadi::countNodes(const MX &A)
    ------------------------------------------------------------------------

    Count number of nodes

    >  int casadi::countNodes(const SX &A)
    ------------------------------------------------------------------------

    Count number of nodes.


    """
    return _casadi_core.countNodes(*args)

def diag(*args):
    """
    diag(IMatrix A) -> IMatrix
    diag(DMatrix A) -> DMatrix
    diag(SX A) -> SX
    diag(MX x) -> MX



    >  Matrix< DataType > casadi::diag(const Matrix< DataType > &A)
    ------------------------------------------------------------------------

    Get the diagonal of a matrix or construct a diagonal When the input is
    square, the diagonal elements are returned. If the input is vector- like, a
    diagonal matrix is constructed with it.

    >  MX casadi::diag(const MX &x)
    ------------------------------------------------------------------------

    Get the diagonal of a matrix or construct a diagonal.

    When the input is square, the diagonal elements are returned. If the input
    is vector-like, a diagonal matrix is constructed with it.


    """
    return _casadi_core.diag(*args)

def blkdiag(*args):
    """
    blkdiag(SparsityVector v) -> Sparsity
    blkdiag(IMatrixVector A) -> IMatrix
    blkdiag(DMatrixVector A) -> DMatrix
    blkdiag(SXVector A) -> SX
    blkdiag(MXVector A) -> MX



    >  Matrix< DataType > casadi::blkdiag(const std::vector< Matrix< DataType > > &A)
    ------------------------------------------------------------------------

    Construct a matrix with given block on the diagonal.

    >  Sparsity casadi::blkdiag(const std::vector< Sparsity > &v)
    ------------------------------------------------------------------------

    Construct a Sparsity with given blocks on the diagonal.

    >  Sparsity casadi::blkdiag(const Sparsity &a, const Sparsity &b)
    ------------------------------------------------------------------------
    [INTERNAL] 
     Reshape the sparsity pattern keeping the relative location of the nonzeros.

    >  MX casadi::blkdiag(const std::vector< MX > &A)
    ------------------------------------------------------------------------

    Construct a matrix with given blocks on the diagonal.

    >  MX casadi::blkdiag(const MX &A, const MX &B)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Construct a matrix with given blocks on the diagonal.


    """
    return _casadi_core.blkdiag(*args)

def sumCols(*args):
    """
    sumCols(IMatrix x) -> IMatrix
    sumCols(DMatrix x) -> DMatrix
    sumCols(SX x) -> SX
    sumCols(MX x) -> MX



    Return a col-wise summation of elements.


    """
    return _casadi_core.sumCols(*args)

def sumRows(*args):
    """
    sumRows(IMatrix x) -> IMatrix
    sumRows(DMatrix x) -> DMatrix
    sumRows(SX x) -> SX
    sumRows(MX x) -> MX



    Return a row-wise summation of elements.


    """
    return _casadi_core.sumRows(*args)

def sumAll(*args):
    """
    sumAll(IMatrix x) -> IMatrix
    sumAll(DMatrix x) -> DMatrix
    sumAll(SX x) -> SX
    sumAll(MX x) -> MX



    Return summation of all elements.


    """
    return _casadi_core.sumAll(*args)

def polyval(*args):
    """
    polyval(IMatrix p, IMatrix x) -> IMatrix
    polyval(DMatrix p, DMatrix x) -> DMatrix
    polyval(SX p, SX x) -> SX
    polyval(MX p, MX x) -> MX



    Evaluate a polynomial with coefficients p in x.


    """
    return _casadi_core.polyval(*args)

def getOperatorRepresentation(*args):
    """
    getOperatorRepresentation(SXElement x, StringVector args) -> std::string
    getOperatorRepresentation(MX xb, StringVector args) -> std::string



    >  std::string casadi::getOperatorRepresentation(const MX &xb, const std::vector< std::string > &args)
    ------------------------------------------------------------------------

    Get a string representation for a binary MX, using custom arguments.

    >  std::string casadi::getOperatorRepresentation(const SXElement &x, const std::vector< std::string > &args)
    ------------------------------------------------------------------------

    Get a string representation for a binary SX, using custom arguments.


    """
    return _casadi_core.getOperatorRepresentation(*args)

def substitute(*args):
    """
    substitute(SX ex, SX v, SX vdef) -> SX
    substitute(SXVector ex, SXVector v, SXVector vdef) -> SXVector
    substitute(MX ex, MX v, MX vdef) -> MX
    substitute(MXVector ex, MXVector v, MXVector vdef) -> MXVector



    >  MX casadi::substitute(const MX &ex, const MX &v, const MX &vdef)

    >  SX casadi::substitute(const SX &ex, const SX &v, const SX &vdef)
    ------------------------------------------------------------------------

    Substitute variable v with expression vdef in an expression ex.

    >  std::vector< MX > casadi::substitute(const std::vector< MX > &ex, const std::vector< MX > &v, const std::vector< MX > &vdef)

    >  std::vector< SX > casadi::substitute(const std::vector< SX > &ex, const std::vector< SX > &v, const std::vector< SX > &vdef)
    ------------------------------------------------------------------------

    Substitute variable var with expression expr in multiple expressions.


    """
    return _casadi_core.substitute(*args)

def graph_substitute(*args):
    """
    graph_substitute(MX ex, MXVector v, MXVector vdef) -> MX
    graph_substitute(MXVector ex, MXVector v, MXVector vdef) -> MXVector



    >  MX casadi::graph_substitute(const MX &ex, const std::vector< MX > &v, const std::vector< MX > &vdef)
    ------------------------------------------------------------------------

    Substitute variable v with expression vdef in an expression ex, preserving
    nodes.

    >  std::vector< MX > casadi::graph_substitute(const std::vector< MX > &ex, const std::vector< MX > &v, const std::vector< MX > &vdef)
    ------------------------------------------------------------------------

    Substitute variable var with expression expr in multiple expressions,
    preserving nodes.


    """
    return _casadi_core.graph_substitute(*args)

def substituteInPlace(*args):
    """
    substituteInPlace(SX v, SX vdef, bool reverse=False)
    substituteInPlace(SX v, SX vdef, SXVector ex, bool reverse=False)
    substituteInPlace(SXVector v, SXVector vdef, SXVector ex, bool reverse=False)
    substituteInPlace(MXVector v, MXVector INOUT, bool reverse=False)
    substituteInPlace(MXVector v, MXVector arg2, MXVector arg3, bool reverse=False)



    >  void casadi::substituteInPlace(const std::vector< MX > &v, std::vector< MX > &vdef, bool reverse=false)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Inplace substitution Substitute variables v out of the expressions
    vdef sequentially.

    >  void casadi::substituteInPlace(const std::vector< MX > &v, std::vector< MX > &vdef, std::vector< MX > &ex, bool reverse=false)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Inplace substitution with piggyback expressions Substitute variables v
    out of the expressions vdef sequentially, as well as out of a number
    of other expressions piggyback.

    >  void casadi::substituteInPlace(const SX &v, SX &vdef, bool reverse=false)
    ------------------------------------------------------------------------

    Substitute variable var out of or into an expression expr.

    >  void casadi::substituteInPlace(const SX &v, SX &vdef, std::vector< SX > &ex, bool reverse=false)
    ------------------------------------------------------------------------

    Substitute variable var out of or into an expression expr, with an arbitrary
    number of other expressions piggyback.

    >  void casadi::substituteInPlace(const std::vector< SX > &v, std::vector< SX > &vdef, std::vector< SX > &ex, bool reverse=false)
    ------------------------------------------------------------------------

    Substitute variable var out of or into an expression expr, with an arbitrary
    number of other expressions piggyback (vector version)


    """
    return _casadi_core.substituteInPlace(*args)

def extractShared(*args):
    """
    extractShared(SXElementVector ex, SXElementVector v, SXElementVector vdef, std::string const & v_prefix, std::string const & v_suffix)
    extractShared(MXVector ex, MXVector v, MXVector vdef, std::string const & v_prefix, std::string const & v_suffix)



    Extract shared subexpressions from an set of expressions.


    """
    return _casadi_core.extractShared(*args)

def printCompact(*args):
    """
    printCompact(SX ex, std::ostream & stream)
    printCompact(MX ex, std::ostream & stream)



    Print compact, introducing new variables for shared subexpressions.


    """
    return _casadi_core.printCompact(*args)

def jacobian(*args):
    """
    jacobian(SX ex, SX arg) -> SX
    jacobian(MX ex, MX arg) -> MX



    >  MX casadi::jacobian(const MX &ex, const MX &arg)
    ------------------------------------------------------------------------

    Calculate jacobian via source code transformation.

    Uses casadi::MXFunction::jac

    >  SX casadi::jacobian(const SX &ex, const SX &arg)
    ------------------------------------------------------------------------

    Calculate jacobian via source code transformation.

    Uses casadi::SXFunction::jac


    """
    return _casadi_core.jacobian(*args)

def gradient(*args):
    """
    gradient(SX ex, SX arg) -> SX
    gradient(MX ex, MX arg) -> MX



    >  MX casadi::gradient(const MX &ex, const MX &arg)
    ------------------------------------------------------------------------

    split horizontally, retaining groups of cols

    Parameters:
    -----------

    output_offset:  List of all start cols for each group the last col group
    will run to the end.

    horzcat(horzsplit(x, ...)) = x

    >  SX casadi::gradient(const SX &ex, const SX &arg)
    ------------------------------------------------------------------------

    Integrate f from a to b using Gaussian quadrature with n points.


    """
    return _casadi_core.gradient(*args)

def tangent(*args):
    """
    tangent(SX ex, SX arg) -> SX
    tangent(MX ex, MX arg) -> MX



    >  MX casadi::tangent(const MX &ex, const MX &arg)
    ------------------------------------------------------------------------

    split horizontally, retaining groups of cols

    Parameters:
    -----------

    output_offset:  List of all start cols for each group the last col group
    will run to the end.

    horzcat(horzsplit(x, ...)) = x

    >  SX casadi::tangent(const SX &ex, const SX &arg)
    ------------------------------------------------------------------------

    Integrate f from a to b using Gaussian quadrature with n points.


    """
    return _casadi_core.tangent(*args)

def nullspace(*args):
    """
    nullspace(IMatrix A) -> IMatrix
    nullspace(DMatrix A) -> DMatrix
    nullspace(SX A) -> SX
    nullspace(MX A) -> MX



    Computes the nullspace of a matrix A.

    Finds Z m-by-(m-n) such that AZ = 0 with A n-by-m with m > n

    Assumes A is full rank

    Inspired by Numerical Methods in Scientific Computing by Ake Bjorck


    """
    return _casadi_core.nullspace(*args)

def det(*args):
    """
    det(IMatrix a) -> int
    det(DMatrix a) -> double
    det(SX a) -> SXElement
    det(MX A) -> MX



    >  DataType casadi::det(const Matrix< DataType > &a)
    ------------------------------------------------------------------------

    Transpose of a matrix.

    >  MX casadi::det(const MX &A)
    ------------------------------------------------------------------------

    Matrix determinant (experimental)


    """
    return _casadi_core.det(*args)

def inv(*args):
    """
    inv(IMatrix a) -> IMatrix
    inv(DMatrix a) -> DMatrix
    inv(SX a) -> SX
    inv(MX A) -> MX



    >  Matrix< DataType > casadi::inv(const Matrix< DataType > &a)
    ------------------------------------------------------------------------

    Transpose of a matrix.

    >  MX casadi::inv(const MX &A)
    ------------------------------------------------------------------------

    Matrix inverse (experimental)


    """
    return _casadi_core.inv(*args)

def getSymbols(*args):
    """
    getSymbols(SX e) -> SXElementVector
    getSymbols(MX e) -> MXVector
    getSymbols(MXVector e) -> MXVector



    >  std::vector< SXElement > casadi::getSymbols(const SX &e)
    ------------------------------------------------------------------------

    Get all symbols contained in the supplied expression Get all symbols on
    which the supplied expression depends.

    See:   SXFunction::getFree()

    >  std::vector< MX > casadi::getSymbols(const MX &e)

    >  std::vector< MX > casadi::getSymbols(const std::vector< MX > &e)
    ------------------------------------------------------------------------

    Get all symbols contained in the supplied expression Get all symbols on
    which the supplied expression depends.

    See:   MXFunction::getFree()


    """
    return _casadi_core.getSymbols(*args)

def dependsOn(*args):
    """
    dependsOn(SX f, SX arg) -> bool
    dependsOn(MX ex, MXVector arg) -> bool



    >  bool casadi::dependsOn(const SX &f, const SX &arg)
    ------------------------------------------------------------------------

    Check if expression depends on the argument The argument must be symbolic.

    >  bool casadi::dependsOn(const MX &ex, const std::vector< MX > &arg)
    ------------------------------------------------------------------------

    Check if expression depends on any of the arguments The arguments must be
    symbolic.


    """
    return _casadi_core.dependsOn(*args)

def matrix_expand(*args):
    """
    matrix_expand(MX e, MXVector boundary) -> MX
    matrix_expand(MXVector e, MXVector boundary) -> MXVector



    Expand MX graph to SXFunction call.

    Expand the given expression e, optionally supplying expressions contained in
    it at which expansion should stop.


    """
    return _casadi_core.matrix_expand(*args)

def kron(*args):
    """
    kron(IMatrix a, IMatrix b) -> IMatrix
    kron(DMatrix a, DMatrix b) -> DMatrix
    kron(SX a, SX b) -> SX
    kron(MX a, MX b) -> MX



    Kronecker tensor product.

    Creates a block matrix in which each element (i, j) is a_ij*b


    """
    return _casadi_core.kron(*args)

def solve(*args):
    """
    solve(DMatrix A, DMatrix b, std::string const & lsolver, Dictionary dict) -> DMatrix
    solve(DMatrix A, DMatrix b, std::string const & lsolver) -> DMatrix
    solve(IMatrix A, IMatrix b) -> IMatrix
    solve(DMatrix A, DMatrix b) -> DMatrix
    solve(SX A, SX b) -> SX
    solve(MX A, MX b, std::string const & lsolver, Dictionary dict) -> MX
    solve(MX A, MX b, std::string const & lsolver) -> MX
    solve(MX A, MX b) -> MX



    >  Matrix< double > casadi::solve(const Matrix< double > &A, const Matrix< double > &b, const std::string &lsolver, const Dictionary &dict=Dictionary())

    >  MX casadi::solve(const MX &A, const MX &b, const std::string &lsolver="symbolicqr", const Dictionary &dict=Dictionary())
    ------------------------------------------------------------------------

    Solve a system of equations: A*x = b.

    >  Matrix< DataType > casadi::solve(const Matrix< DataType > &A, const Matrix< DataType > &b)
    ------------------------------------------------------------------------

    Solve a system of equations: A*x = b The solve routine works similar to
    Matlab's backslash when A is square and nonsingular. The algorithm used is
    the following:

    A simple forward or backward substitution if A is upper or lower triangular

    If the linear system is at most 3-by-3, form the inverse via minor expansion
    and multiply

    Permute the variables and equations as to get a (structurally) nonzero
    diagonal, then perform a QR factorization without pivoting and solve the
    factorized system.

    Note 1: If there are entries of the linear system known to be zero, these
    will be removed. Elements that are very small, or will evaluate to be zero,
    can still cause numerical errors, due to the lack of pivoting (which is not
    possible since cannot compare the size of entries)

    Note 2: When permuting the linear system, a BLT (block lower triangular)
    transformation is formed. Only the permutation part of this is however used.
    An improvement would be to solve block-by-block if there are multiple BLT
    blocks.


    """
    return _casadi_core.solve(*args)

def pinv(*args):
    """
    pinv(DMatrix A, std::string const & lsolver, Dictionary dict) -> DMatrix
    pinv(IMatrix A) -> IMatrix
    pinv(DMatrix A) -> DMatrix
    pinv(SX A) -> SX
    pinv(MX A, std::string const & lsolver, Dictionary dict) -> MX



    >  Matrix< double > casadi::pinv(const Matrix< double > &A, const std::string &lsolver, const Dictionary &dict=Dictionary())

    >  MX casadi::pinv(const MX &A, const std::string &lsolver, const Dictionary &dict=Dictionary())
    ------------------------------------------------------------------------

    Computes the Moore-Penrose pseudo-inverse.

    If the matrix A is fat (size1>size2), mul(A, pinv(A)) is unity. If the
    matrix A is slender (size2<size1), mul(pinv(A), A) is unity.

    >  Matrix< DataType > casadi::pinv(const Matrix< DataType > &A)
    ------------------------------------------------------------------------

    Computes the Moore-Penrose pseudo-inverse.

    If the matrix A is fat (size2>size1), mul(A, pinv(A)) is unity. If the
    matrix A is slender (size1<size2), mul(pinv(A), A) is unity.


    """
    return _casadi_core.pinv(*args)
class Pair_MX_MXVector(_object):
    """Proxy of C++ std::pair<(casadi::MX,std::vector<(casadi::MX)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_MX_MXVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_MX_MXVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(casadi::MX,std::vector<(casadi::MX)>)> self) -> Pair_MX_MXVector
        __init__(std::pair<(casadi::MX,std::vector<(casadi::MX)>)> self, MX first, MXVector second) -> Pair_MX_MXVector
        __init__(std::pair<(casadi::MX,std::vector<(casadi::MX)>)> self, Pair_MX_MXVector p) -> Pair_MX_MXVector
        """
        this = _casadi_core.new_Pair_MX_MXVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_MX_MXVector_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_MX_MXVector_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_MX_MXVector_first_get, _casadi_core.Pair_MX_MXVector_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_MX_MXVector_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_MX_MXVector_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_MX_MXVector_second_get, _casadi_core.Pair_MX_MXVector_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_MX_MXVector
Pair_MX_MXVector_swigregister = _casadi_core.Pair_MX_MXVector_swigregister
Pair_MX_MXVector_swigregister(Pair_MX_MXVector)


def attach_return_type(f,t):
  if not(hasattr(f,'func_annotations')):
    f.func_annotations = {}
  if not(isinstance(getattr(f,'func_annotations'),dict)):
    raise Exception("Cannot annotate this python Method to be a sparsitygenerator. Method has func_annotations attribute with unknown type.")
  f.func_annotations["return"] = t
  return f

def pyderivativegenerator(f):
  return attach_return_type(f,Function)

def pyevaluate(f):
  return attach_return_type(f,None)

def pycallback(f):
  return attach_return_type(f,int)


def pyfunction(inputs,outputs):
  def wrap(f):

    @pyevaluate
    def fcustom(f2):
      res = f([f2.getInput(i) for i in range(f2.getNumInputs())])
      if not isinstance(res,list):
        res = [res]
      for i in range(f2.getNumOutputs()):
        f2.setOutput(res[i],i)
    Fun = CustomFunction(fcustom,inputs,outputs)
    Fun.setOption("name","CustomFunction")
    return Fun
  return wrap

def PyFunction(obj,inputs,outputs):
    @pyevaluate
    def fcustom(f):
      obj.evaluate([f.input(i) for i in range(f.getNumInputs())],[f.output(i) for i in range(f.getNumOutputs())])

    Fun = CustomFunction(fcustom,inputs,outputs)
    Fun.setOption("name","CustomFunction")
    if hasattr(obj,'getDerivative'):
      @pyderivativegenerator
      def derivativewrap(f,nfwd,nadj):
        return obj.getDerivative(f,nfwd,nadj)
      Fun.setOption("derivative_generator",derivativewrap)

    elif hasattr(obj,'fwd') or hasattr(obj,'adj'):
      @pyderivativegenerator
      def derivativewrap(f,nfwd,nadj):
        num_in = f.getNumInputs()
        num_out = f.getNumOutputs()

        @pyevaluate
        def der(f2):
          all_inputs = [f2.input(i) for i in range(f2.getNumInputs())]
          all_outputs = [f2.output(i) for i in range(f2.getNumOutputs())]
          inputs=all_inputs[:num_in]
          outputs=all_outputs[:num_out]
          fwd_seeds=zip(*[iter(all_inputs[num_in:num_in*(nfwd+1)])]*num_in)
          fwd_sens=zip(*[iter(all_outputs[num_out:num_out*(nfwd+1)])]*num_out)
          adj_seeds=zip(*[iter(all_inputs[num_in*(nfwd+1):])]*num_out)
          adj_sens=zip(*[iter(all_outputs[num_out*(nfwd+1):])]*num_in)
          if hasattr(obj,'fwd') and nfwd>0:
            obj.fwd(inputs,outputs,fwd_seeds,fwd_sens)
          if hasattr(obj,'adj') and nadj>0:
            obj.adj(inputs,outputs,adj_seeds,adj_sens)

        DerFun = CustomFunction(der,inputs+nfwd*inputs+nadj*outputs,outputs+nfwd*outputs+nadj*inputs)
        DerFun.setOption("name","CustomFunction_derivative")
        DerFun.init()
        return DerFun

      Fun.setOption("derivative_generator",derivativewrap)

    if not(hasattr(obj,'getDerivative')) and hasattr(obj,'fwd') and not hasattr(obj,'adj'):
      Fun.setOption("ad_mode","forward")
    if not(hasattr(obj,'getDerivative')) and not hasattr(obj,'fwd') and hasattr(obj,'adj'):
      Fun.setOption("ad_mode","reverse")
    return Fun


class IOScheme(SharedObject):
    """


    Class with mapping between names and indices.

    Joris Gillis

    C++ includes: io_scheme.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOScheme, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOScheme, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.IOScheme_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def name(self, *args):
        """
        name(IOScheme self) -> std::string



        Name of the scheme.


        """
        return _casadi_core.IOScheme_name(self, *args)


    def entryNames(self, *args):
        """
        entryNames(IOScheme self) -> std::string



        List available entries.


        """
        return _casadi_core.IOScheme_entryNames(self, *args)


    def index(self, *args):
        """
        index(IOScheme self, std::string const & name) -> int



        Get index by entry name.


        """
        return _casadi_core.IOScheme_index(self, *args)


    def size(self, *args):
        """
        size(IOScheme self) -> int



        Number of entries.


        """
        return _casadi_core.IOScheme_size(self, *args)


    def entry(self, *args):
        """
        entry(IOScheme self, int i) -> std::string



        Get the entry name by index.


        """
        return _casadi_core.IOScheme_entry(self, *args)


    def entryLabel(self, *args):
        """
        entryLabel(IOScheme self, int i) -> std::string



        Get the entry label by index If scheme is unknown, returns the index as a
        string.


        """
        return _casadi_core.IOScheme_entryLabel(self, *args)


    def entryEnum(self, *args):
        """
        entryEnum(IOScheme self, int i) -> std::string



        Get the entry enum name by index.


        """
        return _casadi_core.IOScheme_entryEnum(self, *args)


    def describeInput(self, *args):
        """
        describeInput(IOScheme self, int i) -> std::string



        Describe the index as an input.


        """
        return _casadi_core.IOScheme_describeInput(self, *args)


    def describeOutput(self, *args):
        """
        describeOutput(IOScheme self, int i) -> std::string



        Describe the index as an output.


        """
        return _casadi_core.IOScheme_describeOutput(self, *args)


    def describe(self, *args):
        """
        describe(IOScheme self, int i) -> std::string



        Describe the index.


        """
        return _casadi_core.IOScheme_describe(self, *args)


    def known(self, *args):
        """
        known(IOScheme self) -> bool



        Check whether the scheme is known.


        """
        return _casadi_core.IOScheme_known(self, *args)


    def compatibleSize(self, *args):
        """
        compatibleSize(IOScheme self, int size) -> int



        Check whether this scheme is compatible with the given size.


        """
        return _casadi_core.IOScheme_compatibleSize(self, *args)


    def __call__original__(self, *args):
        """
        __call__original__(IOScheme self, SparsityVector arg_m, StringVector arg_s) -> SparsityVector
        __call__original__(IOScheme self, StringVector arg_s, SparsityVector arg_m) -> IOSchemeVectorSparsity
        __call__original__(IOScheme self, MXVector arg_m, StringVector arg_s) -> MXVector
        __call__original__(IOScheme self, StringVector arg_s, MXVector arg_m) -> IOSchemeVectorMX
        __call__original__(IOScheme self, SXVector arg_m, StringVector arg_s) -> SXVector
        __call__original__(IOScheme self, StringVector arg_s, SXVector arg_m) -> IOSchemeVectorSX
        __call__original__(IOScheme self, DMatrixVector arg_m, StringVector arg_s) -> DMatrixVector
        __call__original__(IOScheme self, StringVector arg_s, DMatrixVector arg_m) -> IOSchemeVectorD
        """
        return _casadi_core.IOScheme___call__original__(self, *args)


    def __call__(self,*dummy,**kwargs):
      if len(dummy)>1: return self.__call__original__(dummy[0],dummy[1:])
      return self.__call__original__(kwargs.keys(),kwargs.values())


    def __init__(self, *args):
        """
        __init__(casadi::IOScheme self) -> IOScheme
        __init__(casadi::IOScheme self, casadi::InputOutputScheme scheme) -> IOScheme
        __init__(casadi::IOScheme self, StringVector entries, StringVector descriptions) -> IOScheme
        __init__(casadi::IOScheme self, IOScheme other) -> IOScheme



        >  casadi::IOScheme::IOScheme()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::IOScheme::IOScheme(InputOutputScheme scheme)
        ------------------------------------------------------------------------

        Constructor with enum.

        >  casadi::IOScheme::IOScheme(const std::vector< std::string > &entries, const std::vector< std::string > &descriptions=std::vector< std::string >())
        ------------------------------------------------------------------------

        Constructor with entry names.


        """
        this = _casadi_core.new_IOScheme(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOScheme
IOScheme_swigregister = _casadi_core.IOScheme_swigregister
IOScheme_swigregister(IOScheme)

def IOScheme_testCast(*args):
    """IOScheme_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.IOScheme_testCast(*args)

class IOInterfaceFunction(_object):
    """


    Interface for accessing input and output data structures.

    Joel Andersson

    C++ includes: io_interface.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOInterfaceFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IOInterfaceFunction, name)
    __repr__ = _swig_repr

    def input(self, *args):
        """
        input(IOInterfaceFunction self, int iind=0) -> DMatrix
        input(IOInterfaceFunction self, std::string const & iname) -> DMatrix



        [UNSAFE] Obtain reference to inputs  getInput, setInput

        Access input argument


        """
        return _casadi_core.IOInterfaceFunction_input(self, *args)


    def inputRef(self, *args):
        """
        inputRef(IOInterfaceFunction self, int iind=0) -> DMatrix
        inputRef(IOInterfaceFunction self, std::string const & iname) -> DMatrix



        [UNSAFE] Obtain reference to inputs  getInput, setInput

        Access input argument


        """
        return _casadi_core.IOInterfaceFunction_inputRef(self, *args)


    def output(self, *args):
        """
        output(IOInterfaceFunction self, int oind=0) -> DMatrix
        output(IOInterfaceFunction self, std::string const & oname) -> DMatrix



        [UNSAFE] Obtain reference to outputs  getOutput, getOutput

        Access output argument


        """
        return _casadi_core.IOInterfaceFunction_output(self, *args)


    def outputRef(self, *args):
        """
        outputRef(IOInterfaceFunction self, int oind=0) -> DMatrix
        outputRef(IOInterfaceFunction self, std::string const & oname) -> DMatrix



        [UNSAFE] Obtain reference to outputs  getOutput, getOutput

        Access output argument


        """
        return _casadi_core.IOInterfaceFunction_outputRef(self, *args)


    def getNumInputs(self, *args):
        """
        getNumInputs(IOInterfaceFunction self) -> int



        Get the number of function inputs.


        """
        return _casadi_core.IOInterfaceFunction_getNumInputs(self, *args)


    def getNumOutputs(self, *args):
        """
        getNumOutputs(IOInterfaceFunction self) -> int



        Get the number of function outputs.


        """
        return _casadi_core.IOInterfaceFunction_getNumOutputs(self, *args)


    def setNumInputs(self, *args):
        """
        setNumInputs(IOInterfaceFunction self, int num_in)



        Set the number of function inputs.


        """
        return _casadi_core.IOInterfaceFunction_setNumInputs(self, *args)


    def setNumOutputs(self, *args):
        """
        setNumOutputs(IOInterfaceFunction self, int num_out)



        Set the number of function outputs.


        """
        return _casadi_core.IOInterfaceFunction_setNumOutputs(self, *args)


    def setInputScheme(self, *args):
        """
        setInputScheme(IOInterfaceFunction self, IOScheme scheme)



        Set input scheme.


        """
        return _casadi_core.IOInterfaceFunction_setInputScheme(self, *args)


    def setOutputScheme(self, *args):
        """
        setOutputScheme(IOInterfaceFunction self, IOScheme scheme)



        Set output scheme.


        """
        return _casadi_core.IOInterfaceFunction_setOutputScheme(self, *args)


    def getInputScheme(self, *args):
        """
        getInputScheme(IOInterfaceFunction self) -> IOScheme



        Get input scheme.


        """
        return _casadi_core.IOInterfaceFunction_getInputScheme(self, *args)


    def getOutputScheme(self, *args):
        """
        getOutputScheme(IOInterfaceFunction self) -> IOScheme



        Get output scheme.


        """
        return _casadi_core.IOInterfaceFunction_getOutputScheme(self, *args)


    def inputSchemeEntry(self, *args):
        """
        inputSchemeEntry(IOInterfaceFunction self, std::string const & name) -> int

        [INTERNAL]
        Find the index for a string describing a particular entry of an input
        scheme.

        example: schemeEntry("x_opt") -> returns NLP_SOLVER_X if FunctionInternal
        adheres to SCHEME_NLPINput


        """
        return _casadi_core.IOInterfaceFunction_inputSchemeEntry(self, *args)


    def outputSchemeEntry(self, *args):
        """
        outputSchemeEntry(IOInterfaceFunction self, std::string const & name) -> int

        [INTERNAL]
        Find the index for a string describing a particular entry of an output
        scheme.

        example: schemeEntry("x_opt") -> returns NLP_SOLVER_X if FunctionInternal
        adheres to SCHEME_NLPINput


        """
        return _casadi_core.IOInterfaceFunction_outputSchemeEntry(self, *args)


    def schemeEntry(self, *args):
        """
        schemeEntry(IOInterfaceFunction self, IOScheme scheme, std::string const & name, bool input) -> int

        [INTERNAL]  Find
        the index for a string describing a particular entry of a scheme.

        example: schemeEntry("x_opt") -> returns NLP_SOLVER_X if FunctionInternal
        adheres to SCHEME_NLPINput


        """
        return _casadi_core.IOInterfaceFunction_schemeEntry(self, *args)


    def getInput(self, *args):
        """
        getInput(IOInterfaceFunction self, int iind=0) -> DMatrix
        getInput(IOInterfaceFunction self, std::string const & iname) -> DMatrix



        >  Matrix<double> casadi::IOInterface< Derived >::getInput(int iind=0) const 
        ------------------------------------------------------------------------

        Get an input by index.

        Parameters:
        -----------

        iind:  index within the range [0.. getNumInputs()-1]

        >  Matrix<double> casadi::IOInterface< Derived >::getInput(const std::string &iname) const 
        ------------------------------------------------------------------------

        Get an input by name.

        Parameters:
        -----------

        iname:  input name. Only allowed when an input scheme is set.

        >  void casadi::IOInterface< Derived >::getInput(T val, int iind=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get an input by index.

        Parameters:
        -----------

        val:  can be double&, std::vector<double>&, Matrix<double>&, double *

        iind:  index within the range [0.. getNumInputs()-1]

        >  void casadi::IOInterface< Derived >::getInput(T val, const std::string &iname)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get an input by name.

        Parameters:
        -----------

        val:  can be double&, std::vector<double>&, Matrix<double>&, double *

        iname:  input name. Only allowed when an input scheme is set.


        """
        return _casadi_core.IOInterfaceFunction_getInput(self, *args)


    def getOutput(self, *args):
        """
        getOutput(IOInterfaceFunction self, int oind=0) -> DMatrix
        getOutput(IOInterfaceFunction self, std::string const & oname) -> DMatrix



        >  Matrix<double> casadi::IOInterface< Derived >::getOutput(int oind=0) const 
        ------------------------------------------------------------------------

        Get an output by index.

        Parameters:
        -----------

        oind:  index within the range [0.. getNumOutputs()-1]

        >  Matrix<double> casadi::IOInterface< Derived >::getOutput(const std::string &oname) const 
        ------------------------------------------------------------------------

        Get an output by name.

        Parameters:
        -----------

        oname:  output name. Only allowed when an output scheme is set.

        >  void casadi::IOInterface< Derived >::getOutput(T val, int oind=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get an output by index.

        Parameters:
        -----------

        val:  can be double&, std::vector<double>&, Matrix<double>&, double *

        oind:  index within the range [0.. getNumOutputs()-1]

        >  void casadi::IOInterface< Derived >::getOutput(T val, const std::string &oname)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Get an output by name.

        Parameters:
        -----------

        val:  can be double&, std::vector<double>&, Matrix<double>&, double *

        oname:  output name. Only allowed when an output scheme is set.


        """
        return _casadi_core.IOInterfaceFunction_getOutput(self, *args)


    def setInput(self, *args):
        """
        setInput(IOInterfaceFunction self, double val, int iind=0)
        setInput(IOInterfaceFunction self, double val, std::string const & iname)
        setInput(IOInterfaceFunction self, DVector val, int iind=0)
        setInput(IOInterfaceFunction self, DVector val, std::string const & iname)
        setInput(IOInterfaceFunction self, DMatrix val, int iind=0)
        setInput(IOInterfaceFunction self, DMatrix val, std::string const & iname)



        >  void casadi::IOInterface< Derived >::setInput(T val, int iind=0)
        ------------------------------------------------------------------------

        Set an input by index.

        Parameters:
        -----------

        val:  can be double, const std::vector<double>&, const Matrix<double>&,
        double *

        iind:  index within the range [0.. getNumInputs()-1]

        >  void casadi::IOInterface< Derived >::setInput(T val, const std::string &iname)
        ------------------------------------------------------------------------

        Set an input by name.

        Parameters:
        -----------

        val:  can be double, const std::vector<double>&, const Matrix<double>&,
        double *

        iname:  input name. Only allowed when an input scheme is set.


        """
        return _casadi_core.IOInterfaceFunction_setInput(self, *args)


    def setOutput(self, *args):
        """
        setOutput(IOInterfaceFunction self, double val, int oind=0)
        setOutput(IOInterfaceFunction self, double val, std::string const & oname)
        setOutput(IOInterfaceFunction self, DVector val, int oind=0)
        setOutput(IOInterfaceFunction self, DVector val, std::string const & oname)
        setOutput(IOInterfaceFunction self, DMatrix val, int oind=0)
        setOutput(IOInterfaceFunction self, DMatrix val, std::string const & oname)



        >  void casadi::IOInterface< Derived >::setOutput(T val, int oind=0)
        ------------------------------------------------------------------------

        Set an output by index.

        Parameters:
        -----------

        val:  can be double, const std::vector<double>&, const Matrix<double>&,
        double *

        oind:  index within the range [0.. getNumOutputs()-1]

        >  void casadi::IOInterface< Derived >::setOutput(T val, const std::string &oname)
        ------------------------------------------------------------------------

        Set an output by name.

        Parameters:
        -----------

        val:  can be double, const std::vector<double>&, const Matrix<double>&,
        double *

        oname:  output name. Only allowed when an output scheme is set.


        """
        return _casadi_core.IOInterfaceFunction_setOutput(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::IOInterface<(casadi::Function)> self) -> IOInterfaceFunction
        __init__(casadi::IOInterface<(casadi::Function)> self, IOInterfaceFunction other) -> IOInterfaceFunction
        """
        this = _casadi_core.new_IOInterfaceFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOInterfaceFunction
IOInterfaceFunction_swigregister = _casadi_core.IOInterfaceFunction_swigregister
IOInterfaceFunction_swigregister(IOInterfaceFunction)

class IOSchemeVectorMX(PrintIOSchemeVectorMX):
    """


    A vector container with associated IOScheme A class.

    C++ includes: io_scheme_vector.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintIOSchemeVectorMX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOSchemeVectorMX, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintIOSchemeVectorMX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOSchemeVectorMX, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _casadi_core.IOSchemeVectorMX_data_set
    __swig_getmethods__["data"] = _casadi_core.IOSchemeVectorMX_data_get
    if _newclass:
        data = _swig_property(_casadi_core.IOSchemeVectorMX_data_get, _casadi_core.IOSchemeVectorMX_data_set)
    __swig_setmethods__["scheme"] = _casadi_core.IOSchemeVectorMX_scheme_set
    __swig_getmethods__["scheme"] = _casadi_core.IOSchemeVectorMX_scheme_get
    if _newclass:
        scheme = _swig_property(_casadi_core.IOSchemeVectorMX_scheme_get, _casadi_core.IOSchemeVectorMX_scheme_set)

    def __getitem__(self, *args):
        """
        __getitem__(IOSchemeVectorMX self, int i) -> MX
        __getitem__(IOSchemeVectorMX self, std::string const & name) -> MX
        """
        return _casadi_core.IOSchemeVectorMX___getitem__(self, *args)


    def __len__(self, *args):
        """__len__(IOSchemeVectorMX self) -> int"""
        return _casadi_core.IOSchemeVectorMX___len__(self, *args)


    def vector(self, *args):
        """vector(IOSchemeVectorMX self) -> MXVector"""
        return _casadi_core.IOSchemeVectorMX_vector(self, *args)


    def __iter__(self):
      return iter(self.data)


    def __init__(self, *args):
        """
        __init__(casadi::IOSchemeVector<(casadi::MX)> self, MXVector d, IOScheme s) -> IOSchemeVectorMX
        __init__(casadi::IOSchemeVector<(casadi::MX)> self, IOSchemeVectorMX other) -> IOSchemeVectorMX
        """
        this = _casadi_core.new_IOSchemeVectorMX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOSchemeVectorMX
IOSchemeVectorMX_swigregister = _casadi_core.IOSchemeVectorMX_swigregister
IOSchemeVectorMX_swigregister(IOSchemeVectorMX)

class IOSchemeVectorSX(PrintIOSchemeVectorSX):
    """


    A vector container with associated IOScheme A class.

    C++ includes: io_scheme_vector.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintIOSchemeVectorSX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOSchemeVectorSX, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintIOSchemeVectorSX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOSchemeVectorSX, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _casadi_core.IOSchemeVectorSX_data_set
    __swig_getmethods__["data"] = _casadi_core.IOSchemeVectorSX_data_get
    if _newclass:
        data = _swig_property(_casadi_core.IOSchemeVectorSX_data_get, _casadi_core.IOSchemeVectorSX_data_set)
    __swig_setmethods__["scheme"] = _casadi_core.IOSchemeVectorSX_scheme_set
    __swig_getmethods__["scheme"] = _casadi_core.IOSchemeVectorSX_scheme_get
    if _newclass:
        scheme = _swig_property(_casadi_core.IOSchemeVectorSX_scheme_get, _casadi_core.IOSchemeVectorSX_scheme_set)

    def __getitem__(self, *args):
        """
        __getitem__(IOSchemeVectorSX self, int i) -> SX
        __getitem__(IOSchemeVectorSX self, std::string const & name) -> SX
        """
        return _casadi_core.IOSchemeVectorSX___getitem__(self, *args)


    def __len__(self, *args):
        """__len__(IOSchemeVectorSX self) -> int"""
        return _casadi_core.IOSchemeVectorSX___len__(self, *args)


    def vector(self, *args):
        """vector(IOSchemeVectorSX self) -> SXVector"""
        return _casadi_core.IOSchemeVectorSX_vector(self, *args)


    def __iter__(self):
      return iter(self.data)


    def __init__(self, *args):
        """
        __init__(casadi::IOSchemeVector<(casadi::Matrix<(casadi::SXElement)>)> self, SXVector d, IOScheme s) -> IOSchemeVectorSX
        __init__(casadi::IOSchemeVector<(casadi::Matrix<(casadi::SXElement)>)> self, IOSchemeVectorSX other) -> IOSchemeVectorSX
        """
        this = _casadi_core.new_IOSchemeVectorSX(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOSchemeVectorSX
IOSchemeVectorSX_swigregister = _casadi_core.IOSchemeVectorSX_swigregister
IOSchemeVectorSX_swigregister(IOSchemeVectorSX)

class IOSchemeVectorD(PrintIOSchemeVectorD):
    """


    A vector container with associated IOScheme A class.

    C++ includes: io_scheme_vector.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintIOSchemeVectorD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOSchemeVectorD, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintIOSchemeVectorD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOSchemeVectorD, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _casadi_core.IOSchemeVectorD_data_set
    __swig_getmethods__["data"] = _casadi_core.IOSchemeVectorD_data_get
    if _newclass:
        data = _swig_property(_casadi_core.IOSchemeVectorD_data_get, _casadi_core.IOSchemeVectorD_data_set)
    __swig_setmethods__["scheme"] = _casadi_core.IOSchemeVectorD_scheme_set
    __swig_getmethods__["scheme"] = _casadi_core.IOSchemeVectorD_scheme_get
    if _newclass:
        scheme = _swig_property(_casadi_core.IOSchemeVectorD_scheme_get, _casadi_core.IOSchemeVectorD_scheme_set)

    def __getitem__(self, *args):
        """
        __getitem__(IOSchemeVectorD self, int i) -> DMatrix
        __getitem__(IOSchemeVectorD self, std::string const & name) -> DMatrix
        """
        return _casadi_core.IOSchemeVectorD___getitem__(self, *args)


    def __len__(self, *args):
        """__len__(IOSchemeVectorD self) -> int"""
        return _casadi_core.IOSchemeVectorD___len__(self, *args)


    def vector(self, *args):
        """vector(IOSchemeVectorD self) -> DMatrixVector"""
        return _casadi_core.IOSchemeVectorD_vector(self, *args)


    def __iter__(self):
      return iter(self.data)


    def __init__(self, *args):
        """
        __init__(casadi::IOSchemeVector<(casadi::Matrix<(double)>)> self, DMatrixVector d, IOScheme s) -> IOSchemeVectorD
        __init__(casadi::IOSchemeVector<(casadi::Matrix<(double)>)> self, IOSchemeVectorD other) -> IOSchemeVectorD
        """
        this = _casadi_core.new_IOSchemeVectorD(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOSchemeVectorD
IOSchemeVectorD_swigregister = _casadi_core.IOSchemeVectorD_swigregister
IOSchemeVectorD_swigregister(IOSchemeVectorD)

class IOSchemeVectorSparsity(PrintIOSchemeVectorSparsity):
    """


    A vector container with associated IOScheme A class.

    C++ includes: io_scheme_vector.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintIOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOSchemeVectorSparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintIOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOSchemeVectorSparsity, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _casadi_core.IOSchemeVectorSparsity_data_set
    __swig_getmethods__["data"] = _casadi_core.IOSchemeVectorSparsity_data_get
    if _newclass:
        data = _swig_property(_casadi_core.IOSchemeVectorSparsity_data_get, _casadi_core.IOSchemeVectorSparsity_data_set)
    __swig_setmethods__["scheme"] = _casadi_core.IOSchemeVectorSparsity_scheme_set
    __swig_getmethods__["scheme"] = _casadi_core.IOSchemeVectorSparsity_scheme_get
    if _newclass:
        scheme = _swig_property(_casadi_core.IOSchemeVectorSparsity_scheme_get, _casadi_core.IOSchemeVectorSparsity_scheme_set)

    def __getitem__(self, *args):
        """
        __getitem__(IOSchemeVectorSparsity self, int i) -> Sparsity
        __getitem__(IOSchemeVectorSparsity self, std::string const & name) -> Sparsity
        """
        return _casadi_core.IOSchemeVectorSparsity___getitem__(self, *args)


    def __len__(self, *args):
        """__len__(IOSchemeVectorSparsity self) -> int"""
        return _casadi_core.IOSchemeVectorSparsity___len__(self, *args)


    def vector(self, *args):
        """vector(IOSchemeVectorSparsity self) -> SparsityVector"""
        return _casadi_core.IOSchemeVectorSparsity_vector(self, *args)


    def __iter__(self):
      return iter(self.data)


    def __init__(self, *args):
        """
        __init__(casadi::IOSchemeVector<(casadi::Sparsity)> self, SparsityVector d, IOScheme s) -> IOSchemeVectorSparsity
        __init__(casadi::IOSchemeVector<(casadi::Sparsity)> self, IOSchemeVectorSparsity other) -> IOSchemeVectorSparsity
        """
        this = _casadi_core.new_IOSchemeVectorSparsity(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOSchemeVectorSparsity
IOSchemeVectorSparsity_swigregister = _casadi_core.IOSchemeVectorSparsity_swigregister
IOSchemeVectorSparsity_swigregister(IOSchemeVectorSparsity)

class IOSchemeVectorSparsityVector(PrintIOSchemeVectorSparsityVector):
    """


    A vector container with associated IOScheme A class.

    C++ includes: io_scheme_vector.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintIOSchemeVectorSparsityVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOSchemeVectorSparsityVector, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintIOSchemeVectorSparsityVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOSchemeVectorSparsityVector, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _casadi_core.IOSchemeVectorSparsityVector_data_set
    __swig_getmethods__["data"] = _casadi_core.IOSchemeVectorSparsityVector_data_get
    if _newclass:
        data = _swig_property(_casadi_core.IOSchemeVectorSparsityVector_data_get, _casadi_core.IOSchemeVectorSparsityVector_data_set)
    __swig_setmethods__["scheme"] = _casadi_core.IOSchemeVectorSparsityVector_scheme_set
    __swig_getmethods__["scheme"] = _casadi_core.IOSchemeVectorSparsityVector_scheme_get
    if _newclass:
        scheme = _swig_property(_casadi_core.IOSchemeVectorSparsityVector_scheme_get, _casadi_core.IOSchemeVectorSparsityVector_scheme_set)

    def __getitem__(self, *args):
        """
        __getitem__(IOSchemeVectorSparsityVector self, int i) -> SparsityVector
        __getitem__(IOSchemeVectorSparsityVector self, std::string const & name) -> SparsityVector
        """
        return _casadi_core.IOSchemeVectorSparsityVector___getitem__(self, *args)


    def __len__(self, *args):
        """__len__(IOSchemeVectorSparsityVector self) -> int"""
        return _casadi_core.IOSchemeVectorSparsityVector___len__(self, *args)


    def vector(self, *args):
        """vector(IOSchemeVectorSparsityVector self) -> SparsityVectorVector"""
        return _casadi_core.IOSchemeVectorSparsityVector_vector(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::IOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, SparsityVectorVector d, IOScheme s) -> IOSchemeVectorSparsityVector
        __init__(casadi::IOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, IOSchemeVectorSparsityVector other) -> IOSchemeVectorSparsityVector
        """
        this = _casadi_core.new_IOSchemeVectorSparsityVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IOSchemeVectorSparsityVector
IOSchemeVectorSparsityVector_swigregister = _casadi_core.IOSchemeVectorSparsityVector_swigregister
IOSchemeVectorSparsityVector_swigregister(IOSchemeVectorSparsityVector)

class Function(OptionsFunctionality, IOInterfaceFunction):
    """


    General function.

    A general function $f$ in casadi can be multi-input, multi-output. Number of
    inputs: nin getNumInputs() Number of outputs: nout getNumOutputs()  We can
    view this function as a being composed of a ( nin, nout) grid of single-
    input, single-output primitive functions. Each such primitive function $f_
    {i, j} \\forall i \\in [0, nin-1], j \\in [0, nout-1]$ can map as
    $\\mathbf {R}^{n, m}\\to\\mathbf{R}^{p, q}$, in which n, m, p, q can
    take different values for every (i, j) pair.  When passing input, you
    specify which partition $i$ is active. You pass the numbers vectorized, as a
    vector of size $(n*m)$. When requesting output, you specify which partition
    $j$ is active. You get the numbers vectorized, as a vector of size $(p*q)$.
    To calculate Jacobians, you need to have $(m=1, q=1)$.

    Write the Jacobian as $J_ {i, j} = \\nabla f_{i, j} = \\frac
    {\\partial f_{i, j}(\\vec{x})}{\\partial \\vec{x}}$.

    Using $\\vec {v} \\in \\mathbf{R}^n$ as a forward seed: setFwdSeed(v,
    i) Retrieving $\\vec {s}_f \\in \\mathbf{R}^p$ from: getFwdSens(sf, j)
    Using $\\vec {w} \\in \\mathbf{R}^p$ as a forward seed: setAdjSeed(w,
    j) Retrieving $\\vec {s}_a \\in \\mathbf{R}^n $ from: getAdjSens(sa,
    i)  We have the following relationships for function mapping from a row
    vector to a row vector:

    $ \\vec {s}_f = \\nabla f_{i, j} . \\vec{v}$ $ \\vec {s}_a =
    (\\nabla f_{i, j})^T . \\vec{w}$

    Some quantities in these formulas must be transposed: input col: transpose $
    \\vec {v} $ and $\\vec{s}_a$ output col: transpose $ \\vec {w} $ and
    $\\vec{s}_f$  NOTE: Functions are allowed to modify their input arguments
    when evaluating: implicitFunction, IDAS solver Further releases may disallow
    this.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    >List of available monitors

    +---------+--------------------------+
    |   Id    |         Used in          |
    +=========+==========================+
    | inputs  | casadi::FunctionInternal |
    +---------+--------------------------+
    | outputs | casadi::FunctionInternal |
    +---------+--------------------------+

    C++ includes: function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [OptionsFunctionality, IOInterfaceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Function, name, value)
    __swig_getmethods__ = {}
    for _s in [OptionsFunctionality, IOInterfaceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Function, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi_core.delete_Function

    def inputScheme(self, *args):
        """
        inputScheme(Function self) -> IOScheme
        inputScheme(Function self) -> IOScheme

        [INTERNAL]  Access
        input/output scheme.


        """
        return _casadi_core.Function_inputScheme(self, *args)


    def outputScheme(self, *args):
        """
        outputScheme(Function self) -> IOScheme
        outputScheme(Function self) -> IOScheme

        [INTERNAL]  Access
        input/output scheme.


        """
        return _casadi_core.Function_outputScheme(self, *args)


    def input_struct(self, *args):
        """
        input_struct(Function self) -> IOSchemeVectorD
        input_struct(Function self) -> IOSchemeVectorD

        [INTERNAL]
        Input/output structures of the function


        """
        return _casadi_core.Function_input_struct(self, *args)


    def output_struct(self, *args):
        """
        output_struct(Function self) -> IOSchemeVectorD
        output_struct(Function self) -> IOSchemeVectorD

        [INTERNAL]
        Input/output structures of the function


        """
        return _casadi_core.Function_output_struct(self, *args)


    def getNumInputNonzeros(self, *args):
        """
        getNumInputNonzeros(Function self) -> int



        Get total number of nonzeros in all of the matrix-valued inputs.


        """
        return _casadi_core.Function_getNumInputNonzeros(self, *args)


    def getNumOutputNonzeros(self, *args):
        """
        getNumOutputNonzeros(Function self) -> int



        Get total number of nonzeros in all of the matrix-valued outputs.


        """
        return _casadi_core.Function_getNumOutputNonzeros(self, *args)


    def getNumInputElements(self, *args):
        """
        getNumInputElements(Function self) -> int



        Get total number of elements in all of the matrix-valued inputs.


        """
        return _casadi_core.Function_getNumInputElements(self, *args)


    def getNumOutputElements(self, *args):
        """
        getNumOutputElements(Function self) -> int



        Get total number of elements in all of the matrix-valued outputs.


        """
        return _casadi_core.Function_getNumOutputElements(self, *args)


    def setInputScheme(self, *args):
        """
        setInputScheme(Function self, IOScheme scheme)



        Set input scheme.


        """
        return _casadi_core.Function_setInputScheme(self, *args)


    def setOutputScheme(self, *args):
        """
        setOutputScheme(Function self, IOScheme scheme)



        Set output scheme.


        """
        return _casadi_core.Function_setOutputScheme(self, *args)


    def getInputScheme(self, *args):
        """
        getInputScheme(Function self) -> IOScheme



        Get input scheme.


        """
        return _casadi_core.Function_getInputScheme(self, *args)


    def getOutputScheme(self, *args):
        """
        getOutputScheme(Function self) -> IOScheme



        Get output scheme.


        """
        return _casadi_core.Function_getOutputScheme(self, *args)


    def evaluate(self, *args):
        """
        evaluate(Function self)



        Evaluate.


        """
        return _casadi_core.Function_evaluate(self, *args)


    def jacobian(self, *args):
        """
        jacobian(Function self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, std::string const & iind, int oind=0, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, int iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, std::string const & iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Function



        Generate a Jacobian function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. If
        compact is set to true, only the nonzeros of the input and output
        expressions are considered. If symmetric is set to true, the Jacobian being
        calculated is known to be symmetric (usually a Hessian), which can be
        exploited by the algorithm.

        The generated Jacobian has one more output than the calling function
        corresponding to the Jacobian and the same number of inputs.


        """
        return _casadi_core.Function_jacobian(self, *args)


    def setJacobian(self, *args):
        """
        setJacobian(Function self, Function jac, int iind=0, int oind=0, bool compact=False)



        Set the Jacobian function of output oind with respect to input iind NOTE:
        Does not take ownership, only weak references to the Jacobians are kept
        internally


        """
        return _casadi_core.Function_setJacobian(self, *args)


    def gradient(self, *args):
        """
        gradient(Function self, int iind=0, int oind=0) -> Function
        gradient(Function self, std::string const & iind, int oind=0) -> Function
        gradient(Function self, int iind, std::string const & oind) -> Function
        gradient(Function self, std::string const & iind, std::string const & oind) -> Function



        Generate a gradient function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. Note
        that the output must be scalar. In other cases, use the Jacobian instead.


        """
        return _casadi_core.Function_gradient(self, *args)


    def tangent(self, *args):
        """
        tangent(Function self, int iind=0, int oind=0) -> Function
        tangent(Function self, std::string const & iind, int oind=0) -> Function
        tangent(Function self, int iind, std::string const & oind) -> Function
        tangent(Function self, std::string const & iind, std::string const & oind) -> Function



        Generate a tangent function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. Note
        that the input must be scalar. In other cases, use the Jacobian instead.


        """
        return _casadi_core.Function_tangent(self, *args)


    def hessian(self, *args):
        """
        hessian(Function self, int iind=0, int oind=0) -> Function
        hessian(Function self, std::string const & iind, int oind=0) -> Function
        hessian(Function self, int iind, std::string const & oind) -> Function
        hessian(Function self, std::string const & iind, std::string const & oind) -> Function



        Generate a Hessian function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The generated Hessian has two more outputs than the calling function
        corresponding to the Hessian and the gradients.


        """
        return _casadi_core.Function_hessian(self, *args)


    def fullJacobian(self, *args):
        """
        fullJacobian(Function self) -> Function



        Generate a Jacobian function of all the inputs elements with respect to all
        the output elements).


        """
        return _casadi_core.Function_fullJacobian(self, *args)


    def setFullJacobian(self, *args):
        """
        setFullJacobian(Function self, Function jac)



        Set the Jacobian of all the input nonzeros with respect to all output
        nonzeros NOTE: Does not take ownership, only weak references to the Jacobian
        are kept internally


        """
        return _casadi_core.Function_setFullJacobian(self, *args)


    def call(self, *args):
        """
        call(Function self, DMatrixVector arg, bool always_inline=False, bool never_inline=False) -> DMatrixVector
        call(Function self, SXVector arg, bool always_inline=False, bool never_inline=False) -> SXVector
        call(Function self, MXVector arg, bool always_inline=False, bool never_inline=False) -> MXVector



        Evaluate the function symbolically or numerically.


        """
        return _casadi_core.Function_call(self, *args)


    def __call__(self, *args):
        """
        __call__(Function self, DMatrixVector arg) -> DMatrixVector
        __call__(Function self, SXVector arg) -> SXVector
        __call__(Function self, MXVector arg) -> MXVector
        __call__(Function self, IOSchemeVectorD arg) -> IOSchemeVectorD
        __call__(Function self, IOSchemeVectorSX arg) -> IOSchemeVectorSX
        __call__(Function self, IOSchemeVectorMX arg) -> IOSchemeVectorMX
        """
        return _casadi_core.Function___call__(self, *args)


    def callDerivative(self, *args):
        """
        callDerivative(Function self, DMatrixVector arg, DMatrixVectorVector fseed, DMatrixVectorVector aseed, bool always_inline=False, bool never_inline=False)
        callDerivative(Function self, SXVector arg, SXVectorVector fseed, SXVectorVector aseed, bool always_inline=False, bool never_inline=False)
        callDerivative(Function self, MXVector arg, MXVectorVector fseed, MXVectorVector aseed, bool always_inline=False, bool never_inline=False)

        [INTERNAL]
        Evaluate the function symbolically or numerically with directional
        derivatives The first two arguments are the nondifferentiated inputs and
        results of the evaluation, the next two arguments are a set of forward
        directional seeds and the resulting forward directional derivatives, the
        length of the vector being the number of forward directions. The next two
        arguments are a set of adjoint directional seeds and the resulting adjoint
        directional derivatives, the length of the vector being the number of
        adjoint directions.


        """
        return _casadi_core.Function_callDerivative(self, *args)


    def callParallel(self, *args):
        """
        callParallel(Function self, MXVectorVector arg, Dictionary paropt) -> MXVectorVector



        Evaluate symbolically in parallel (matrix graph)

        Parameters:
        -----------

        paropt:  Set of options to be passed to the Parallelizer


        """
        return _casadi_core.Function_callParallel(self, *args)


    def derivative(self, *args):
        """
        derivative(Function self, int nfwd, int nadj) -> Function



        Get a function that calculates nfwd forward derivatives and nadj adjoint
        derivatives.

        Returns a function with (1+nfwd)*n_in+nadj*n_out inputs and (1+nfwd)*n_out +
        nadj*n_in outputs. The first n_in inputs correspond to nondifferentiated
        inputs. The next nfwd*n_in inputs correspond to forward seeds, one direction
        at a time and the last nadj*n_out inputs correspond to adjoint seeds, one
        direction at a time. The first n_out outputs correspond to nondifferentiated
        outputs. The next nfwd*n_out outputs correspond to forward sensitivities,
        one direction at a time and the last nadj*n_in outputs corresponds to
        adjoint sensitivities, one direction at a time.

        (n_in = getNumInputs(), n_out = getNumOutputs())

        The functions returned are cached, meaning that if called multiple timed
        with the same value, then multiple references to the same function will be
        returned.


        """
        return _casadi_core.Function_derivative(self, *args)


    def setDerivative(self, *args):
        """
        setDerivative(Function self, Function fcn, int nfwd, int nadj)



        Set a function that calculates nfwd forward derivatives and nadj adjoint
        derivatives.

        NOTE: Does not take ownership, only weak references to the derivatives are
        kept internally


        """
        return _casadi_core.Function_setDerivative(self, *args)


    def jacSparsity(self, *args):
        """
        jacSparsity(Function self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> Sparsity
        jacSparsity(Function self, std::string const & iind, int oind=0, bool compact=False, bool symmetric=False) -> Sparsity
        jacSparsity(Function self, int iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity
        jacSparsity(Function self, std::string const & iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity



        Get, if necessary generate, the sparsity of a Jacobian block


        """
        return _casadi_core.Function_jacSparsity(self, *args)


    def setJacSparsity(self, *args):
        """
        setJacSparsity(Function self, Sparsity sp, int iind, int oind, bool compact=False)
        setJacSparsity(Function self, Sparsity sp, std::string const & iind, int oind, bool compact=False)
        setJacSparsity(Function self, Sparsity sp, int iind, std::string const & oind, bool compact=False)
        setJacSparsity(Function self, Sparsity sp, std::string const & iind, std::string const & oind, bool compact=False)



        Generate the sparsity of a Jacobian block


        """
        return _casadi_core.Function_setJacSparsity(self, *args)


    def generateCode(self, *args):
        """
        generateCode(Function self, std::string const & filename, bool generate_main=False)
        generateCode(Function self) -> std::string
        generateCode(Function self, std::ostream & filename, bool generate_main=False)



        >  void casadi::Function::generateCode(const std::string &filename, bool generate_main=false)
        ------------------------------------------------------------------------

        Export / Generate C code for the function.

        >  std::string casadi::Function::generateCode()

        >  void casadi::Function::generateCode(std::ostream &filename, bool generate_main=false)
        ------------------------------------------------------------------------

        Generate C code for the function.


        """
        return _casadi_core.Function_generateCode(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.Function_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def getStats(self, *args):
        """
        getStats(Function self) -> Dictionary



        Get all statistics obtained at the end of the last evaluate call.


        """
        return _casadi_core.Function_getStats(self, *args)


    def getStat(self, *args):
        """
        getStat(Function self, std::string const & name) -> GenericType



        Get a single statistic obtained at the end of the last evaluate call.


        """
        return _casadi_core.Function_getStat(self, *args)


    def symbolicInput(self, *args):
        """
        symbolicInput(Function self) -> MXVector



        Get a vector of symbolic variables with the same dimensions as the inputs.

        There is no guarantee that consecutive calls return identical objects


        """
        return _casadi_core.Function_symbolicInput(self, *args)


    def symbolicInputSX(self, *args):
        """
        symbolicInputSX(Function self) -> SXVector



        Get a vector of symbolic variables with the same dimensions as the inputs,
        SX graph.

        There is no guarantee that consecutive calls return identical objects


        """
        return _casadi_core.Function_symbolicInputSX(self, *args)


    def spCanEvaluate(self, *args):
        """
        spCanEvaluate(Function self, bool fwd) -> bool

        [INTERNAL]  Is the
        class able to propagate seeds through the algorithm?

        (for usage, see the example propagating_sparsity.cpp)


        """
        return _casadi_core.Function_spCanEvaluate(self, *args)


    def spInit(self, *args):
        """
        spInit(Function self, bool fwd)

        [INTERNAL]  Reset the
        sparsity propagation.

        (for usage, see the example propagating_sparsity.cpp)


        """
        return _casadi_core.Function_spInit(self, *args)


    def spEvaluate(self, *args):
        """
        spEvaluate(Function self, bool fwd)

        [INTERNAL]  Propagate
        the sparsity pattern through a set of directional.

        derivatives forward or backward (for usage, see the example
        propagating_sparsity.cpp)


        """
        return _casadi_core.Function_spEvaluate(self, *args)


    def addMonitor(self, *args):
        """
        addMonitor(Function self, std::string const & mon)



        Add modules to be monitored.


        """
        return _casadi_core.Function_addMonitor(self, *args)


    def removeMonitor(self, *args):
        """
        removeMonitor(Function self, std::string const & mon)



        Remove modules to be monitored.


        """
        return _casadi_core.Function_removeMonitor(self, *args)


    def checkInputs(self, *args):
        """
        checkInputs(Function self)

        [INTERNAL]  Check if
        the numerical values of the supplied bounds make sense.


        """
        return _casadi_core.Function_checkInputs(self, *args)


    def getSanitizedName(self, *args):
        """
        getSanitizedName(Function self) -> std::string



        get function name with all non alphanumeric characters converted to '_'


        """
        return _casadi_core.Function_getSanitizedName(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::Function self) -> Function
        __init__(casadi::Function self, Function other) -> Function



        default constructor


        """
        this = _casadi_core.new_Function(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
Function_swigregister = _casadi_core.Function_swigregister
Function_swigregister(Function)

def Function_testCast(*args):
    """Function_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.Function_testCast(*args)

class FunctionVector(_object):
    """Proxy of C++ std::vector<(casadi::Function)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Function)> self) -> FunctionVector
        __init__(std::vector<(casadi::Function)> self, FunctionVector other) -> FunctionVector
        """
        this = _casadi_core.new_FunctionVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_FunctionVector
FunctionVector_swigregister = _casadi_core.FunctionVector_swigregister
FunctionVector_swigregister(FunctionVector)

class Pair_Function_Function(_object):
    """Proxy of C++ std::pair<(casadi::Function,casadi::Function)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair_Function_Function, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pair_Function_Function, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(casadi::Function,casadi::Function)> self) -> Pair_Function_Function
        __init__(std::pair<(casadi::Function,casadi::Function)> self, Function first, Function second) -> Pair_Function_Function
        __init__(std::pair<(casadi::Function,casadi::Function)> self, Pair_Function_Function p) -> Pair_Function_Function
        """
        this = _casadi_core.new_Pair_Function_Function(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _casadi_core.Pair_Function_Function_first_set
    __swig_getmethods__["first"] = _casadi_core.Pair_Function_Function_first_get
    if _newclass:
        first = _swig_property(_casadi_core.Pair_Function_Function_first_get, _casadi_core.Pair_Function_Function_first_set)
    __swig_setmethods__["second"] = _casadi_core.Pair_Function_Function_second_set
    __swig_getmethods__["second"] = _casadi_core.Pair_Function_Function_second_get
    if _newclass:
        second = _swig_property(_casadi_core.Pair_Function_Function_second_get, _casadi_core.Pair_Function_Function_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _casadi_core.delete_Pair_Function_Function
Pair_Function_Function_swigregister = _casadi_core.Pair_Function_Function_swigregister
Pair_Function_Function_swigregister(Pair_Function_Function)

class SXFunction(Function):
    """


    Dynamically created function that can be expanded into a series of scalar
    operations.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | just_in_time | OT_BOOLEAN   | false        | Just-in-time | casadi::SXFu |
    | _opencl      |              |              | compilation  | nctionIntern |
    |              |              |              | for numeric  | al           |
    |              |              |              | evaluation   |              |
    |              |              |              | using OpenCL |              |
    |              |              |              | (experimenta |              |
    |              |              |              | l)           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | just_in_time | OT_BOOLEAN   | false        | Propagate    | casadi::SXFu |
    | _sparsity    |              |              | sparsity     | nctionIntern |
    |              |              |              | patterns     | al           |
    |              |              |              | using just-  |              |
    |              |              |              | in-time      |              |
    |              |              |              | compilation  |              |
    |              |              |              | to a CPU or  |              |
    |              |              |              | GPU using    |              |
    |              |              |              | OpenCL       |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: sx_function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SXFunction, name)
    __repr__ = _swig_repr

    def jac(self, *args):
        """
        jac(SXFunction self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> SX
        jac(SXFunction self, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> SX
        jac(SXFunction self, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> SX
        jac(SXFunction self, std::string const & iname, std::string const & oname, bool compact=False, bool symmetric=False) -> SX



        Jacobian via source code transformation.

        See:  casadi::Jacobian for an AD approach


        """
        return _casadi_core.SXFunction_jac(self, *args)


    def grad(self, *args):
        """
        grad(SXFunction self, int iind=0, int oind=0) -> SX
        grad(SXFunction self, std::string const & iname, int oind=0) -> SX
        grad(SXFunction self, int iind, std::string const & oname) -> SX
        grad(SXFunction self, std::string const & iname, std::string const & oname) -> SX



        Gradient via source code transformation


        """
        return _casadi_core.SXFunction_grad(self, *args)


    def tang(self, *args):
        """
        tang(SXFunction self, int iind=0, int oind=0) -> SX
        tang(SXFunction self, std::string const & iname, int oind=0) -> SX
        tang(SXFunction self, int iind, std::string const & oname) -> SX
        tang(SXFunction self, std::string const & iname, std::string const & oname) -> SX



        Tangent via source code transformation


        """
        return _casadi_core.SXFunction_tang(self, *args)


    def hess(self, *args):
        """
        hess(SXFunction self, int iind=0, int oind=0) -> SX
        hess(SXFunction self, std::string const & iname, int oind=0) -> SX
        hess(SXFunction self, int iind, std::string const & oname) -> SX
        hess(SXFunction self, std::string const & iname, std::string const & oname) -> SX



        Hessian (forward over adjoint) via source code transformation


        """
        return _casadi_core.SXFunction_hess(self, *args)


    def inputExpr(self, *args):
        """
        inputExpr(SXFunction self, int iind) -> SX
        inputExpr(SXFunction self, std::string const & iname) -> SX
        inputExpr(SXFunction self) -> SXVector



        >  const SX & casadi::SXFunction::inputExpr(int iind) const 
        ------------------------------------------------------------------------

        Get function input.

        >  const std::vector< SX > & casadi::SXFunction::inputExpr() const 
        ------------------------------------------------------------------------

        Get all function inputs.


        """
        return _casadi_core.SXFunction_inputExpr(self, *args)


    def outputExpr(self, *args):
        """
        outputExpr(SXFunction self, int oind) -> SX
        outputExpr(SXFunction self, std::string const & oname) -> SX
        outputExpr(SXFunction self) -> SXVector



        >  const SX & casadi::SXFunction::outputExpr(int oind) const 
        ------------------------------------------------------------------------

        Get function output.

        >  const std::vector< SX > & casadi::SXFunction::outputExpr() const 
        ------------------------------------------------------------------------

        Get all function outputs.


        """
        return _casadi_core.SXFunction_outputExpr(self, *args)


    def getAlgorithmSize(self, *args):
        """
        getAlgorithmSize(SXFunction self) -> int



        Get the number of atomic operations.


        """
        return _casadi_core.SXFunction_getAlgorithmSize(self, *args)


    def getWorkSize(self, *args):
        """
        getWorkSize(SXFunction self) -> int



        Get the length of the work vector.


        """
        return _casadi_core.SXFunction_getWorkSize(self, *args)


    def getAtomicOperation(self, *args):
        """
        getAtomicOperation(SXFunction self, int k) -> int



        Get an atomic operation operator index.


        """
        return _casadi_core.SXFunction_getAtomicOperation(self, *args)


    def getAtomicInput(self, *args):
        """
        getAtomicInput(SXFunction self, int k) -> Pair_Int_Int



        Get the (integer) input arguments of an atomic operation.


        """
        return _casadi_core.SXFunction_getAtomicInput(self, *args)


    def getAtomicInputReal(self, *args):
        """
        getAtomicInputReal(SXFunction self, int k) -> double



        Get the floating point output argument of an atomic operation.


        """
        return _casadi_core.SXFunction_getAtomicInputReal(self, *args)


    def getAtomicOutput(self, *args):
        """
        getAtomicOutput(SXFunction self, int k) -> int



        Get the (integer) output argument of an atomic operation.


        """
        return _casadi_core.SXFunction_getAtomicOutput(self, *args)


    def countNodes(self, *args):
        """
        countNodes(SXFunction self) -> int



        Number of nodes in the algorithm.


        """
        return _casadi_core.SXFunction_countNodes(self, *args)


    def clearSymbolic(self, *args):
        """
        clearSymbolic(SXFunction self)



        Clear the function from its symbolic representation, to free up memory, no
        symbolic evaluations are possible after this.


        """
        return _casadi_core.SXFunction_clearSymbolic(self, *args)


    def getFree(self, *args):
        """
        getFree(SXFunction self) -> SXElementVector



        Get all the free variables of the function.


        """
        return _casadi_core.SXFunction_getFree(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.SXFunction_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::SXFunction self) -> SXFunction
        __init__(casadi::SXFunction self, MXFunction f) -> SXFunction
        __init__(casadi::SXFunction self, Function f) -> SXFunction
        __init__(casadi::SXFunction self, SXVector arg, SXVector res) -> SXFunction
        __init__(casadi::SXFunction self, SXVector arg, IOSchemeVectorSX res) -> SXFunction
        __init__(casadi::SXFunction self, IOSchemeVectorSX arg, SXVector res) -> SXFunction
        __init__(casadi::SXFunction self, IOSchemeVectorSX arg, IOSchemeVectorSX res) -> SXFunction
        __init__(casadi::SXFunction self, SXFunction other) -> SXFunction



        >  casadi::SXFunction::SXFunction()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::SXFunction::SXFunction(const MXFunction &f)
        ------------------------------------------------------------------------

        Expand an MXFunction.

        >  casadi::SXFunction::SXFunction(const Function &f)
        ------------------------------------------------------------------------

        Expand an Function.

        >  casadi::SXFunction::SXFunction(const std::vector< SX > &arg, const std::vector< SX > &res)

        >  casadi::SXFunction::SXFunction(const std::vector< SX > &arg, const IOSchemeVector< SX > &res)

        >  casadi::SXFunction::SXFunction(const IOSchemeVector< SX > &arg, const std::vector< SX > &res)

        >  casadi::SXFunction::SXFunction(const IOSchemeVector< SX > &arg, const IOSchemeVector< SX > &res)
        ------------------------------------------------------------------------

        Multiple (matrix valued) input, multiple (matrix valued) output.

        >  casadi::SXFunction::SXFunction(const std::vector< std::vector< SXElement > > &arg, const std::vector< std::vector< SXElement > > &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Multiple (vector valued) input, multiple (vector valued) output.

        >  casadi::SXFunction::SXFunction(const SX &arg, const SX &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Single (scalar/matrix/vector valued) input, single
        (scalar/matrix/vector valued) output.

        >  casadi::SXFunction::SXFunction(const std::vector< std::vector< SXElement > > &arg, const SX &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Multiple (vector valued) input, single (scalar/vector/matrix valued)
        output.

        >  casadi::SXFunction::SXFunction(const std::vector< SX > &arg, const SX &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Multiple (matrix valued) input, single (scalar/vector/matrix valued)
        output.

        >  casadi::SXFunction::SXFunction(const SX &arg, const std::vector< std::vector< SXElement > > &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Single (scalar/vector/matrix valued) input, multiple (vector valued)
        output.

        >  casadi::SXFunction::SXFunction(const SX &arg, const std::vector< SX > &res)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Single (scalar/vector/matrix valued) input, multiple (matrix valued)
        output.


        """
        this = _casadi_core.new_SXFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SXFunction
SXFunction_swigregister = _casadi_core.SXFunction_swigregister
SXFunction_swigregister(SXFunction)

def SXFunction_testCast(*args):
    """SXFunction_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.SXFunction_testCast(*args)

class MXAlgEl(_object):
    """
    [INTERNAL]  An element of the
    algorithm, namely an MX node.

    C++ includes: mx_function.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MXAlgEl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MXAlgEl, name)
    __repr__ = _swig_repr
    __swig_setmethods__["op"] = _casadi_core.MXAlgEl_op_set
    __swig_getmethods__["op"] = _casadi_core.MXAlgEl_op_get
    if _newclass:
        op = _swig_property(_casadi_core.MXAlgEl_op_get, _casadi_core.MXAlgEl_op_set)
    __swig_setmethods__["data"] = _casadi_core.MXAlgEl_data_set
    __swig_getmethods__["data"] = _casadi_core.MXAlgEl_data_get
    if _newclass:
        data = _swig_property(_casadi_core.MXAlgEl_data_get, _casadi_core.MXAlgEl_data_set)
    __swig_setmethods__["arg"] = _casadi_core.MXAlgEl_arg_set
    __swig_getmethods__["arg"] = _casadi_core.MXAlgEl_arg_get
    if _newclass:
        arg = _swig_property(_casadi_core.MXAlgEl_arg_get, _casadi_core.MXAlgEl_arg_set)
    __swig_setmethods__["res"] = _casadi_core.MXAlgEl_res_set
    __swig_getmethods__["res"] = _casadi_core.MXAlgEl_res_get
    if _newclass:
        res = _swig_property(_casadi_core.MXAlgEl_res_get, _casadi_core.MXAlgEl_res_set)

    def __init__(self, *args):
        """
        __init__(casadi::MXAlgEl self) -> MXAlgEl
        __init__(casadi::MXAlgEl self, MXAlgEl other) -> MXAlgEl
        """
        this = _casadi_core.new_MXAlgEl(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MXAlgEl
MXAlgEl_swigregister = _casadi_core.MXAlgEl_swigregister
MXAlgEl_swigregister(MXAlgEl)

class MXAlgElVector(_object):
    """Proxy of C++ std::vector<(casadi::MXAlgEl)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MXAlgElVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MXAlgElVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::MXAlgEl)> self) -> MXAlgElVector
        __init__(std::vector<(casadi::MXAlgEl)> self, MXAlgElVector other) -> MXAlgElVector
        """
        this = _casadi_core.new_MXAlgElVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MXAlgElVector
MXAlgElVector_swigregister = _casadi_core.MXAlgElVector_swigregister
MXAlgElVector_swigregister(MXAlgElVector)

class MXFunction(Function):
    """


    General function mapping from/to MX.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: mx_function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MXFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MXFunction, name)
    __repr__ = _swig_repr

    def inputExpr(self, *args):
        """
        inputExpr(MXFunction self, int ind) -> MX
        inputExpr(MXFunction self, std::string const & iname) -> MX
        inputExpr(MXFunction self) -> MXVector



        >  const MX & casadi::MXFunction::inputExpr(int ind) const 
        ------------------------------------------------------------------------

        Get function input.

        >  const std::vector< MX > & casadi::MXFunction::inputExpr() const 
        ------------------------------------------------------------------------

        Get all function inputs.


        """
        return _casadi_core.MXFunction_inputExpr(self, *args)


    def outputExpr(self, *args):
        """
        outputExpr(MXFunction self, int ind) -> MX
        outputExpr(MXFunction self, std::string const & oname) -> MX
        outputExpr(MXFunction self) -> MXVector



        >  const MX & casadi::MXFunction::outputExpr(int ind) const 
        ------------------------------------------------------------------------

        Get function output.

        >  const std::vector< MX > & casadi::MXFunction::outputExpr() const 
        ------------------------------------------------------------------------

        Get all function outputs.


        """
        return _casadi_core.MXFunction_outputExpr(self, *args)


    def getAlgorithmSize(self, *args):
        """
        getAlgorithmSize(MXFunction self) -> int



        Get the number of atomic operations.


        """
        return _casadi_core.MXFunction_getAlgorithmSize(self, *args)


    def getWorkSize(self, *args):
        """
        getWorkSize(MXFunction self) -> int



        Get the length of the work vector.


        """
        return _casadi_core.MXFunction_getWorkSize(self, *args)


    def countNodes(self, *args):
        """
        countNodes(MXFunction self) -> int



        Number of nodes in the algorithm.


        """
        return _casadi_core.MXFunction_countNodes(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.MXFunction_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def jac(self, *args):
        """
        jac(MXFunction self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> MX
        jac(MXFunction self, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> MX
        jac(MXFunction self, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> MX
        jac(MXFunction self, std::string const & iname, std::string const & oname, bool compact=False, bool symmetric=False) -> MX



        Jacobian via source code transformation.


        """
        return _casadi_core.MXFunction_jac(self, *args)


    def grad(self, *args):
        """
        grad(MXFunction self, int iind=0, int oind=0) -> MX
        grad(MXFunction self, std::string const & iname, int oind=0) -> MX
        grad(MXFunction self, int iind, std::string const & oname) -> MX
        grad(MXFunction self, std::string const & iname, std::string const & oname) -> MX



        Gradient via source code transformation.


        """
        return _casadi_core.MXFunction_grad(self, *args)


    def tang(self, *args):
        """
        tang(MXFunction self, int iind=0, int oind=0) -> MX
        tang(MXFunction self, std::string const & iname, int oind=0) -> MX
        tang(MXFunction self, int iind, std::string const & oname) -> MX
        tang(MXFunction self, std::string const & iname, std::string const & oname) -> MX



        Tangent via source code transformation.


        """
        return _casadi_core.MXFunction_tang(self, *args)


    def expand(self, *args):
        """
        expand(MXFunction self, SXVector inputv) -> SXFunction



        Expand the matrix valued graph into a scalar valued graph.


        """
        return _casadi_core.MXFunction_expand(self, *args)


    def getFree(self, *args):
        """
        getFree(MXFunction self) -> MXVector



        Get all the free variables of the function.


        """
        return _casadi_core.MXFunction_getFree(self, *args)


    def generateLiftingFunctions(self, *args):
        """
        generateLiftingFunctions(MXFunction self, MXFunction arg2, MXFunction arg3)

        [INTERNAL]  Extract the functions needed for the Lifted Newton method.


        """
        return _casadi_core.MXFunction_generateLiftingFunctions(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::MXFunction self) -> MXFunction
        __init__(casadi::MXFunction self, Function function) -> MXFunction
        __init__(casadi::MXFunction self, MXVector input, MXVector output) -> MXFunction
        __init__(casadi::MXFunction self, MXVector input, IOSchemeVectorMX output) -> MXFunction
        __init__(casadi::MXFunction self, IOSchemeVectorMX input, MXVector output) -> MXFunction
        __init__(casadi::MXFunction self, IOSchemeVectorMX input, IOSchemeVectorMX output) -> MXFunction
        __init__(casadi::MXFunction self, MXFunction other) -> MXFunction



        >  casadi::MXFunction::MXFunction()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::MXFunction::MXFunction(const Function &function)
        ------------------------------------------------------------------------

        Attempt to form an MXFunction out of an Function.

        >  casadi::MXFunction::MXFunction(const MX &input, const MX &output)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Single input, single output.

        >  casadi::MXFunction::MXFunction(const MX &input, const std::vector< MX > &output)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Single input, multiple output.

        >  casadi::MXFunction::MXFunction(const std::vector< MX > &input, const MX &output)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Multiple input, single output.

        >  casadi::MXFunction::MXFunction(const std::vector< MX > &input, const std::vector< MX > &output)

        >  casadi::MXFunction::MXFunction(const std::vector< MX > &input, const IOSchemeVector< MX > &output)

        >  casadi::MXFunction::MXFunction(const IOSchemeVector< MX > &input, const std::vector< MX > &output)

        >  casadi::MXFunction::MXFunction(const IOSchemeVector< MX > &input, const IOSchemeVector< MX > &output)
        ------------------------------------------------------------------------

        Multiple input, multiple output.


        """
        this = _casadi_core.new_MXFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_MXFunction
MXFunction_swigregister = _casadi_core.MXFunction_swigregister
MXFunction_swigregister(MXFunction)

def MXFunction_testCast(*args):
    """MXFunction_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.MXFunction_testCast(*args)


_casadi_core.LINSOL_A_swigconstant(_casadi_core)
LINSOL_A = _casadi_core.LINSOL_A

_casadi_core.LINSOL_B_swigconstant(_casadi_core)
LINSOL_B = _casadi_core.LINSOL_B

_casadi_core.LINSOL_NUM_IN_swigconstant(_casadi_core)
LINSOL_NUM_IN = _casadi_core.LINSOL_NUM_IN

_casadi_core.LINSOL_X_swigconstant(_casadi_core)
LINSOL_X = _casadi_core.LINSOL_X

_casadi_core.LINSOL_NUM_OUT_swigconstant(_casadi_core)
LINSOL_NUM_OUT = _casadi_core.LINSOL_NUM_OUT
class LinearSolver(Function):
    """


    Base class for the linear solver classes.

    Solves the linear system A*X = B or A^T*X = B for X with A square and non-
    singular

    If A is structurally singular, an error will be thrown during init. If A is
    numerically singular, the prepare step will fail.

    The usual procedure to use LinearSolver is:  init()

    set the first input (A)

    prepare()

    set the second input (b)

    solve()

    Repeat steps 4 and 5 to work with other b vectors.

    The method evaluate() combines the prepare() and solve() step and is
    therefore more expensive if A is invariant.

    General information
    ===================



    >Input scheme: casadi::LinsolInput (LINSOL_NUM_IN = 2) [linsolIn]

    +-----------+-------+------------------------------------------------+
    | Full name | Short |                  Description                   |
    +===========+=======+================================================+
    | LINSOL_A  | A     | The square matrix A: sparse, (n x n). .        |
    +-----------+-------+------------------------------------------------+
    | LINSOL_B  | B     | The right-hand-side matrix b: dense, (n x m) . |
    +-----------+-------+------------------------------------------------+

    >Output scheme: casadi::LinsolOutput (LINSOL_NUM_OUT = 1) [linsolOut]

    +-----------+-------+----------------------------------------------+
    | Full name | Short |                 Description                  |
    +===========+=======+==============================================+
    | LINSOL_X  | X     | Solution to the linear system of equations . |
    +-----------+-------+----------------------------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_LinearSolver_csparsecholesky'>csparsecholesky</a>

    - <a href='#plugin_LinearSolver_csparse'>csparse</a>

    - <a href='#plugin_LinearSolver_lapacklu'>lapacklu</a>

    - <a href='#plugin_LinearSolver_lapackqr'>lapackqr</a>

    - <a href='#plugin_LinearSolver_symbolicqr'>symbolicqr</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    LinearSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    csparsecholesky
    ---------------



    LinearSolver with CSparseCholesky Interface

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    csparse
    -------



    LinearSolver with CSparse Interface

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lapacklu
    --------



    This class solves the linear system A.x=b by making an LU factorization of
    A: A = L.U, with L lower and U upper triangular

    >List of available options

    +-----------------------------+------------+---------+-------------+
    |             Id              |    Type    | Default | Description |
    +=============================+============+=========+=============+
    | allow_equilibration_failure | OT_BOOLEAN | false   |             |
    +-----------------------------+------------+---------+-------------+
    | equilibration               | OT_BOOLEAN | true    |             |
    +-----------------------------+------------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lapackqr
    --------



    This class solves the linear system A.x=b by making an QR factorization of
    A: A = Q.R, with Q orthogonal and R upper triangular

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    symbolicqr
    ----------



    LinearSolver based on QR factorization with sparsity pattern based
    reordering without partial pivoting

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | codegen         | OT_BOOLEAN      | false           | C-code          |
    |                 |                 |                 | generation      |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | "gcc -fPIC -O2" | Compiler        |
    |                 |                 |                 | command to be   |
    |                 |                 |                 | used for        |
    |                 |                 |                 | compiling       |
    |                 |                 |                 | generated code  |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: linear_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearSolver, name)
    __repr__ = _swig_repr

    def prepare(self, *args):
        """
        prepare(LinearSolver self)



        Factorize the matrix.


        """
        return _casadi_core.LinearSolver_prepare(self, *args)


    def solve(self, *args):
        """
        solve(LinearSolver self, bool transpose=False)
        solve(LinearSolver self, MX A, MX B, bool transpose=False) -> MX



        >  void casadi::LinearSolver::solve(bool transpose=false)
        ------------------------------------------------------------------------

        Solve the system of equations, internal vector.

        >  void casadi::LinearSolver::solve(double *x, int nrhs=1, bool transpose=false)
        ------------------------------------------------------------------------
        [INTERNAL] 
         Solve the factorized system of equations.

        >  MX casadi::LinearSolver::solve(const MX &A, const MX &B, bool transpose=false)
        ------------------------------------------------------------------------

        Create a solve node.


        """
        return _casadi_core.LinearSolver_solve(self, *args)


    def prepared(self, *args):
        """
        prepared(LinearSolver self) -> bool



        Check if prepared.


        """
        return _casadi_core.LinearSolver_prepared(self, *args)


    def solveL(self, *args):
        """
        solveL(LinearSolver self, double * x, int nrhs, bool transpose)



        Solve the system of equations Lx = b Only when a Cholesky factorization is
        available.


        """
        return _casadi_core.LinearSolver_solveL(self, *args)


    def getFactorizationSparsity(self, *args):
        """
        getFactorizationSparsity(LinearSolver self, bool transpose=False) -> Sparsity



        Obtain a symbolic Cholesky factorization Only for Cholesky solvers.


        """
        return _casadi_core.LinearSolver_getFactorizationSparsity(self, *args)


    def getFactorization(self, *args):
        """
        getFactorization(LinearSolver self, bool transpose=False) -> DMatrix



        Obtain a numeric Cholesky factorization Only for Cholesky solvers.


        """
        return _casadi_core.LinearSolver_getFactorization(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.LinearSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.LinearSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.LinearSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.LinearSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::LinearSolver self) -> LinearSolver
        __init__(casadi::LinearSolver self, Sparsity sp, int nrhs=1) -> LinearSolver
        __init__(casadi::LinearSolver self, std::string const & name, Sparsity sp, int nrhs=1) -> LinearSolver
        __init__(casadi::LinearSolver self, LinearSolver other) -> LinearSolver



        >  casadi::LinearSolver::LinearSolver()
        ------------------------------------------------------------------------
        [INTERNAL] 
        Default (empty) constructor

        >  casadi::LinearSolver::LinearSolver(const Sparsity &sp, int nrhs=1)
        ------------------------------------------------------------------------

        Create a linear solver given a sparsity pattern (creates a dummy solver
        only)

        >  casadi::LinearSolver::LinearSolver(const std::string &name, const Sparsity &sp, int nrhs=1)
        ------------------------------------------------------------------------

        Create a linear solver given a sparsity pattern.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_LinearSolver_csparsecholesky'>csparsecholesky</a>

        - <a href='#plugin_LinearSolver_csparse'>csparse</a>

        - <a href='#plugin_LinearSolver_lapacklu'>lapacklu</a>

        - <a href='#plugin_LinearSolver_lapackqr'>lapackqr</a>

        - <a href='#plugin_LinearSolver_symbolicqr'>symbolicqr</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        LinearSolver.doc("myextraplugin")


        """
        this = _casadi_core.new_LinearSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LinearSolver
LinearSolver_swigregister = _casadi_core.LinearSolver_swigregister
LinearSolver_swigregister(LinearSolver)

def LinearSolver_testCast(*args):
    """LinearSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.LinearSolver_testCast(*args)

def LinearSolver_hasPlugin(*args):
    """LinearSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.LinearSolver_hasPlugin(*args)

def LinearSolver_loadPlugin(*args):
    """LinearSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.LinearSolver_loadPlugin(*args)

def LinearSolver_doc(*args):
    """LinearSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.LinearSolver_doc(*args)

class ImplicitFunction(Function):
    """


    Abstract base class for the implicit function classes.

    The equation:

    F(z, x1, x2, ..., xn) == 0

    where d_F/dz is invertible, implicitly defines the equation:

    z := G(x1, x2, ..., xn)

    F should be an Function mapping from (n+1) inputs to m outputs. The first
    output is the residual that should be zero.

    ImplicitFunction (G) is an Function mapping from n inputs to m outputs. n
    may be zero. The first output is the solved for z.

    You can provide an initial guess for z by setting output(0) of
    ImplicitFunction.

    General information
    ===================



    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | constraints  | OT_INTEGERVE | GenericType( | Constrain    | casadi::Impl |
    |              | CTOR         | )            | the          | icitFunction |
    |              |              |              | unknowns. 0  | Internal     |
    |              |              |              | (default):   |              |
    |              |              |              | no           |              |
    |              |              |              | constraint   |              |
    |              |              |              | on ui, 1: ui |              |
    |              |              |              | >= 0.0, -1:  |              |
    |              |              |              | ui <= 0.0,   |              |
    |              |              |              | 2: ui > 0.0, |              |
    |              |              |              | -2: ui <     |              |
    |              |              |              | 0.0.         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | implicit_inp | OT_INTEGER   | 0            | Index of the | casadi::Impl |
    | ut           |              |              | input that   | icitFunction |
    |              |              |              | corresponds  | Internal     |
    |              |              |              | to the       |              |
    |              |              |              | actual root- |              |
    |              |              |              | finding      |              |
    +--------------+--------------+--------------+--------------+--------------+
    | implicit_out | OT_INTEGER   | 0            | Index of the | casadi::Impl |
    | put          |              |              | output that  | icitFunction |
    |              |              |              | corresponds  | Internal     |
    |              |              |              | to the       |              |
    |              |              |              | actual root- |              |
    |              |              |              | finding      |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | jacobian_fun | OT_FUNCTION  | GenericType( | Function     | casadi::Impl |
    | ction        |              | )            | object for   | icitFunction |
    |              |              |              | calculating  | Internal     |
    |              |              |              | the Jacobian |              |
    |              |              |              | (autogenerat |              |
    |              |              |              | ed by        |              |
    |              |              |              | default)     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | linear_solve | OT_STRING    | GenericType( | User-defined | casadi::Impl |
    | r            |              | )            | linear       | icitFunction |
    |              |              |              | solver       | Internal     |
    |              |              |              | class.       |              |
    |              |              |              | Needed for s |              |
    |              |              |              | ensitivities |              |
    |              |              |              | .            |              |
    +--------------+--------------+--------------+--------------+--------------+
    | linear_solve | OT_FUNCTION  | GenericType( | Function     | casadi::Impl |
    | r_function   |              | )            | object for   | icitFunction |
    |              |              |              | solving the  | Internal     |
    |              |              |              | linearized   |              |
    |              |              |              | problem (aut |              |
    |              |              |              | ogenerated   |              |
    |              |              |              | by default)  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | linear_solve | OT_DICTIONAR | GenericType( | Options to   | casadi::Impl |
    | r_options    | Y            | )            | be passed to | icitFunction |
    |              |              |              | the linear   | Internal     |
    |              |              |              | solver.      |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_ImplicitFunction_kinsol'>kinsol</a>

    - <a href='#plugin_ImplicitFunction_nlp'>nlp</a>

    - <a href='#plugin_ImplicitFunction_newton'>newton</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    ImplicitFunction.doc("myextraplugin")



    --------------------------------------------------------------------------------

    kinsol
    ------



    KINSOL interface from the Sundials suite

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | abstol          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion       |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | disable_interna | OT_BOOLEAN      | false           | Disable KINSOL  |
    | l_warnings      |                 |                 | internal        |
    |                 |                 |                 | warning         |
    |                 |                 |                 | messages        |
    +-----------------+-----------------+-----------------+-----------------+
    | exact_jacobian  | OT_BOOLEAN      | true            |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | f_scale         | OT_REALVECTOR   |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | iterative_solve | OT_STRING       | "gmres"         | gmres|bcgstab|t |
    | r               |                 |                 | fqmr            |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_t | OT_STRING       | "dense"         | dense|banded|it |
    | ype             |                 |                 | erative|user_de |
    |                 |                 |                 | fined           |
    +-----------------+-----------------+-----------------+-----------------+
    | lower_bandwidth | OT_INTEGER      |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 0               | Maximum number  |
    |                 |                 |                 | of Newton       |
    |                 |                 |                 | iterations.     |
    |                 |                 |                 | Putting 0 sets  |
    |                 |                 |                 | the default     |
    |                 |                 |                 | value of        |
    |                 |                 |                 | KinSol.         |
    +-----------------+-----------------+-----------------+-----------------+
    | max_krylov      | OT_INTEGER      | 0               |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | pretype         | OT_STRING       | "none"          | (none|left|righ |
    |                 |                 |                 | t|both)         |
    +-----------------+-----------------+-----------------+-----------------+
    | strategy        | OT_STRING       | "none"          | Globalization   |
    |                 |                 |                 | strategy (none| |
    |                 |                 |                 | linesearch)     |
    +-----------------+-----------------+-----------------+-----------------+
    | u_scale         | OT_REALVECTOR   |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | upper_bandwidth | OT_INTEGER      |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | use_preconditio | OT_BOOLEAN      | false           | precondition an |
    | ner             |                 |                 | iterative       |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-----------+
    |    Id     |
    +===========+
    | eval_djac |
    +-----------+
    | eval_f    |
    +-----------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    nlp
    ---



    Use an NlpSolver as ImplicitFunction solver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +--------------+
    |      Id      |
    +==============+
    | solver_stats |
    +--------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    newton
    ------



    Implements simple newton iterations to solve an implicit function.

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | abstol          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion       |
    |                 |                 |                 | tolerance on    |
    |                 |                 |                 | max(|F|)        |
    +-----------------+-----------------+-----------------+-----------------+
    | abstolStep      | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion       |
    |                 |                 |                 | tolerance on    |
    |                 |                 |                 | step size       |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 1000            | Maximum number  |
    |                 |                 |                 | of Newton       |
    |                 |                 |                 | iterations to   |
    |                 |                 |                 | perform before  |
    |                 |                 |                 | returning.      |
    +-----------------+-----------------+-----------------+-----------------+
    | print_iteration | OT_BOOLEAN      | false           | Print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about each      |
    |                 |                 |                 | iteration       |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +----------+
    |    Id    |
    +==========+
    | F        |
    +----------+
    | J        |
    +----------+
    | normF    |
    +----------+
    | step     |
    +----------+
    | stepsize |
    +----------+

    >List of available stats

    +---------------+
    |      Id       |
    +===============+
    | iter          |
    +---------------+
    | return_status |
    +---------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: implicit_function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImplicitFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImplicitFunction, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.ImplicitFunction_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.ImplicitFunction_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.ImplicitFunction_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.ImplicitFunction_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def getF(self, *args):
        """
        getF(ImplicitFunction self) -> Function



        Access F.


        """
        return _casadi_core.ImplicitFunction_getF(self, *args)


    def getJac(self, *args):
        """
        getJac(ImplicitFunction self) -> Function



        Access Jacobian.


        """
        return _casadi_core.ImplicitFunction_getJac(self, *args)


    def getLinsol(self, *args):
        """
        getLinsol(ImplicitFunction self) -> LinearSolver



        Access linear solver.


        """
        return _casadi_core.ImplicitFunction_getLinsol(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::ImplicitFunction self) -> ImplicitFunction
        __init__(casadi::ImplicitFunction self, std::string const & name, Function f, Function jac, LinearSolver linsol) -> ImplicitFunction
        __init__(casadi::ImplicitFunction self, ImplicitFunction other) -> ImplicitFunction



        >  casadi::ImplicitFunction::ImplicitFunction()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::ImplicitFunction::ImplicitFunction(const std::string &name, const Function &f, const Function &jac=Function(), const LinearSolver &linsol=LinearSolver())
        ------------------------------------------------------------------------

        Create an implicit function solver.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_ImplicitFunction_kinsol'>kinsol</a>

        - <a href='#plugin_ImplicitFunction_nlp'>nlp</a>

        - <a href='#plugin_ImplicitFunction_newton'>newton</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        ImplicitFunction.doc("myextraplugin")

        Parameters:
        -----------

        f:   Function mapping from (n+1) inputs to 1 output


        """
        this = _casadi_core.new_ImplicitFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ImplicitFunction
ImplicitFunction_swigregister = _casadi_core.ImplicitFunction_swigregister
ImplicitFunction_swigregister(ImplicitFunction)

def ImplicitFunction_testCast(*args):
    """ImplicitFunction_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.ImplicitFunction_testCast(*args)

def ImplicitFunction_hasPlugin(*args):
    """ImplicitFunction_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.ImplicitFunction_hasPlugin(*args)

def ImplicitFunction_loadPlugin(*args):
    """ImplicitFunction_loadPlugin(std::string const & name)"""
    return _casadi_core.ImplicitFunction_loadPlugin(*args)

def ImplicitFunction_doc(*args):
    """ImplicitFunction_doc(std::string const & name) -> std::string"""
    return _casadi_core.ImplicitFunction_doc(*args)


_casadi_core.DAE_X_swigconstant(_casadi_core)
DAE_X = _casadi_core.DAE_X

_casadi_core.DAE_Z_swigconstant(_casadi_core)
DAE_Z = _casadi_core.DAE_Z

_casadi_core.DAE_P_swigconstant(_casadi_core)
DAE_P = _casadi_core.DAE_P

_casadi_core.DAE_T_swigconstant(_casadi_core)
DAE_T = _casadi_core.DAE_T

_casadi_core.DAE_NUM_IN_swigconstant(_casadi_core)
DAE_NUM_IN = _casadi_core.DAE_NUM_IN

_casadi_core.DAE_ODE_swigconstant(_casadi_core)
DAE_ODE = _casadi_core.DAE_ODE

_casadi_core.DAE_ALG_swigconstant(_casadi_core)
DAE_ALG = _casadi_core.DAE_ALG

_casadi_core.DAE_QUAD_swigconstant(_casadi_core)
DAE_QUAD = _casadi_core.DAE_QUAD

_casadi_core.DAE_NUM_OUT_swigconstant(_casadi_core)
DAE_NUM_OUT = _casadi_core.DAE_NUM_OUT

_casadi_core.RDAE_RX_swigconstant(_casadi_core)
RDAE_RX = _casadi_core.RDAE_RX

_casadi_core.RDAE_RZ_swigconstant(_casadi_core)
RDAE_RZ = _casadi_core.RDAE_RZ

_casadi_core.RDAE_RP_swigconstant(_casadi_core)
RDAE_RP = _casadi_core.RDAE_RP

_casadi_core.RDAE_X_swigconstant(_casadi_core)
RDAE_X = _casadi_core.RDAE_X

_casadi_core.RDAE_Z_swigconstant(_casadi_core)
RDAE_Z = _casadi_core.RDAE_Z

_casadi_core.RDAE_P_swigconstant(_casadi_core)
RDAE_P = _casadi_core.RDAE_P

_casadi_core.RDAE_T_swigconstant(_casadi_core)
RDAE_T = _casadi_core.RDAE_T

_casadi_core.RDAE_NUM_IN_swigconstant(_casadi_core)
RDAE_NUM_IN = _casadi_core.RDAE_NUM_IN

_casadi_core.RDAE_ODE_swigconstant(_casadi_core)
RDAE_ODE = _casadi_core.RDAE_ODE

_casadi_core.RDAE_ALG_swigconstant(_casadi_core)
RDAE_ALG = _casadi_core.RDAE_ALG

_casadi_core.RDAE_QUAD_swigconstant(_casadi_core)
RDAE_QUAD = _casadi_core.RDAE_QUAD

_casadi_core.RDAE_NUM_OUT_swigconstant(_casadi_core)
RDAE_NUM_OUT = _casadi_core.RDAE_NUM_OUT

_casadi_core.INTEGRATOR_X0_swigconstant(_casadi_core)
INTEGRATOR_X0 = _casadi_core.INTEGRATOR_X0

_casadi_core.INTEGRATOR_P_swigconstant(_casadi_core)
INTEGRATOR_P = _casadi_core.INTEGRATOR_P

_casadi_core.INTEGRATOR_Z0_swigconstant(_casadi_core)
INTEGRATOR_Z0 = _casadi_core.INTEGRATOR_Z0

_casadi_core.INTEGRATOR_RX0_swigconstant(_casadi_core)
INTEGRATOR_RX0 = _casadi_core.INTEGRATOR_RX0

_casadi_core.INTEGRATOR_RP_swigconstant(_casadi_core)
INTEGRATOR_RP = _casadi_core.INTEGRATOR_RP

_casadi_core.INTEGRATOR_RZ0_swigconstant(_casadi_core)
INTEGRATOR_RZ0 = _casadi_core.INTEGRATOR_RZ0

_casadi_core.INTEGRATOR_NUM_IN_swigconstant(_casadi_core)
INTEGRATOR_NUM_IN = _casadi_core.INTEGRATOR_NUM_IN

_casadi_core.INTEGRATOR_XF_swigconstant(_casadi_core)
INTEGRATOR_XF = _casadi_core.INTEGRATOR_XF

_casadi_core.INTEGRATOR_QF_swigconstant(_casadi_core)
INTEGRATOR_QF = _casadi_core.INTEGRATOR_QF

_casadi_core.INTEGRATOR_ZF_swigconstant(_casadi_core)
INTEGRATOR_ZF = _casadi_core.INTEGRATOR_ZF

_casadi_core.INTEGRATOR_RXF_swigconstant(_casadi_core)
INTEGRATOR_RXF = _casadi_core.INTEGRATOR_RXF

_casadi_core.INTEGRATOR_RQF_swigconstant(_casadi_core)
INTEGRATOR_RQF = _casadi_core.INTEGRATOR_RQF

_casadi_core.INTEGRATOR_RZF_swigconstant(_casadi_core)
INTEGRATOR_RZF = _casadi_core.INTEGRATOR_RZF

_casadi_core.INTEGRATOR_NUM_OUT_swigconstant(_casadi_core)
INTEGRATOR_NUM_OUT = _casadi_core.INTEGRATOR_NUM_OUT
class Integrator(Function):
    """


    Base class for integrators.

    Integrator abstract base class

    Solves an initial value problem (IVP) coupled to a terminal value problem
    with differential equation given as an implicit ODE coupled to an algebraic
    equation and a set of quadratures:

    ::

       Initial conditions at t=t0
       x(t0)  = x0
       q(t0)  = 0

       Forward integration from t=t0 to t=tf
       der(x) = function(x, z, p, t)                  Forward ODE
       0 = fz(x, z, p, t)                  Forward algebraic equations
       der(q) = fq(x, z, p, t)                  Forward quadratures

       Terminal conditions at t=tf
       rx(tf)  = rx0
       rq(tf)  = 0

       Backward integration from t=tf to t=t0
       der(rx) = gx(rx, rz, rp, x, z, p, t)        Backward ODE
       0 = gz(rx, rz, rp, x, z, p, t)        Backward algebraic equations
       der(rq) = gq(rx, rz, rp, x, z, p, t)        Backward quadratures

       where we assume that both the forward and backwards integrations are index-1
       (i.e. dfz/dz, dgz/drz are invertible) and furthermore that
       gx, gz and gq have a linear dependency on rx, rz and rp.



    The Integrator class provides some additional functionality, such as getting
    the value of the state and/or sensitivities at certain time points.

    General information
    ===================



    >Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6) [integratorIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | INTEGRATOR_X0          | x0                     | Differential state at  |
    |                        |                        | the initial time .     |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_P           | p                      | Parameters .           |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_Z0          | z0                     | Initial guess for the  |
    |                        |                        | algebraic variable .   |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RX0         | rx0                    | Backward differential  |
    |                        |                        | state at the final     |
    |                        |                        | time .                 |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RP          | rp                     | Backward parameter     |
    |                        |                        | vector .               |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RZ0         | rz0                    | Initial guess for the  |
    |                        |                        | backwards algebraic    |
    |                        |                        | variable .             |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::IntegratorOutput (INTEGRATOR_NUM_OUT = 6) [integratorOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | INTEGRATOR_XF          | xf                     | Differential state at  |
    |                        |                        | the final time .       |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_QF          | qf                     | Quadrature state at    |
    |                        |                        | the final time .       |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_ZF          | zf                     | Algebraic variable at  |
    |                        |                        | the final time .       |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RXF         | rxf                    | Backward differential  |
    |                        |                        | state at the initial   |
    |                        |                        | time .                 |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RQF         | rqf                    | Backward quadrature    |
    |                        |                        | state at the initial   |
    |                        |                        | time .                 |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RZF         | rzf                    | Backward algebraic     |
    |                        |                        | variable at the        |
    |                        |                        | initial time .         |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | augmented_op | OT_DICTIONAR | GenericType( | Options to   | casadi::Inte |
    | tions        | Y            | )            | be passed    | gratorIntern |
    |              |              |              | down to the  | al           |
    |              |              |              | augmented    |              |
    |              |              |              | integrator,  |              |
    |              |              |              | if one is    |              |
    |              |              |              | constructed. |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | expand_augme | OT_BOOLEAN   | true         | If DAE       | casadi::Inte |
    | nted         |              |              | callback     | gratorIntern |
    |              |              |              | functions    | al           |
    |              |              |              | are          |              |
    |              |              |              | SXFunction , |              |
    |              |              |              | have         |              |
    |              |              |              | augmented    |              |
    |              |              |              | DAE callback |              |
    |              |              |              | function     |              |
    |              |              |              | also be      |              |
    |              |              |              | SXFunction . |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | print_stats  | OT_BOOLEAN   | false        | Print out    | casadi::Inte |
    |              |              |              | statistics   | gratorIntern |
    |              |              |              | after        | al           |
    |              |              |              | integration  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | t0           | OT_REAL      | 0            | Beginning of | casadi::Inte |
    |              |              |              | the time     | gratorIntern |
    |              |              |              | horizon      | al           |
    +--------------+--------------+--------------+--------------+--------------+
    | tf           | OT_REAL      | 1            | End of the   | casadi::Inte |
    |              |              |              | time horizon | gratorIntern |
    |              |              |              |              | al           |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_Integrator_cvodes'>cvodes</a>

    - <a href='#plugin_Integrator_idas'>idas</a>

    - <a href='#plugin_Integrator_collocation'>collocation</a>

    - <a href='#plugin_Integrator_oldcollocation'>oldcollocation</a>

    - <a href='#plugin_Integrator_rk'>rk</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Integrator.doc("myextraplugin")



    --------------------------------------------------------------------------------

    cvodes
    ------



    Interface to CVodes from the Sundials suite.

    A call to evaluate will integrate to the end.

    You can retrieve the entire state trajectory as follows, after the evaluate
    call: Call reset. Then call integrate(t_i) and getOuput for a series of
    times t_i.

    Note: depending on the dimension and structure of your problem, you may
    experience a dramatic speed-up by using a sparse linear solver:



    ::

         intg.setOption("linear_solver","csparse")
         intg.setOption("linear_solver_type","user_defined")



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | abstol          | OT_REAL         | 0.000           | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the IVP         |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | abstolB         | OT_REAL         | GenericType()   | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the adjoint     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to abstol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | disable_interna | OT_BOOLEAN      | false           | Disable CVodes  |
    | l_warnings      |                 |                 | internal        |
    |                 |                 |                 | warning         |
    |                 |                 |                 | messages        |
    +-----------------+-----------------+-----------------+-----------------+
    | exact_jacobian  | OT_BOOLEAN      | true            | Use exact       |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | information for |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | integration     |
    +-----------------+-----------------+-----------------+-----------------+
    | exact_jacobianB | OT_BOOLEAN      | GenericType()   | Use exact       |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | information for |
    |                 |                 |                 | the backward    |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to              |
    |                 |                 |                 | exact_jacobian] |
    +-----------------+-----------------+-----------------+-----------------+
    | finite_differen | OT_BOOLEAN      | false           | Use finite      |
    | ce_fsens        |                 |                 | differences to  |
    |                 |                 |                 | approximate the |
    |                 |                 |                 | forward         |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | equations (if   |
    |                 |                 |                 | AD is not       |
    |                 |                 |                 | available)      |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_abstol    | OT_REAL         | GenericType()   | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to abstol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_all_at_on | OT_BOOLEAN      | true            | Calculate all   |
    | ce              |                 |                 | right hand      |
    |                 |                 |                 | sides of the    |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | equations at    |
    |                 |                 |                 | once            |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_err_con   | OT_BOOLEAN      | true            | include the     |
    |                 |                 |                 | forward         |
    |                 |                 |                 | sensitivities   |
    |                 |                 |                 | in all error    |
    |                 |                 |                 | controls        |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_reltol    | OT_REAL         | GenericType()   | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to reltol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_scaling_f | OT_REALVECTOR   | GenericType()   | Scaling factor  |
    | actors          |                 |                 | for the         |
    |                 |                 |                 | components if   |
    |                 |                 |                 | finite          |
    |                 |                 |                 | differences is  |
    |                 |                 |                 | used            |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_sensitivi | OT_INTEGERVECTO | GenericType()   | Specifies which |
    | y_parameters    | R               |                 | components will |
    |                 |                 |                 | be used when    |
    |                 |                 |                 | estimating the  |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | equations       |
    +-----------------+-----------------+-----------------+-----------------+
    | interpolation_t | OT_STRING       | "hermite"       | Type of         |
    | ype             |                 |                 | interpolation   |
    |                 |                 |                 | for the adjoint |
    |                 |                 |                 | sensitivities ( |
    |                 |                 |                 | hermite|polynom |
    |                 |                 |                 | ial)            |
    +-----------------+-----------------+-----------------+-----------------+
    | iterative_solve | OT_STRING       | "gmres"         | (gmres|bcgstab| |
    | r               |                 |                 | tfqmr)          |
    +-----------------+-----------------+-----------------+-----------------+
    | iterative_solve | OT_STRING       | GenericType()   | (gmres|bcgstab| |
    | rB              |                 |                 | tfqmr)          |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_multiste | OT_STRING       | "bdf"           | Integrator      |
    | p_method        |                 |                 | scheme          |
    |                 |                 |                 | (bdf|adams)     |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver   | OT_STRING       | GenericType()   | A custom linear |
    |                 |                 |                 | solver creator  |
    |                 |                 |                 | function        |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solverB  | OT_STRING       | GenericType()   | A custom linear |
    |                 |                 |                 | solver creator  |
    |                 |                 |                 | function for    |
    |                 |                 |                 | backwards       |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to              |
    |                 |                 |                 | linear_solver]  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver   |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptionsB         |                 |                 | passed to the   |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | for backwards   |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to linear_solve |
    |                 |                 |                 | r_options]      |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_t | OT_STRING       | "dense"         | (user_defined|d |
    | ype             |                 |                 | ense|banded|ite |
    |                 |                 |                 | rative)         |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_t | OT_STRING       | GenericType()   | (user_defined|d |
    | ypeB            |                 |                 | ense|banded|ite |
    |                 |                 |                 | rative)         |
    +-----------------+-----------------+-----------------+-----------------+
    | lower_bandwidth | OT_INTEGER      | GenericType()   | Lower band-     |
    |                 |                 |                 | width of banded |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | (estimations)   |
    +-----------------+-----------------+-----------------+-----------------+
    | lower_bandwidth | OT_INTEGER      | GenericType()   | lower band-     |
    | B               |                 |                 | width of banded |
    |                 |                 |                 | jacobians for   |
    |                 |                 |                 | backward        |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to lower_bandwi |
    |                 |                 |                 | dth]            |
    +-----------------+-----------------+-----------------+-----------------+
    | max_krylov      | OT_INTEGER      | 10              | Maximum Krylov  |
    |                 |                 |                 | subspace size   |
    +-----------------+-----------------+-----------------+-----------------+
    | max_krylovB     | OT_INTEGER      | GenericType()   | Maximum krylov  |
    |                 |                 |                 | subspace size   |
    +-----------------+-----------------+-----------------+-----------------+
    | max_multistep_o | OT_INTEGER      | 5               |                 |
    | rder            |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | max_num_steps   | OT_INTEGER      | 10000           | Maximum number  |
    |                 |                 |                 | of integrator   |
    |                 |                 |                 | steps           |
    +-----------------+-----------------+-----------------+-----------------+
    | nonlinear_solve | OT_STRING       | "newton"        | (newton|functio |
    | r_iteration     |                 |                 | nal)            |
    +-----------------+-----------------+-----------------+-----------------+
    | pretype         | OT_STRING       | "none"          | (none|left|righ |
    |                 |                 |                 | t|both)         |
    +-----------------+-----------------+-----------------+-----------------+
    | pretypeB        | OT_STRING       | GenericType()   | (none|left|righ |
    |                 |                 |                 | t|both)         |
    +-----------------+-----------------+-----------------+-----------------+
    | quad_err_con    | OT_BOOLEAN      | false           | Should the      |
    |                 |                 |                 | quadratures     |
    |                 |                 |                 | affect the step |
    |                 |                 |                 | size control    |
    +-----------------+-----------------+-----------------+-----------------+
    | reltol          | OT_REAL         | 0.000           | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the IVP         |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | reltolB         | OT_REAL         | GenericType()   | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the adjoint     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to reltol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | sensitivity_met | OT_STRING       | "simultaneous"  | (simultaneous|s |
    | hod             |                 |                 | taggered)       |
    +-----------------+-----------------+-----------------+-----------------+
    | steps_per_check | OT_INTEGER      | 20              | Number of steps |
    | point           |                 |                 | between two     |
    |                 |                 |                 | consecutive     |
    |                 |                 |                 | checkpoints     |
    +-----------------+-----------------+-----------------+-----------------+
    | stop_at_end     | OT_BOOLEAN      | true            | Stop the        |
    |                 |                 |                 | integrator at   |
    |                 |                 |                 | the end of the  |
    |                 |                 |                 | interval        |
    +-----------------+-----------------+-----------------+-----------------+
    | upper_bandwidth | OT_INTEGER      | GenericType()   | Upper band-     |
    |                 |                 |                 | width of banded |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | (estimations)   |
    +-----------------+-----------------+-----------------+-----------------+
    | upper_bandwidth | OT_INTEGER      | GenericType()   | Upper band-     |
    | B               |                 |                 | width of banded |
    |                 |                 |                 | jacobians for   |
    |                 |                 |                 | backward        |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to upper_bandwi |
    |                 |                 |                 | dth]            |
    +-----------------+-----------------+-----------------+-----------------+
    | use_preconditio | OT_BOOLEAN      | false           | Precondition an |
    | ner             |                 |                 | iterative       |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+
    | use_preconditio | OT_BOOLEAN      | GenericType()   | Precondition an |
    | nerB            |                 |                 | iterative       |
    |                 |                 |                 | solver for the  |
    |                 |                 |                 | backwards       |
    |                 |                 |                 | problem         |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to use_precondi |
    |                 |                 |                 | tioner]         |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +---------+
    |   Id    |
    +=========+
    | djacB   |
    +---------+
    | psetupB |
    +---------+
    | res     |
    +---------+
    | resB    |
    +---------+
    | resQB   |
    +---------+
    | reset   |
    +---------+

    >List of available stats

    +-------------+
    |     Id      |
    +=============+
    | nlinsetups  |
    +-------------+
    | nlinsetupsB |
    +-------------+
    | nsteps      |
    +-------------+
    | nstepsB     |
    +-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    idas
    ----



    Interface to IDAS from the Sundials suite.

    Note: depending on the dimension and structure of your problem, you may
    experience a dramatic speed-up by using a sparse linear solver:



    ::

         intg.setOption("linear_solver","csparse")
         intg.setOption("linear_solver_type","user_defined")



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | abstol          | OT_REAL         | 0.000           | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the IVP         |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | abstolB         | OT_REAL         | GenericType()   | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the adjoint     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to abstol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | abstolv         | OT_REALVECTOR   |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | calc_ic         | OT_BOOLEAN      | true            | Use IDACalcIC   |
    |                 |                 |                 | to get          |
    |                 |                 |                 | consistent      |
    |                 |                 |                 | initial         |
    |                 |                 |                 | conditions.     |
    +-----------------+-----------------+-----------------+-----------------+
    | calc_icB        | OT_BOOLEAN      | GenericType()   | Use IDACalcIC   |
    |                 |                 |                 | to get          |
    |                 |                 |                 | consistent      |
    |                 |                 |                 | initial         |
    |                 |                 |                 | conditions for  |
    |                 |                 |                 | backwards       |
    |                 |                 |                 | system          |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to calc_ic].    |
    +-----------------+-----------------+-----------------+-----------------+
    | cj_scaling      | OT_BOOLEAN      | false           | IDAS scaling on |
    |                 |                 |                 | cj for the      |
    |                 |                 |                 | user-defined    |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | module          |
    +-----------------+-----------------+-----------------+-----------------+
    | disable_interna | OT_BOOLEAN      | false           | Disable IDAS    |
    | l_warnings      |                 |                 | internal        |
    |                 |                 |                 | warning         |
    |                 |                 |                 | messages        |
    +-----------------+-----------------+-----------------+-----------------+
    | exact_jacobian  | OT_BOOLEAN      | true            | Use exact       |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | information for |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | integration     |
    +-----------------+-----------------+-----------------+-----------------+
    | exact_jacobianB | OT_BOOLEAN      | GenericType()   | Use exact       |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | information for |
    |                 |                 |                 | the backward    |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to              |
    |                 |                 |                 | exact_jacobian] |
    +-----------------+-----------------+-----------------+-----------------+
    | extra_fsens_cal | OT_BOOLEAN      | false           | Call calc ic an |
    | c_ic            |                 |                 | extra time,     |
    |                 |                 |                 | with fsens=0    |
    +-----------------+-----------------+-----------------+-----------------+
    | finite_differen | OT_BOOLEAN      | false           | Use finite      |
    | ce_fsens        |                 |                 | differences to  |
    |                 |                 |                 | approximate the |
    |                 |                 |                 | forward         |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | equations (if   |
    |                 |                 |                 | AD is not       |
    |                 |                 |                 | available)      |
    +-----------------+-----------------+-----------------+-----------------+
    | first_time      | OT_REAL         | GenericType()   | First requested |
    |                 |                 |                 | time as a       |
    |                 |                 |                 | fraction of the |
    |                 |                 |                 | time interval   |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_abstol    | OT_REAL         | GenericType()   | Absolute        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to abstol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_abstolv   | OT_REALVECTOR   |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_err_con   | OT_BOOLEAN      | true            | include the     |
    |                 |                 |                 | forward         |
    |                 |                 |                 | sensitivities   |
    |                 |                 |                 | in all error    |
    |                 |                 |                 | controls        |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_reltol    | OT_REAL         | GenericType()   | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the forward     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to reltol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_scaling_f | OT_REALVECTOR   | GenericType()   | Scaling factor  |
    | actors          |                 |                 | for the         |
    |                 |                 |                 | components if   |
    |                 |                 |                 | finite          |
    |                 |                 |                 | differences is  |
    |                 |                 |                 | used            |
    +-----------------+-----------------+-----------------+-----------------+
    | fsens_sensitivi | OT_INTEGERVECTO | GenericType()   | Specifies which |
    | y_parameters    | R               |                 | components will |
    |                 |                 |                 | be used when    |
    |                 |                 |                 | estimating the  |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | equations       |
    +-----------------+-----------------+-----------------+-----------------+
    | init_xdot       | OT_REALVECTOR   | GenericType()   | Initial values  |
    |                 |                 |                 | for the state   |
    |                 |                 |                 | derivatives     |
    +-----------------+-----------------+-----------------+-----------------+
    | interpolation_t | OT_STRING       | "hermite"       | Type of         |
    | ype             |                 |                 | interpolation   |
    |                 |                 |                 | for the adjoint |
    |                 |                 |                 | sensitivities ( |
    |                 |                 |                 | hermite|polynom |
    |                 |                 |                 | ial)            |
    +-----------------+-----------------+-----------------+-----------------+
    | iterative_solve | OT_STRING       | "gmres"         | (gmres|bcgstab| |
    | r               |                 |                 | tfqmr)          |
    +-----------------+-----------------+-----------------+-----------------+
    | iterative_solve | OT_STRING       | GenericType()   | (gmres|bcgstab| |
    | rB              |                 |                 | tfqmr)          |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver   | OT_STRING       | GenericType()   | A custom linear |
    |                 |                 |                 | solver creator  |
    |                 |                 |                 | function        |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solverB  | OT_STRING       | GenericType()   | A custom linear |
    |                 |                 |                 | solver creator  |
    |                 |                 |                 | function for    |
    |                 |                 |                 | backwards       |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to              |
    |                 |                 |                 | linear_solver]  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver   |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptionsB         |                 |                 | passed to the   |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | for backwards   |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to linear_solve |
    |                 |                 |                 | r_options]      |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_t | OT_STRING       | "dense"         | (user_defined|d |
    | ype             |                 |                 | ense|banded|ite |
    |                 |                 |                 | rative)         |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_t | OT_STRING       | GenericType()   | (user_defined|d |
    | ypeB            |                 |                 | ense|banded|ite |
    |                 |                 |                 | rative)         |
    +-----------------+-----------------+-----------------+-----------------+
    | lower_bandwidth | OT_INTEGER      | GenericType()   | Lower band-     |
    |                 |                 |                 | width of banded |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | (estimations)   |
    +-----------------+-----------------+-----------------+-----------------+
    | lower_bandwidth | OT_INTEGER      | GenericType()   | lower band-     |
    | B               |                 |                 | width of banded |
    |                 |                 |                 | jacobians for   |
    |                 |                 |                 | backward        |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to lower_bandwi |
    |                 |                 |                 | dth]            |
    +-----------------+-----------------+-----------------+-----------------+
    | max_krylov      | OT_INTEGER      | 10              | Maximum Krylov  |
    |                 |                 |                 | subspace size   |
    +-----------------+-----------------+-----------------+-----------------+
    | max_krylovB     | OT_INTEGER      | GenericType()   | Maximum krylov  |
    |                 |                 |                 | subspace size   |
    +-----------------+-----------------+-----------------+-----------------+
    | max_multistep_o | OT_INTEGER      | 5               |                 |
    | rder            |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | max_num_steps   | OT_INTEGER      | 10000           | Maximum number  |
    |                 |                 |                 | of integrator   |
    |                 |                 |                 | steps           |
    +-----------------+-----------------+-----------------+-----------------+
    | max_step_size   | OT_REAL         | 0               | Maximim step    |
    |                 |                 |                 | size            |
    +-----------------+-----------------+-----------------+-----------------+
    | pretype         | OT_STRING       | "none"          | (none|left|righ |
    |                 |                 |                 | t|both)         |
    +-----------------+-----------------+-----------------+-----------------+
    | pretypeB        | OT_STRING       | GenericType()   | (none|left|righ |
    |                 |                 |                 | t|both)         |
    +-----------------+-----------------+-----------------+-----------------+
    | quad_err_con    | OT_BOOLEAN      | false           | Should the      |
    |                 |                 |                 | quadratures     |
    |                 |                 |                 | affect the step |
    |                 |                 |                 | size control    |
    +-----------------+-----------------+-----------------+-----------------+
    | reltol          | OT_REAL         | 0.000           | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the IVP         |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | reltolB         | OT_REAL         | GenericType()   | Relative        |
    |                 |                 |                 | tolerence for   |
    |                 |                 |                 | the adjoint     |
    |                 |                 |                 | sensitivity     |
    |                 |                 |                 | solution        |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to reltol]      |
    +-----------------+-----------------+-----------------+-----------------+
    | sensitivity_met | OT_STRING       | "simultaneous"  | (simultaneous|s |
    | hod             |                 |                 | taggered)       |
    +-----------------+-----------------+-----------------+-----------------+
    | steps_per_check | OT_INTEGER      | 20              | Number of steps |
    | point           |                 |                 | between two     |
    |                 |                 |                 | consecutive     |
    |                 |                 |                 | checkpoints     |
    +-----------------+-----------------+-----------------+-----------------+
    | stop_at_end     | OT_BOOLEAN      | true            | Stop the        |
    |                 |                 |                 | integrator at   |
    |                 |                 |                 | the end of the  |
    |                 |                 |                 | interval        |
    +-----------------+-----------------+-----------------+-----------------+
    | suppress_algebr | OT_BOOLEAN      | false           | Suppress        |
    | aic             |                 |                 | algebraic       |
    |                 |                 |                 | variables in    |
    |                 |                 |                 | the error       |
    |                 |                 |                 | testing         |
    +-----------------+-----------------+-----------------+-----------------+
    | upper_bandwidth | OT_INTEGER      | GenericType()   | Upper band-     |
    |                 |                 |                 | width of banded |
    |                 |                 |                 | Jacobian        |
    |                 |                 |                 | (estimations)   |
    +-----------------+-----------------+-----------------+-----------------+
    | upper_bandwidth | OT_INTEGER      | GenericType()   | Upper band-     |
    | B               |                 |                 | width of banded |
    |                 |                 |                 | jacobians for   |
    |                 |                 |                 | backward        |
    |                 |                 |                 | integration     |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to upper_bandwi |
    |                 |                 |                 | dth]            |
    +-----------------+-----------------+-----------------+-----------------+
    | use_preconditio | OT_BOOLEAN      | false           | Precondition an |
    | ner             |                 |                 | iterative       |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+
    | use_preconditio | OT_BOOLEAN      | GenericType()   | Precondition an |
    | nerB            |                 |                 | iterative       |
    |                 |                 |                 | solver for the  |
    |                 |                 |                 | backwards       |
    |                 |                 |                 | problem         |
    |                 |                 |                 | [default: equal |
    |                 |                 |                 | to use_precondi |
    |                 |                 |                 | tioner]         |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +--------------------------+
    |            Id            |
    +==========================+
    | bjacB                    |
    +--------------------------+
    | correctInitialConditions |
    +--------------------------+
    | jtimesB                  |
    +--------------------------+
    | psetup                   |
    +--------------------------+
    | psetupB                  |
    +--------------------------+
    | psolveB                  |
    +--------------------------+
    | res                      |
    +--------------------------+
    | resB                     |
    +--------------------------+
    | resS                     |
    +--------------------------+
    | rhsQB                    |
    +--------------------------+

    >List of available stats

    +-------------+
    |     Id      |
    +=============+
    | nlinsetups  |
    +-------------+
    | nlinsetupsB |
    +-------------+
    | nsteps      |
    +-------------+
    | nstepsB     |
    +-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    collocation
    -----------



    Fixed-step implicit Runge-Kutta integrator ODE/DAE integrator based on
    collocation schemes

    The method is still under development

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | collocation_sch | OT_STRING       | "radau"         | Collocation     |
    | eme             |                 |                 | scheme (radau|l |
    |                 |                 |                 | egendre)        |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_solver | OT_STRING       | GenericType()   | An implicit     |
    |                 |                 |                 | function solver |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_solver | OT_DICTIONARY   | GenericType()   | Options to be   |
    | _options        |                 |                 | passed to the   |
    |                 |                 |                 | NLP Solver      |
    +-----------------+-----------------+-----------------+-----------------+
    | interpolation_o | OT_INTEGER      | 3               | Order of the    |
    | rder            |                 |                 | interpolating   |
    |                 |                 |                 | polynomials     |
    +-----------------+-----------------+-----------------+-----------------+
    | number_of_finit | OT_INTEGER      | 20              | Number of       |
    | e_elements      |                 |                 | finite elements |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    oldcollocation
    --------------



    Collocation integrator ODE/DAE integrator based on collocation

    The method is still under development

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | collocation_sch | OT_STRING       | "radau"         | Collocation     |
    | eme             |                 |                 | scheme (radau|l |
    |                 |                 |                 | egendre)        |
    +-----------------+-----------------+-----------------+-----------------+
    | expand_f        | OT_BOOLEAN      | false           | Expand the      |
    |                 |                 |                 | ODE/DAE         |
    |                 |                 |                 | residual        |
    |                 |                 |                 | function in an  |
    |                 |                 |                 | SX graph        |
    +-----------------+-----------------+-----------------+-----------------+
    | expand_q        | OT_BOOLEAN      | false           | Expand the      |
    |                 |                 |                 | quadrature      |
    |                 |                 |                 | function in an  |
    |                 |                 |                 | SX graph        |
    +-----------------+-----------------+-----------------+-----------------+
    | hotstart        | OT_BOOLEAN      | true            | Initialize the  |
    |                 |                 |                 | trajectory at   |
    |                 |                 |                 | the previous    |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_solver | OT_STRING       | GenericType()   | An implicit     |
    |                 |                 |                 | function solver |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_solver | OT_DICTIONARY   | GenericType()   | Options to be   |
    | _options        |                 |                 | passed to the   |
    |                 |                 |                 | implicit solver |
    +-----------------+-----------------+-----------------+-----------------+
    | interpolation_o | OT_INTEGER      | 3               | Order of the    |
    | rder            |                 |                 | interpolating   |
    |                 |                 |                 | polynomials     |
    +-----------------+-----------------+-----------------+-----------------+
    | number_of_finit | OT_INTEGER      | 20              | Number of       |
    | e_elements      |                 |                 | finite elements |
    +-----------------+-----------------+-----------------+-----------------+
    | startup_integra | OT_STRING       | GenericType()   | An ODE/DAE      |
    | tor             |                 |                 | integrator that |
    |                 |                 |                 | can be used to  |
    |                 |                 |                 | generate a      |
    |                 |                 |                 | startup         |
    |                 |                 |                 | trajectory      |
    +-----------------+-----------------+-----------------+-----------------+
    | startup_integra | OT_DICTIONARY   | GenericType()   | Options to be   |
    | tor_options     |                 |                 | passed to the   |
    |                 |                 |                 | startup         |
    |                 |                 |                 | integrator      |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    rk --



    Fixed-step explicit Runge-Kutta integrator for ODEs Currently implements
    RK4.

    The method is still under development

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | number_of_finit | OT_INTEGER      | 20              | Number of       |
    | e_elements      |                 |                 | finite elements |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: integrator.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Integrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Integrator, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(Integrator self) -> Integrator



        Clone.


        """
        return _casadi_core.Integrator_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(Integrator self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.Integrator_printStats(self, *args)


    def reset(self, *args):
        """
        reset(Integrator self)



        Reset the forward problem Time will be set to t0 and state to
        input(INTEGRATOR_X0)


        """
        return _casadi_core.Integrator_reset(self, *args)


    def integrate(self, *args):
        """
        integrate(Integrator self, double t_out)



        Integrate forward until a specified time point.


        """
        return _casadi_core.Integrator_integrate(self, *args)


    def resetB(self, *args):
        """
        resetB(Integrator self)



        Reset the backward problem.

        Time will be set to tf and backward state to input(INTEGRATOR_RX0)


        """
        return _casadi_core.Integrator_resetB(self, *args)


    def integrateB(self, *args):
        """
        integrateB(Integrator self, double t_out)



        Integrate backward until a specified time point.


        """
        return _casadi_core.Integrator_integrateB(self, *args)


    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.Integrator_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.Integrator_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.Integrator_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def getAugmented(self, *args):
        """
        getAugmented(Integrator self, int nfwd, int nadj) -> Pair_Function_Function



        Generate a augmented DAE system with nfwd forward sensitivities and nadj
        adjoint sensitivities.


        """
        return _casadi_core.Integrator_getAugmented(self, *args)


    def getDAE(self, *args):
        """
        getDAE(Integrator self) -> Function



        Get the DAE.


        """
        return _casadi_core.Integrator_getDAE(self, *args)


    def setStopTime(self, *args):
        """
        setStopTime(Integrator self, double tf)



        Set a stop time for the forward integration.


        """
        return _casadi_core.Integrator_setStopTime(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.Integrator_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::Integrator self) -> Integrator
        __init__(casadi::Integrator self, std::string const & name, Function f, Function g) -> Integrator
        __init__(casadi::Integrator self, Integrator other) -> Integrator



        >  casadi::Integrator::Integrator()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::Integrator::Integrator(const std::string &name, const Function &f, const Function &g=Function())
        ------------------------------------------------------------------------

        Integrator factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_Integrator_cvodes'>cvodes</a>

        - <a href='#plugin_Integrator_idas'>idas</a>

        - <a href='#plugin_Integrator_collocation'>collocation</a>

        - <a href='#plugin_Integrator_oldcollocation'>oldcollocation</a>

        - <a href='#plugin_Integrator_rk'>rk</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        Integrator.doc("myextraplugin")

        Parameters:
        -----------

        f:  dynamical system

        >Input scheme: casadi::DAEInput (DAE_NUM_IN = 4) [daeIn]

        +-----------+-------+----------------------------+
        | Full name | Short |        Description         |
        +===========+=======+============================+
        | DAE_X     | x     | Differential state .       |
        +-----------+-------+----------------------------+
        | DAE_Z     | z     | Algebraic state .          |
        +-----------+-------+----------------------------+
        | DAE_P     | p     | Parameter .                |
        +-----------+-------+----------------------------+
        | DAE_T     | t     | Explicit time dependence . |
        +-----------+-------+----------------------------+

        >Output scheme: casadi::DAEOutput (DAE_NUM_OUT = 3) [daeOut]

        +-----------+-------+--------------------------------------------+
        | Full name | Short |                Description                 |
        +===========+=======+============================================+
        | DAE_ODE   | ode   | Right hand side of the implicit ODE .      |
        +-----------+-------+--------------------------------------------+
        | DAE_ALG   | alg   | Right hand side of algebraic equations .   |
        +-----------+-------+--------------------------------------------+
        | DAE_QUAD  | quad  | Right hand side of quadratures equations . |
        +-----------+-------+--------------------------------------------+

        Parameters:
        -----------

        g:  backwards system

        >Input scheme: casadi::RDAEInput (RDAE_NUM_IN = 7) [rdaeIn]

        +-----------+-------+-------------------------------+
        | Full name | Short |          Description          |
        +===========+=======+===============================+
        | RDAE_RX   | rx    | Backward differential state . |
        +-----------+-------+-------------------------------+
        | RDAE_RZ   | rz    | Backward algebraic state .    |
        +-----------+-------+-------------------------------+
        | RDAE_RP   | rp    | Backward parameter vector .   |
        +-----------+-------+-------------------------------+
        | RDAE_X    | x     | Forward differential state .  |
        +-----------+-------+-------------------------------+
        | RDAE_Z    | z     | Forward algebraic state .     |
        +-----------+-------+-------------------------------+
        | RDAE_P    | p     | Parameter vector .            |
        +-----------+-------+-------------------------------+
        | RDAE_T    | t     | Explicit time dependence .    |
        +-----------+-------+-------------------------------+

        >Output scheme: casadi::RDAEOutput (RDAE_NUM_OUT = 3) [rdaeOut]

        +-----------+-------+-------------------------------------------+
        | Full name | Short |                Description                |
        +===========+=======+===========================================+
        | RDAE_ODE  | ode   | Right hand side of ODE. .                 |
        +-----------+-------+-------------------------------------------+
        | RDAE_ALG  | alg   | Right hand side of algebraic equations. . |
        +-----------+-------+-------------------------------------------+
        | RDAE_QUAD | quad  | Right hand side of quadratures. .         |
        +-----------+-------+-------------------------------------------+


        """
        this = _casadi_core.new_Integrator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Integrator
Integrator_swigregister = _casadi_core.Integrator_swigregister
Integrator_swigregister(Integrator)

def Integrator_hasPlugin(*args):
    """Integrator_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.Integrator_hasPlugin(*args)

def Integrator_loadPlugin(*args):
    """Integrator_loadPlugin(std::string const & name)"""
    return _casadi_core.Integrator_loadPlugin(*args)

def Integrator_doc(*args):
    """Integrator_doc(std::string const & name) -> std::string"""
    return _casadi_core.Integrator_doc(*args)

def Integrator_testCast(*args):
    """Integrator_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.Integrator_testCast(*args)

class IntegratorVector(_object):
    """Proxy of C++ std::vector<(casadi::Integrator)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegratorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntegratorVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::vector<(casadi::Integrator)> self) -> IntegratorVector
        __init__(std::vector<(casadi::Integrator)> self, IntegratorVector other) -> IntegratorVector
        """
        this = _casadi_core.new_IntegratorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_IntegratorVector
IntegratorVector_swigregister = _casadi_core.IntegratorVector_swigregister
IntegratorVector_swigregister(IntegratorVector)

class Simulator(Function):
    """


    Integrator class.

    An "simulator" integrates an IVP, stopping at a (fixed) number of grid
    points and evaluates a set of output functions at these points. The internal
    stepsizes of the integrator need not coincide with the gridpoints.

    Simulator is an casadi::Function mapping from casadi::IntegratorInput to n.
    \\

    The output function needs to be a mapping from casadi::DAEInput to n. The
    default output has n=1 and the output is the (vectorized) differential state
    for each time step.

    Joel Andersson

    >Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6) [integratorIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | INTEGRATOR_X0          | x0                     | Differential state at  |
    |                        |                        | the initial time .     |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_P           | p                      | Parameters .           |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_Z0          | z0                     | Initial guess for the  |
    |                        |                        | algebraic variable .   |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RX0         | rx0                    | Backward differential  |
    |                        |                        | state at the final     |
    |                        |                        | time .                 |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RP          | rp                     | Backward parameter     |
    |                        |                        | vector .               |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RZ0         | rz0                    | Initial guess for the  |
    |                        |                        | backwards algebraic    |
    |                        |                        | variable .             |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp | casadi::Simu |
    |              |              |              | uts)  (initi | latorInterna |
    |              |              |              | al|step)     | l            |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    >List of available monitors

    +---------+---------------------------+
    |   Id    |          Used in          |
    +=========+===========================+
    | initial | casadi::SimulatorInternal |
    +---------+---------------------------+
    | inputs  | casadi::FunctionInternal  |
    +---------+---------------------------+
    | outputs | casadi::FunctionInternal  |
    +---------+---------------------------+
    | step    | casadi::SimulatorInternal |
    +---------+---------------------------+

    C++ includes: simulator.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Simulator, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Simulator, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.Simulator_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::Simulator self) -> Simulator
        __init__(casadi::Simulator self, Integrator integrator, Function output_fcn, DVector grid) -> Simulator
        __init__(casadi::Simulator self, Integrator integrator, Function output_fcn, DMatrix grid) -> Simulator
        __init__(casadi::Simulator self, Integrator integrator, DVector grid) -> Simulator
        __init__(casadi::Simulator self, Integrator integrator, DMatrix grid) -> Simulator
        __init__(casadi::Simulator self, Simulator other) -> Simulator



        >  casadi::Simulator::Simulator()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::Simulator::Simulator(const Integrator &integrator, const Function &output_fcn, const std::vector< double > &grid)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        output_fcn:  output function which maps to n outputs.

        >Input scheme: casadi::DAEInput (DAE_NUM_IN = 4) [daeIn]

        +-----------+-------+----------------------------+
        | Full name | Short |        Description         |
        +===========+=======+============================+
        | DAE_X     | x     | Differential state .       |
        +-----------+-------+----------------------------+
        | DAE_Z     | z     | Algebraic state .          |
        +-----------+-------+----------------------------+
        | DAE_P     | p     | Parameter .                |
        +-----------+-------+----------------------------+
        | DAE_T     | t     | Explicit time dependence . |
        +-----------+-------+----------------------------+

        >  casadi::Simulator::Simulator(const Integrator &integrator, const std::vector< double > &grid)
        ------------------------------------------------------------------------

        Output function equal to the state.


        """
        this = _casadi_core.new_Simulator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Simulator
Simulator_swigregister = _casadi_core.Simulator_swigregister
Simulator_swigregister(Simulator)

def Simulator_testCast(*args):
    """Simulator_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.Simulator_testCast(*args)


_casadi_core.CONTROL_DAE_T_swigconstant(_casadi_core)
CONTROL_DAE_T = _casadi_core.CONTROL_DAE_T

_casadi_core.CONTROL_DAE_X_swigconstant(_casadi_core)
CONTROL_DAE_X = _casadi_core.CONTROL_DAE_X

_casadi_core.CONTROL_DAE_Z_swigconstant(_casadi_core)
CONTROL_DAE_Z = _casadi_core.CONTROL_DAE_Z

_casadi_core.CONTROL_DAE_P_swigconstant(_casadi_core)
CONTROL_DAE_P = _casadi_core.CONTROL_DAE_P

_casadi_core.CONTROL_DAE_U_swigconstant(_casadi_core)
CONTROL_DAE_U = _casadi_core.CONTROL_DAE_U

_casadi_core.CONTROL_DAE_U_INTERP_swigconstant(_casadi_core)
CONTROL_DAE_U_INTERP = _casadi_core.CONTROL_DAE_U_INTERP

_casadi_core.CONTROL_DAE_X_MAJOR_swigconstant(_casadi_core)
CONTROL_DAE_X_MAJOR = _casadi_core.CONTROL_DAE_X_MAJOR

_casadi_core.CONTROL_DAE_T0_swigconstant(_casadi_core)
CONTROL_DAE_T0 = _casadi_core.CONTROL_DAE_T0

_casadi_core.CONTROL_DAE_TF_swigconstant(_casadi_core)
CONTROL_DAE_TF = _casadi_core.CONTROL_DAE_TF

_casadi_core.CONTROL_DAE_NUM_IN_swigconstant(_casadi_core)
CONTROL_DAE_NUM_IN = _casadi_core.CONTROL_DAE_NUM_IN

_casadi_core.CONTROLSIMULATOR_X0_swigconstant(_casadi_core)
CONTROLSIMULATOR_X0 = _casadi_core.CONTROLSIMULATOR_X0

_casadi_core.CONTROLSIMULATOR_P_swigconstant(_casadi_core)
CONTROLSIMULATOR_P = _casadi_core.CONTROLSIMULATOR_P

_casadi_core.CONTROLSIMULATOR_U_swigconstant(_casadi_core)
CONTROLSIMULATOR_U = _casadi_core.CONTROLSIMULATOR_U

_casadi_core.CONTROLSIMULATOR_NUM_IN_swigconstant(_casadi_core)
CONTROLSIMULATOR_NUM_IN = _casadi_core.CONTROLSIMULATOR_NUM_IN
class ControlSimulator(Function):
    """


    Piecewise Simulation class.

    A ControlSimulator can be seen as a chain of Simulators whereby some
    parameters change from one Simulator to the next.

    These changing parameters can typically be interpreted as "controls" in
    the context of dynamic optimization.

    We discriminate between the following time steps: Major time-steps. These
    are the time steps provided by the supplied grid. Controls are constant
    inbetween major time-steps  Minor time-steps. These are time steps linearly
    interpolated from one major time-step to the next. The option 'nf' regulates
    how many minor time-steps are taken.  Integration time-steps. Time steps
    that the supplied integrator might choose to integrate the continuous
    dynamics. They are not important what ControlSimulator is concerned.  np
    Number of parameters nu Number of controls ns The number of major grid
    points, as supplied in the constructor nf The number of minor grid points
    per major interval

    Joris Gillis

    >Input scheme: casadi::ControlSimulatorInput (CONTROLSIMULATOR_NUM_IN = 3) [controlsimulatorIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | CONTROLSIMULATOR_X0    | x0                     | Differential or        |
    |                        |                        | algebraic state at t0  |
    |                        |                        | (dimension nx-by-1) .  |
    +------------------------+------------------------+------------------------+
    | CONTROLSIMULATOR_P     | p                      | Parameters that are    |
    |                        |                        | fixed over the entire  |
    |                        |                        | horizon (dimension np- |
    |                        |                        | by-1) .                |
    +------------------------+------------------------+------------------------+
    | CONTROLSIMULATOR_U     | u                      | Parameters that change |
    |                        |                        | over the integration   |
    |                        |                        | intervals (dimension   |
    |                        |                        | nu-by-(ns-1)) .        |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | control_endp | OT_BOOLEAN   | false        | Include a    | casadi::Cont |
    | oint         |              |              | control      | rolSimulator |
    |              |              |              | value at the | Internal     |
    |              |              |              | end of the   |              |
    |              |              |              | simulation   |              |
    |              |              |              | domain. Used |              |
    |              |              |              | for interpol |              |
    |              |              |              | ation.       |              |
    +--------------+--------------+--------------+--------------+--------------+
    | control_inte | OT_STRING    | "none"       | none|nearest | casadi::Cont |
    | rpolation    |              |              | |linear      | rolSimulator |
    |              |              |              |              | Internal     |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | integrator   | OT_STRING    | GenericType( | An           | casadi::Cont |
    |              |              | )            | integrator   | rolSimulator |
    |              |              |              | creator      | Internal     |
    |              |              |              | function     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | integrator_o | OT_DICTIONAR | GenericType( | Options to   | casadi::Cont |
    | ptions       | Y            | )            | be passed to | rolSimulator |
    |              |              |              | the          | Internal     |
    |              |              |              | integrator   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | minor_grid   | OT_INTEGERVE | GenericType( | The local    | casadi::Cont |
    |              | CTOR         | )            | grid used on | rolSimulator |
    |              |              |              | each major   | Internal     |
    |              |              |              | interval,    |              |
    |              |              |              | with time    |              |
    |              |              |              | normalized   |              |
    |              |              |              | to 1. By     |              |
    |              |              |              | default,     |              |
    |              |              |              | option 'nf'  |              |
    |              |              |              | is used to   |              |
    |              |              |              | construct a  |              |
    |              |              |              | linearly     |              |
    |              |              |              | spaced grid. |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | nf           | OT_INTEGER   | 1            | Number of    | casadi::Cont |
    |              |              |              | minor        | rolSimulator |
    |              |              |              | grained      | Internal     |
    |              |              |              | integration  |              |
    |              |              |              | steps per    |              |
    |              |              |              | major        |              |
    |              |              |              | interval.    |              |
    |              |              |              | nf>0 must    |              |
    |              |              |              | hold. This   |              |
    |              |              |              | option is    |              |
    |              |              |              | not used     |              |
    |              |              |              | when         |              |
    |              |              |              | 'minor_grid' |              |
    |              |              |              | is provided. |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | simulator_op | OT_DICTIONAR | GenericType( | Options to   | casadi::Cont |
    | tions        | Y            | )            | be passed to | rolSimulator |
    |              |              |              | the          | Internal     |
    |              |              |              | simulator    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: control_simulator.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ControlSimulator, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ControlSimulator, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.ControlSimulator_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def getMinorT(self, *args):
        """
        getMinorT(ControlSimulator self) -> DVector



        Get the (minor) time grid The length is (ns-1)*nf + 1


        """
        return _casadi_core.ControlSimulator_getMinorT(self, *args)


    def getMinorU(self, *args):
        """
        getMinorU(ControlSimulator self) -> DMatrix



        Get the controls, sampled on the minor timescale. Number of rows is
        (ns-1)*nf.


        """
        return _casadi_core.ControlSimulator_getMinorU(self, *args)


    def getMajorIndex(self, *args):
        """
        getMajorIndex(ControlSimulator self) -> IVector



        Get the index i such that gridminor[i] == gridmajor


        """
        return _casadi_core.ControlSimulator_getMajorIndex(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::ControlSimulator self) -> ControlSimulator
        __init__(casadi::ControlSimulator self, Function dae, Function output_fcn, DVector grid) -> ControlSimulator
        __init__(casadi::ControlSimulator self, Function dae, Function output_fcn, DMatrix grid) -> ControlSimulator
        __init__(casadi::ControlSimulator self, Function dae, DVector grid) -> ControlSimulator
        __init__(casadi::ControlSimulator self, Function dae, DMatrix grid) -> ControlSimulator
        __init__(casadi::ControlSimulator self, ControlSimulator other) -> ControlSimulator



        >  casadi::ControlSimulator::ControlSimulator()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::ControlSimulator::ControlSimulator(const Function &dae, const Function &output_fcn, const std::vector< double > &grid)
        ------------------------------------------------------------------------

        Creates a piecewise simulator.

        Parameters:
        -----------

        ffcn:  Continuous time dynamics, an casadi::Function with the following
        mapping:

        >Input scheme: casadi::ControlledDAEInput (CONTROL_DAE_NUM_IN = 9) [controldaeIn]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | CONTROL_DAE_T          | t                      | Global physical time.  |
        |                        |                        | (1-by-1) .             |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_X          | x                      | State vector           |
        |                        |                        | (dimension nx-by-1).   |
        |                        |                        | Should have the same   |
        |                        |                        | amount of non-zeros as |
        |                        |                        | DAEOutput:DAE_RES      |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_Z          | z                      | Algebraic state vector |
        |                        |                        | (dimension np-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_P          | p                      | Parameter vector       |
        |                        |                        | (dimension np-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_U          | u                      | Control vector         |
        |                        |                        | (dimension nu-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_U_INTERP   | u_interp               | Control vector,        |
        |                        |                        | linearly interpolated  |
        |                        |                        | (dimension nu-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_X_MAJOR    | x_major                | State vector           |
        |                        |                        | (dimension nx-by-1) at |
        |                        |                        | the last major time-   |
        |                        |                        | step .                 |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_T0         | t0                     | Time at start of       |
        |                        |                        | control interval       |
        |                        |                        | (1-by-1) .             |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_TF         | tf                     | Time at end of control |
        |                        |                        | interval (1-by-1) .    |
        +------------------------+------------------------+------------------------+

        >Output scheme: casadi::DAEOutput (DAE_NUM_OUT = 3) [daeOut]

        +-----------+-------+--------------------------------------------+
        | Full name | Short |                Description                 |
        +===========+=======+============================================+
        | DAE_ODE   | ode   | Right hand side of the implicit ODE .      |
        +-----------+-------+--------------------------------------------+
        | DAE_ALG   | alg   | Right hand side of algebraic equations .   |
        +-----------+-------+--------------------------------------------+
        | DAE_QUAD  | quad  | Right hand side of quadratures equations . |
        +-----------+-------+--------------------------------------------+

        Parameters:
        -----------

        output_fcn:  output function which maps ControlledDAEInput or DAEInput to n
        outputs.

        >Input scheme: casadi::DAEInput (DAE_NUM_IN = 4) [daeIn]

        +-----------+-------+----------------------------+
        | Full name | Short |        Description         |
        +===========+=======+============================+
        | DAE_X     | x     | Differential state .       |
        +-----------+-------+----------------------------+
        | DAE_Z     | z     | Algebraic state .          |
        +-----------+-------+----------------------------+
        | DAE_P     | p     | Parameter .                |
        +-----------+-------+----------------------------+
        | DAE_T     | t     | Explicit time dependence . |
        +-----------+-------+----------------------------+

        >Input scheme: casadi::ControlledDAEInput (CONTROL_DAE_NUM_IN = 9) [controldaeIn]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | CONTROL_DAE_T          | t                      | Global physical time.  |
        |                        |                        | (1-by-1) .             |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_X          | x                      | State vector           |
        |                        |                        | (dimension nx-by-1).   |
        |                        |                        | Should have the same   |
        |                        |                        | amount of non-zeros as |
        |                        |                        | DAEOutput:DAE_RES      |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_Z          | z                      | Algebraic state vector |
        |                        |                        | (dimension np-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_P          | p                      | Parameter vector       |
        |                        |                        | (dimension np-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_U          | u                      | Control vector         |
        |                        |                        | (dimension nu-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_U_INTERP   | u_interp               | Control vector,        |
        |                        |                        | linearly interpolated  |
        |                        |                        | (dimension nu-by-1). . |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_X_MAJOR    | x_major                | State vector           |
        |                        |                        | (dimension nx-by-1) at |
        |                        |                        | the last major time-   |
        |                        |                        | step .                 |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_T0         | t0                     | Time at start of       |
        |                        |                        | control interval       |
        |                        |                        | (1-by-1) .             |
        +------------------------+------------------------+------------------------+
        | CONTROL_DAE_TF         | tf                     | Time at end of control |
        |                        |                        | interval (1-by-1) .    |
        +------------------------+------------------------+------------------------+

        Parameters:
        -----------

        grid:  the major time grid

        >  casadi::ControlSimulator::ControlSimulator(const Function &dae, const std::vector< double > &grid)
        ------------------------------------------------------------------------

        Output function equal to the state.


        """
        this = _casadi_core.new_ControlSimulator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ControlSimulator
ControlSimulator_swigregister = _casadi_core.ControlSimulator_swigregister
ControlSimulator_swigregister(ControlSimulator)

def ControlSimulator_testCast(*args):
    """ControlSimulator_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.ControlSimulator_testCast(*args)


_casadi_core.NL_X_swigconstant(_casadi_core)
NL_X = _casadi_core.NL_X

_casadi_core.NL_P_swigconstant(_casadi_core)
NL_P = _casadi_core.NL_P

_casadi_core.NL_NUM_IN_swigconstant(_casadi_core)
NL_NUM_IN = _casadi_core.NL_NUM_IN

_casadi_core.NL_F_swigconstant(_casadi_core)
NL_F = _casadi_core.NL_F

_casadi_core.NL_G_swigconstant(_casadi_core)
NL_G = _casadi_core.NL_G

_casadi_core.NL_NUM_OUT_swigconstant(_casadi_core)
NL_NUM_OUT = _casadi_core.NL_NUM_OUT

_casadi_core.GRADF_X_swigconstant(_casadi_core)
GRADF_X = _casadi_core.GRADF_X

_casadi_core.GRADF_P_swigconstant(_casadi_core)
GRADF_P = _casadi_core.GRADF_P

_casadi_core.GRADF_NUM_IN_swigconstant(_casadi_core)
GRADF_NUM_IN = _casadi_core.GRADF_NUM_IN

_casadi_core.GRADF_GRAD_swigconstant(_casadi_core)
GRADF_GRAD = _casadi_core.GRADF_GRAD

_casadi_core.GRADF_F_swigconstant(_casadi_core)
GRADF_F = _casadi_core.GRADF_F

_casadi_core.GRADF_G_swigconstant(_casadi_core)
GRADF_G = _casadi_core.GRADF_G

_casadi_core.GRADF_NUM_OUT_swigconstant(_casadi_core)
GRADF_NUM_OUT = _casadi_core.GRADF_NUM_OUT

_casadi_core.JACG_X_swigconstant(_casadi_core)
JACG_X = _casadi_core.JACG_X

_casadi_core.JACG_P_swigconstant(_casadi_core)
JACG_P = _casadi_core.JACG_P

_casadi_core.JACG_NUM_IN_swigconstant(_casadi_core)
JACG_NUM_IN = _casadi_core.JACG_NUM_IN

_casadi_core.JACG_JAC_swigconstant(_casadi_core)
JACG_JAC = _casadi_core.JACG_JAC

_casadi_core.JACG_F_swigconstant(_casadi_core)
JACG_F = _casadi_core.JACG_F

_casadi_core.JACG_G_swigconstant(_casadi_core)
JACG_G = _casadi_core.JACG_G

_casadi_core.JACG_NUM_OUT_swigconstant(_casadi_core)
JACG_NUM_OUT = _casadi_core.JACG_NUM_OUT

_casadi_core.HESSLAG_X_swigconstant(_casadi_core)
HESSLAG_X = _casadi_core.HESSLAG_X

_casadi_core.HESSLAG_P_swigconstant(_casadi_core)
HESSLAG_P = _casadi_core.HESSLAG_P

_casadi_core.HESSLAG_LAM_F_swigconstant(_casadi_core)
HESSLAG_LAM_F = _casadi_core.HESSLAG_LAM_F

_casadi_core.HESSLAG_LAM_G_swigconstant(_casadi_core)
HESSLAG_LAM_G = _casadi_core.HESSLAG_LAM_G

_casadi_core.HESSLAG_NUM_IN_swigconstant(_casadi_core)
HESSLAG_NUM_IN = _casadi_core.HESSLAG_NUM_IN

_casadi_core.HESSLAG_HESS_swigconstant(_casadi_core)
HESSLAG_HESS = _casadi_core.HESSLAG_HESS

_casadi_core.HESSLAG_F_swigconstant(_casadi_core)
HESSLAG_F = _casadi_core.HESSLAG_F

_casadi_core.HESSLAG_G_swigconstant(_casadi_core)
HESSLAG_G = _casadi_core.HESSLAG_G

_casadi_core.HESSLAG_GRAD_X_swigconstant(_casadi_core)
HESSLAG_GRAD_X = _casadi_core.HESSLAG_GRAD_X

_casadi_core.HESSLAG_GRAD_P_swigconstant(_casadi_core)
HESSLAG_GRAD_P = _casadi_core.HESSLAG_GRAD_P

_casadi_core.HESSLAG_NUM_OUT_swigconstant(_casadi_core)
HESSLAG_NUM_OUT = _casadi_core.HESSLAG_NUM_OUT

_casadi_core.NLP_SOLVER_X0_swigconstant(_casadi_core)
NLP_SOLVER_X0 = _casadi_core.NLP_SOLVER_X0

_casadi_core.NLP_SOLVER_P_swigconstant(_casadi_core)
NLP_SOLVER_P = _casadi_core.NLP_SOLVER_P

_casadi_core.NLP_SOLVER_LBX_swigconstant(_casadi_core)
NLP_SOLVER_LBX = _casadi_core.NLP_SOLVER_LBX

_casadi_core.NLP_SOLVER_UBX_swigconstant(_casadi_core)
NLP_SOLVER_UBX = _casadi_core.NLP_SOLVER_UBX

_casadi_core.NLP_SOLVER_LBG_swigconstant(_casadi_core)
NLP_SOLVER_LBG = _casadi_core.NLP_SOLVER_LBG

_casadi_core.NLP_SOLVER_UBG_swigconstant(_casadi_core)
NLP_SOLVER_UBG = _casadi_core.NLP_SOLVER_UBG

_casadi_core.NLP_SOLVER_LAM_X0_swigconstant(_casadi_core)
NLP_SOLVER_LAM_X0 = _casadi_core.NLP_SOLVER_LAM_X0

_casadi_core.NLP_SOLVER_LAM_G0_swigconstant(_casadi_core)
NLP_SOLVER_LAM_G0 = _casadi_core.NLP_SOLVER_LAM_G0

_casadi_core.NLP_SOLVER_NUM_IN_swigconstant(_casadi_core)
NLP_SOLVER_NUM_IN = _casadi_core.NLP_SOLVER_NUM_IN

_casadi_core.NLP_SOLVER_X_swigconstant(_casadi_core)
NLP_SOLVER_X = _casadi_core.NLP_SOLVER_X

_casadi_core.NLP_SOLVER_F_swigconstant(_casadi_core)
NLP_SOLVER_F = _casadi_core.NLP_SOLVER_F

_casadi_core.NLP_SOLVER_G_swigconstant(_casadi_core)
NLP_SOLVER_G = _casadi_core.NLP_SOLVER_G

_casadi_core.NLP_SOLVER_LAM_X_swigconstant(_casadi_core)
NLP_SOLVER_LAM_X = _casadi_core.NLP_SOLVER_LAM_X

_casadi_core.NLP_SOLVER_LAM_G_swigconstant(_casadi_core)
NLP_SOLVER_LAM_G = _casadi_core.NLP_SOLVER_LAM_G

_casadi_core.NLP_SOLVER_LAM_P_swigconstant(_casadi_core)
NLP_SOLVER_LAM_P = _casadi_core.NLP_SOLVER_LAM_P

_casadi_core.NLP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
NLP_SOLVER_NUM_OUT = _casadi_core.NLP_SOLVER_NUM_OUT
class NlpSolver(Function):
    """


    NlpSolver.

    Solves the following parametric nonlinear program (NLP):

    ::

      min          F(x, p)
       x

      subject to
                  LBX <=   x    <= UBX
                  LBG <= G(x, p) <= UBG
                             p  == P

          nx: number of decision variables
          ng: number of constraints
          np: number of parameters




    General information
    ===================



    >Input scheme: casadi::NlpSolverInput (NLP_SOLVER_NUM_IN = 8) [nlpSolverIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLP_SOLVER_X0          | x0                     | Decision variables,    |
    |                        |                        | initial guess (nx x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_P           | p                      | Value of fixed         |
    |                        |                        | parameters (np x 1) .  |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LBX         | lbx                    | Decision variables     |
    |                        |                        | lower bound (nx x 1),  |
    |                        |                        | default -inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_UBX         | ubx                    | Decision variables     |
    |                        |                        | upper bound (nx x 1),  |
    |                        |                        | default +inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LBG         | lbg                    | Constraints lower      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default -inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_UBG         | ubg                    | Constraints upper      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default +inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_X0      | lam_x0                 | Lagrange multipliers   |
    |                        |                        | for bounds on X,       |
    |                        |                        | initial guess (nx x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_G0      | lam_g0                 | Lagrange multipliers   |
    |                        |                        | for bounds on G,       |
    |                        |                        | initial guess (ng x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::NlpSolverOutput (NLP_SOLVER_NUM_OUT = 6) [nlpSolverOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLP_SOLVER_X           | x                      | Decision variables at  |
    |                        |                        | the optimal solution   |
    |                        |                        | (nx x 1) .             |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_F           | f                      | Cost function value at |
    |                        |                        | the optimal solution   |
    |                        |                        | (1 x 1) .              |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_G           | g                      | Constraints function   |
    |                        |                        | at the optimal         |
    |                        |                        | solution (ng x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_X       | lam_x                  | Lagrange multipliers   |
    |                        |                        | for bounds on X at the |
    |                        |                        | solution (nx x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_G       | lam_g                  | Lagrange multipliers   |
    |                        |                        | for bounds on G at the |
    |                        |                        | solution (ng x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_P       | lam_p                  | Lagrange multipliers   |
    |                        |                        | for bounds on P at the |
    |                        |                        | solution (np x 1) .    |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eval_errors_ | OT_BOOLEAN   | false        | When errors  | casadi::NlpS |
    | fatal        |              |              | occur during | olverInterna |
    |              |              |              | evaluation   | l            |
    |              |              |              | of           |              |
    |              |              |              | f,g,...,stop |              |
    |              |              |              | the          |              |
    |              |              |              | iterations   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | expand       | OT_BOOLEAN   | false        | Expand the   | casadi::NlpS |
    |              |              |              | NLP function | olverInterna |
    |              |              |              | in terms of  | l            |
    |              |              |              | scalar       |              |
    |              |              |              | operations,  |              |
    |              |              |              | i.e. MX->SX  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | grad_f       | OT_FUNCTION  | GenericType( | Function for | casadi::NlpS |
    |              |              | )            | calculating  | olverInterna |
    |              |              |              | the gradient | l            |
    |              |              |              | of the       |              |
    |              |              |              | objective    |              |
    |              |              |              | (column, aut |              |
    |              |              |              | ogenerated   |              |
    |              |              |              | by default)  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | grad_lag     | OT_FUNCTION  | GenericType( | Function for | casadi::NlpS |
    |              |              | )            | calculating  | olverInterna |
    |              |              |              | the gradient | l            |
    |              |              |              | of the       |              |
    |              |              |              | Lagrangian ( |              |
    |              |              |              | autogenerate |              |
    |              |              |              | d by         |              |
    |              |              |              | default)     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | hess_lag     | OT_FUNCTION  | GenericType( | Function for | casadi::NlpS |
    |              |              | )            | calculating  | olverInterna |
    |              |              |              | the Hessian  | l            |
    |              |              |              | of the       |              |
    |              |              |              | Lagrangian ( |              |
    |              |              |              | autogenerate |              |
    |              |              |              | d by         |              |
    |              |              |              | default)     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | ignore_check | OT_BOOLEAN   | false        | If set to    | casadi::NlpS |
    | _vec         |              |              | true, the    | olverInterna |
    |              |              |              | input shape  | l            |
    |              |              |              | of F will    |              |
    |              |              |              | not be       |              |
    |              |              |              | checked.     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | iteration_ca | OT_CALLBACK  | GenericType( | A function   | casadi::NlpS |
    | llback       |              | )            | that will be | olverInterna |
    |              |              |              | called at    | l            |
    |              |              |              | each         |              |
    |              |              |              | iteration    |              |
    |              |              |              | with the     |              |
    |              |              |              | solver as    |              |
    |              |              |              | input. Check |              |
    |              |              |              | documentatio |              |
    |              |              |              | n of         |              |
    |              |              |              | Callback .   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | iteration_ca | OT_BOOLEAN   | false        | If set to    | casadi::NlpS |
    | llback_ignor |              |              | true, errors | olverInterna |
    | e_errors     |              |              | thrown by it | l            |
    |              |              |              | eration_call |              |
    |              |              |              | back will be |              |
    |              |              |              | ignored.     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | iteration_ca | OT_INTEGER   | 1            | Only call    | casadi::NlpS |
    | llback_step  |              |              | the callback | olverInterna |
    |              |              |              | function     | l            |
    |              |              |              | every few    |              |
    |              |              |              | iterations.  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | jac_f        | OT_FUNCTION  | GenericType( | Function for | casadi::NlpS |
    |              |              | )            | calculating  | olverInterna |
    |              |              |              | the jacobian | l            |
    |              |              |              | of the       |              |
    |              |              |              | objective    |              |
    |              |              |              | (sparse row, |              |
    |              |              |              | autogenerate |              |
    |              |              |              | d by         |              |
    |              |              |              | default)     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | jac_g        | OT_FUNCTION  | GenericType( | Function for | casadi::NlpS |
    |              |              | )            | calculating  | olverInterna |
    |              |              |              | the Jacobian | l            |
    |              |              |              | of the       |              |
    |              |              |              | constraints  |              |
    |              |              |              | (autogenerat |              |
    |              |              |              | ed by        |              |
    |              |              |              | default)     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | warn_initial | OT_BOOLEAN   | false        | Warn if the  | casadi::NlpS |
    | _bounds      |              |              | initial      | olverInterna |
    |              |              |              | guess does   | l            |
    |              |              |              | not satisfy  |              |
    |              |              |              | LBX and UBX  |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_NlpSolver_ipopt'>ipopt</a>

    - <a href='#plugin_NlpSolver_knitro'>knitro</a>

    - <a href='#plugin_NlpSolver_snopt'>snopt</a>

    - <a href='#plugin_NlpSolver_worhp'>worhp</a>

    - <a href='#plugin_NlpSolver_scpgen'>scpgen</a>

    - <a href='#plugin_NlpSolver_sqpmethod'>sqpmethod</a>

    - <a href='#plugin_NlpSolver_stabilizedsqp'>stabilizedsqp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    NlpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    ipopt
    -----



    When in warmstart mode, output NLP_SOLVER_LAM_X may be used as input

    NOTE: Even when max_iter == 0, it is not guaranteed that
    input(NLP_SOLVER_X0) == output(NLP_SOLVER_X). Indeed if bounds on X or
    constraints are unmet, they will differ.

    For a good tutorial on IPOPT,
    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf

    A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler,
    On the Implementation of an Interior-Point Filter Line-Search Algorithm for
    Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp.
    25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center,
    Yorktown, USA

    Caveats: with default options, multipliers for the decision variables are
    wrong for equality constraints. Change the 'fixed_variable_treatment' to
    'make_constraint' or 'relax_bounds' to obtain correct results.

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | accept_after_ma | OT_INTEGER      | -1              | Accept a trial  |
    | x_steps         |                 |                 | point after     |
    |                 |                 |                 | maximal this    |
    |                 |                 |                 | number of       |
    |                 |                 |                 | steps. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | accept_every_tr | OT_STRING       | no              | Always accept   |
    | ial_step        |                 |                 | the first trial |
    |                 |                 |                 | step. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_comp | OT_REAL         | 0.010           | "Acceptance"    |
    | l_inf_tol       |                 |                 | threshold for   |
    |                 |                 |                 | the             |
    |                 |                 |                 | complementarity |
    |                 |                 |                 | conditions.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_cons | OT_REAL         | 0.010           | "Acceptance"    |
    | tr_viol_tol     |                 |                 | threshold for   |
    |                 |                 |                 | the constraint  |
    |                 |                 |                 | violation. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_dual | OT_REAL         | 1.000e+10       | "Acceptance"    |
    | _inf_tol        |                 |                 | threshold for   |
    |                 |                 |                 | the dual        |
    |                 |                 |                 | infeasibility.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_iter | OT_INTEGER      | 15              | Number of       |
    |                 |                 |                 | "acceptable"    |
    |                 |                 |                 | iterates before |
    |                 |                 |                 | triggering      |
    |                 |                 |                 | termination.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_obj_ | OT_REAL         | 1.000e+20       | "Acceptance"    |
    | change_tol      |                 |                 | stopping        |
    |                 |                 |                 | criterion based |
    |                 |                 |                 | on objective    |
    |                 |                 |                 | function        |
    |                 |                 |                 | change. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | acceptable_tol  | OT_REAL         | 0.000           | "Acceptable"    |
    |                 |                 |                 | convergence     |
    |                 |                 |                 | tolerance       |
    |                 |                 |                 | (relative).     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_glo | OT_STRING       | obj-constr-     | Globalization   |
    | balization      |                 | filter          | strategy for    |
    |                 |                 |                 | the adaptive mu |
    |                 |                 |                 | selection mode. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_kkt | OT_STRING       | 2-norm-squared  | Norm used for   |
    | _norm_type      |                 |                 | the KKT error   |
    |                 |                 |                 | in the adaptive |
    |                 |                 |                 | mu              |
    |                 |                 |                 | globalization   |
    |                 |                 |                 | strategies.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_kkt | OT_REAL         | 1.000           | Sufficient      |
    | error_red_fact  |                 |                 | decrease factor |
    |                 |                 |                 | for "kkt-error" |
    |                 |                 |                 | globalization   |
    |                 |                 |                 | strategy. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_kkt | OT_INTEGER      | 4               | Maximum number  |
    | error_red_iters |                 |                 | of iterations   |
    |                 |                 |                 | requiring       |
    |                 |                 |                 | sufficient      |
    |                 |                 |                 | progress. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_mon | OT_REAL         | 0.800           | Determines the  |
    | otone_init_fact |                 |                 | initial value   |
    | or              |                 |                 | of the barrier  |
    |                 |                 |                 | parameter when  |
    |                 |                 |                 | switching to    |
    |                 |                 |                 | the monotone    |
    |                 |                 |                 | mode. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_res | OT_STRING       | no              | Indicates if    |
    | tore_previous_i |                 |                 | the previous    |
    | terate          |                 |                 | iterate should  |
    |                 |                 |                 | be restored if  |
    |                 |                 |                 | the monotone    |
    |                 |                 |                 | mode is         |
    |                 |                 |                 | entered. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | adaptive_mu_saf | OT_REAL         | 0               | (see IPOPT      |
    | eguard_factor   |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | alpha_for_y     | OT_STRING       | primal          | Method to       |
    |                 |                 |                 | determine the   |
    |                 |                 |                 | step size for   |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | multipliers.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | alpha_for_y_tol | OT_REAL         | 10              | Tolerance for   |
    |                 |                 |                 | switching to    |
    |                 |                 |                 | full equality   |
    |                 |                 |                 | multiplier      |
    |                 |                 |                 | steps. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | alpha_min_frac  | OT_REAL         | 0.050           | Safety factor   |
    |                 |                 |                 | for the minimal |
    |                 |                 |                 | step size       |
    |                 |                 |                 | (before         |
    |                 |                 |                 | switching to    |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase). (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | alpha_red_facto | OT_REAL         | 0.500           | Fractional      |
    | r               |                 |                 | reduction of    |
    |                 |                 |                 | the trial step  |
    |                 |                 |                 | size in the     |
    |                 |                 |                 | backtracking    |
    |                 |                 |                 | line search.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | barrier_tol_fac | OT_REAL         | 10              | Factor for mu   |
    | tor             |                 |                 | in barrier stop |
    |                 |                 |                 | test. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_frac      | OT_REAL         | 0.010           | Desired minimum |
    |                 |                 |                 | relative        |
    |                 |                 |                 | distance from   |
    |                 |                 |                 | the initial     |
    |                 |                 |                 | point to bound. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_mult_init | OT_STRING       | constant        | Initialization  |
    | _method         |                 |                 | method for      |
    |                 |                 |                 | bound           |
    |                 |                 |                 | multipliers     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_mult_init | OT_REAL         | 1               | Initial value   |
    | _val            |                 |                 | for the bound   |
    |                 |                 |                 | multipliers.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_mult_rese | OT_REAL         | 1000            | Threshold for   |
    | t_threshold     |                 |                 | resetting bound |
    |                 |                 |                 | multipliers     |
    |                 |                 |                 | after the       |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_push      | OT_REAL         | 0.010           | Desired minimum |
    |                 |                 |                 | absolute        |
    |                 |                 |                 | distance from   |
    |                 |                 |                 | the initial     |
    |                 |                 |                 | point to bound. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | bound_relax_fac | OT_REAL         | 0.000           | Factor for      |
    | tor             |                 |                 | initial         |
    |                 |                 |                 | relaxation of   |
    |                 |                 |                 | the bounds.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | check_derivativ | OT_STRING       | no              | Indicates       |
    | es_for_naninf   |                 |                 | whether it is   |
    |                 |                 |                 | desired to      |
    |                 |                 |                 | check for       |
    |                 |                 |                 | Nan/Inf in      |
    |                 |                 |                 | derivative      |
    |                 |                 |                 | matrices (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | chi_cup         | OT_REAL         | 1.500           | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | chi_hat         | OT_REAL         | 2               | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | chi_tilde       | OT_REAL         | 5               | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | compl_inf_tol   | OT_REAL         | 0.000           | Desired         |
    |                 |                 |                 | threshold for   |
    |                 |                 |                 | the             |
    |                 |                 |                 | complementarity |
    |                 |                 |                 | conditions.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | con_integer_md  | OT_DICTIONARY   | None            | Integer         |
    |                 |                 |                 | metadata (a     |
    |                 |                 |                 | dictionary with |
    |                 |                 |                 | lists of        |
    |                 |                 |                 | integers) about |
    |                 |                 |                 | constraints to  |
    |                 |                 |                 | be passed to    |
    |                 |                 |                 | IPOPT           |
    +-----------------+-----------------+-----------------+-----------------+
    | con_numeric_md  | OT_DICTIONARY   | None            | Numeric         |
    |                 |                 |                 | metadata (a     |
    |                 |                 |                 | dictionary with |
    |                 |                 |                 | lists of reals) |
    |                 |                 |                 | about           |
    |                 |                 |                 | constraints to  |
    |                 |                 |                 | be passed to    |
    |                 |                 |                 | IPOPT           |
    +-----------------+-----------------+-----------------+-----------------+
    | con_string_md   | OT_DICTIONARY   | None            | String metadata |
    |                 |                 |                 | (a dictionary   |
    |                 |                 |                 | with lists of   |
    |                 |                 |                 | strings) about  |
    |                 |                 |                 | constraints to  |
    |                 |                 |                 | be passed to    |
    |                 |                 |                 | IPOPT           |
    +-----------------+-----------------+-----------------+-----------------+
    | constr_mult_ini | OT_REAL         | 1000            | Maximum allowed |
    | t_max           |                 |                 | least-square    |
    |                 |                 |                 | guess of        |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | multipliers.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | constr_mult_res | OT_REAL         | 0               | Threshold for   |
    | et_threshold    |                 |                 | resetting       |
    |                 |                 |                 | equality and    |
    |                 |                 |                 | inequality      |
    |                 |                 |                 | multipliers     |
    |                 |                 |                 | after           |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | constr_viol_tol | OT_REAL         | 0.000           | Desired         |
    |                 |                 |                 | threshold for   |
    |                 |                 |                 | the constraint  |
    |                 |                 |                 | violation. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | constraint_viol | OT_STRING       | 1-norm          | Norm to be used |
    | ation_norm_type |                 |                 | for the         |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation in    |
    |                 |                 |                 | the line        |
    |                 |                 |                 | search. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | corrector_compl | OT_REAL         | 1               | Complementarity |
    | _avrg_red_fact  |                 |                 | tolerance       |
    |                 |                 |                 | factor for      |
    |                 |                 |                 | accepting       |
    |                 |                 |                 | corrector step  |
    |                 |                 |                 | (unsupported!). |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | corrector_type  | OT_STRING       | none            | The type of     |
    |                 |                 |                 | corrector steps |
    |                 |                 |                 | that should be  |
    |                 |                 |                 | taken           |
    |                 |                 |                 | (unsupported!). |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | delta           | OT_REAL         | 1               | Multiplier for  |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation in    |
    |                 |                 |                 | the switching   |
    |                 |                 |                 | rule. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | delta_y_max     | OT_REAL         | 1.000e+12       | a parameter     |
    |                 |                 |                 | used to check   |
    |                 |                 |                 | if the fast     |
    |                 |                 |                 | direction can   |
    |                 |                 |                 | be used asthe   |
    |                 |                 |                 | line search     |
    |                 |                 |                 | direction (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | dependency_dete | OT_STRING       | no              | Indicates if    |
    | ction_with_rhs  |                 |                 | the right hand  |
    |                 |                 |                 | sides of the    |
    |                 |                 |                 | constraints     |
    |                 |                 |                 | should be       |
    |                 |                 |                 | considered      |
    |                 |                 |                 | during          |
    |                 |                 |                 | dependency      |
    |                 |                 |                 | detection (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | dependency_dete | OT_STRING       | none            | Indicates which |
    | ctor            |                 |                 | linear solver   |
    |                 |                 |                 | should be used  |
    |                 |                 |                 | to detect       |
    |                 |                 |                 | linearly        |
    |                 |                 |                 | dependent       |
    |                 |                 |                 | equality        |
    |                 |                 |                 | constraints.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_test | OT_STRING       | none            | Enable          |
    |                 |                 |                 | derivative      |
    |                 |                 |                 | checker (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_test | OT_INTEGER      | -2              | Index of first  |
    | _first_index    |                 |                 | quantity to be  |
    |                 |                 |                 | checked by      |
    |                 |                 |                 | derivative      |
    |                 |                 |                 | checker (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_test | OT_REAL         | 0.000           | Size of the     |
    | _perturbation   |                 |                 | finite          |
    |                 |                 |                 | difference      |
    |                 |                 |                 | perturbation in |
    |                 |                 |                 | derivative      |
    |                 |                 |                 | test. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_test | OT_STRING       | no              | Indicates       |
    | _print_all      |                 |                 | whether         |
    |                 |                 |                 | information for |
    |                 |                 |                 | all estimated   |
    |                 |                 |                 | derivatives     |
    |                 |                 |                 | should be       |
    |                 |                 |                 | printed. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_test | OT_REAL         | 0.000           | Threshold for   |
    | _tol            |                 |                 | indicating      |
    |                 |                 |                 | wrong           |
    |                 |                 |                 | derivative.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | diverging_itera | OT_REAL         | 1.000e+20       | Threshold for   |
    | tes_tol         |                 |                 | maximal value   |
    |                 |                 |                 | of primal       |
    |                 |                 |                 | iterates. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | dual_inf_tol    | OT_REAL         | 1               | Desired         |
    |                 |                 |                 | threshold for   |
    |                 |                 |                 | the dual        |
    |                 |                 |                 | infeasibility.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | epsilon_c       | OT_REAL         | 0.010           | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | eta_min         | OT_REAL         | 10              | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | eta_penalty     | OT_REAL         | 0.000           | Relaxation      |
    |                 |                 |                 | factor in the   |
    |                 |                 |                 | Armijo          |
    |                 |                 |                 | condition for   |
    |                 |                 |                 | the penalty     |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | eta_phi         | OT_REAL         | 0.000           | Relaxation      |
    |                 |                 |                 | factor in the   |
    |                 |                 |                 | Armijo          |
    |                 |                 |                 | condition. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | evaluate_orig_o | OT_STRING       | yes             | Determines if   |
    | bj_at_resto_tri |                 |                 | the original    |
    | al              |                 |                 | objective       |
    |                 |                 |                 | function should |
    |                 |                 |                 | be evaluated at |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase trial     |
    |                 |                 |                 | points. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | expect_infeasib | OT_STRING       | no              | Enable          |
    | le_problem      |                 |                 | heuristics to   |
    |                 |                 |                 | quickly detect  |
    |                 |                 |                 | an infeasible   |
    |                 |                 |                 | problem. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | expect_infeasib | OT_REAL         | 0.001           | Threshold for   |
    | le_problem_ctol |                 |                 | disabling "expe |
    |                 |                 |                 | ct_infeasible_p |
    |                 |                 |                 | roblem" option. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | expect_infeasib | OT_REAL         | 100000000       | Multiplier      |
    | le_problem_ytol |                 |                 | threshold for   |
    |                 |                 |                 | activating "exp |
    |                 |                 |                 | ect_infeasible_ |
    |                 |                 |                 | problem"        |
    |                 |                 |                 | option. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | fast_des_fact   | OT_REAL         | 0.100           | a parameter     |
    |                 |                 |                 | used to check   |
    |                 |                 |                 | if the fast     |
    |                 |                 |                 | direction can   |
    |                 |                 |                 | be used asthe   |
    |                 |                 |                 | line search     |
    |                 |                 |                 | direction (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | fast_step_compu | OT_STRING       | no              | Indicates if    |
    | tation          |                 |                 | the linear      |
    |                 |                 |                 | system should   |
    |                 |                 |                 | be solved       |
    |                 |                 |                 | quickly. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | file_print_leve | OT_INTEGER      | 5               | Verbosity level |
    | l               |                 |                 | for output      |
    |                 |                 |                 | file. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | filter_margin_f | OT_REAL         | 0.000           | Factor          |
    | act             |                 |                 | determining     |
    |                 |                 |                 | width of margin |
    |                 |                 |                 | for obj-constr- |
    |                 |                 |                 | filter adaptive |
    |                 |                 |                 | globalization   |
    |                 |                 |                 | strategy. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | filter_max_marg | OT_REAL         | 1               | Maximum width   |
    | in              |                 |                 | of margin in    |
    |                 |                 |                 | obj-constr-     |
    |                 |                 |                 | filter adaptive |
    |                 |                 |                 | globalization   |
    |                 |                 |                 | strategy. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | filter_reset_tr | OT_INTEGER      | 5               | Number of       |
    | igger           |                 |                 | iterations that |
    |                 |                 |                 | trigger the     |
    |                 |                 |                 | filter reset.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | findiff_perturb | OT_REAL         | 0.000           | Size of the     |
    | ation           |                 |                 | finite          |
    |                 |                 |                 | difference      |
    |                 |                 |                 | perturbation    |
    |                 |                 |                 | for derivative  |
    |                 |                 |                 | approximation.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | first_hessian_p | OT_REAL         | 0.000           | Size of first   |
    | erturbation     |                 |                 | x-s             |
    |                 |                 |                 | perturbation    |
    |                 |                 |                 | tried. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | fixed_mu_oracle | OT_STRING       | average_compl   | Oracle for the  |
    |                 |                 |                 | barrier         |
    |                 |                 |                 | parameter when  |
    |                 |                 |                 | switching to    |
    |                 |                 |                 | fixed mode.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | fixed_variable_ | OT_STRING       | make_parameter  | Determines how  |
    | treatment       |                 |                 | fixed variables |
    |                 |                 |                 | should be       |
    |                 |                 |                 | handled. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma_hat       | OT_REAL         | 0.040           | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma_phi       | OT_REAL         | 0.000           | Relaxation      |
    |                 |                 |                 | factor in the   |
    |                 |                 |                 | filter margin   |
    |                 |                 |                 | for the barrier |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma_theta     | OT_REAL         | 0.000           | Relaxation      |
    |                 |                 |                 | factor in the   |
    |                 |                 |                 | filter margin   |
    |                 |                 |                 | for the         |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma_tilde     | OT_REAL         | 4               | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_approxi | OT_STRING       | exact           | Indicates what  |
    | mation          |                 |                 | Hessian         |
    |                 |                 |                 | information is  |
    |                 |                 |                 | to be used.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_approxi | OT_STRING       | nonlinear-      | Indicates in    |
    | mation_space    |                 | variables       | which subspace  |
    |                 |                 |                 | the Hessian     |
    |                 |                 |                 | information is  |
    |                 |                 |                 | to be           |
    |                 |                 |                 | approximated.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_constan | OT_STRING       | no              | Indicates       |
    | t               |                 |                 | whether the     |
    |                 |                 |                 | problem is a    |
    |                 |                 |                 | quadratic       |
    |                 |                 |                 | problem (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | honor_original_ | OT_STRING       | yes             | Indicates       |
    | bounds          |                 |                 | whether final   |
    |                 |                 |                 | points should   |
    |                 |                 |                 | be projected    |
    |                 |                 |                 | into original   |
    |                 |                 |                 | bounds. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | inf_pr_output   | OT_STRING       | original        | Determines what |
    |                 |                 |                 | value is        |
    |                 |                 |                 | printed in the  |
    |                 |                 |                 | "inf_pr" output |
    |                 |                 |                 | column. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_c_constant  | OT_STRING       | no              | Indicates       |
    |                 |                 |                 | whether all     |
    |                 |                 |                 | equality        |
    |                 |                 |                 | constraints are |
    |                 |                 |                 | linear (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_d_constant  | OT_STRING       | no              | Indicates       |
    |                 |                 |                 | whether all     |
    |                 |                 |                 | inequality      |
    |                 |                 |                 | constraints are |
    |                 |                 |                 | linear (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | jacobian_approx | OT_STRING       | exact           | Specifies       |
    | imation         |                 |                 | technique to    |
    |                 |                 |                 | compute         |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | Jacobian (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | jacobian_regula | OT_REAL         | 0.250           | Exponent for mu |
    | rization_expone |                 |                 | in the          |
    | nt              |                 |                 | regularization  |
    |                 |                 |                 | for rank-       |
    |                 |                 |                 | deficient       |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | Jacobians. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | jacobian_regula | OT_REAL         | 0.000           | Size of the     |
    | rization_value  |                 |                 | regularization  |
    |                 |                 |                 | for rank-       |
    |                 |                 |                 | deficient       |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | Jacobians. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | kappa_d         | OT_REAL         | 0.000           | Weight for      |
    |                 |                 |                 | linear damping  |
    |                 |                 |                 | term (to handle |
    |                 |                 |                 | one-sided       |
    |                 |                 |                 | bounds). (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | kappa_sigma     | OT_REAL         | 1.000e+10       | Factor limiting |
    |                 |                 |                 | the deviation   |
    |                 |                 |                 | of dual         |
    |                 |                 |                 | variables from  |
    |                 |                 |                 | primal          |
    |                 |                 |                 | estimates. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | kappa_soc       | OT_REAL         | 0.990           | Factor in the   |
    |                 |                 |                 | sufficient      |
    |                 |                 |                 | reduction rule  |
    |                 |                 |                 | for second      |
    |                 |                 |                 | order           |
    |                 |                 |                 | correction.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | kappa_x_dis     | OT_REAL         | 100             | a parameter     |
    |                 |                 |                 | used to check   |
    |                 |                 |                 | if the fast     |
    |                 |                 |                 | direction can   |
    |                 |                 |                 | be used asthe   |
    |                 |                 |                 | line search     |
    |                 |                 |                 | direction (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | kappa_y_dis     | OT_REAL         | 10000           | a parameter     |
    |                 |                 |                 | used to check   |
    |                 |                 |                 | if the fast     |
    |                 |                 |                 | direction can   |
    |                 |                 |                 | be used asthe   |
    |                 |                 |                 | line search     |
    |                 |                 |                 | direction (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | least_square_in | OT_STRING       | no              | Least square    |
    | it_duals        |                 |                 | initialization  |
    |                 |                 |                 | of all dual     |
    |                 |                 |                 | variables (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | least_square_in | OT_STRING       | no              | Least square    |
    | it_primal       |                 |                 | initialization  |
    |                 |                 |                 | of the primal   |
    |                 |                 |                 | variables (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_STRING       | sherman-        | Strategy for    |
    | aug_solver      |                 | morrison        | solving the     |
    |                 |                 |                 | augmented       |
    |                 |                 |                 | system for low- |
    |                 |                 |                 | rank Hessian.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_REAL         | 1               | Value for B0 in |
    | init_val        |                 |                 | low-rank        |
    |                 |                 |                 | update. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_REAL         | 100000000       | Upper bound on  |
    | init_val_max    |                 |                 | value for B0 in |
    |                 |                 |                 | low-rank        |
    |                 |                 |                 | update. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_REAL         | 0.000           | Lower bound on  |
    | init_val_min    |                 |                 | value for B0 in |
    |                 |                 |                 | low-rank        |
    |                 |                 |                 | update. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_STRING       | scalar1         | Initialization  |
    | initialization  |                 |                 | strategy for    |
    |                 |                 |                 | the limited     |
    |                 |                 |                 | memory quasi-   |
    |                 |                 |                 | Newton          |
    |                 |                 |                 | approximation.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_INTEGER      | 6               | Maximum size of |
    | max_history     |                 |                 | the history for |
    |                 |                 |                 | the limited     |
    |                 |                 |                 | quasi-Newton    |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | approximation.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_INTEGER      | 2               | Threshold for   |
    | max_skipping    |                 |                 | successive      |
    |                 |                 |                 | iterations      |
    |                 |                 |                 | where update is |
    |                 |                 |                 | skipped. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_STRING       | no              | Determines if   |
    | special_for_res |                 |                 | the quasi-      |
    | to              |                 |                 | Newton updates  |
    |                 |                 |                 | should be       |
    |                 |                 |                 | special during  |
    |                 |                 |                 | the restoration |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | limited_memory_ | OT_STRING       | bfgs            | Quasi-Newton    |
    | update_type     |                 |                 | update formula  |
    |                 |                 |                 | for the limited |
    |                 |                 |                 | memory          |
    |                 |                 |                 | approximation.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | line_search_met | OT_STRING       | filter          | Globalization   |
    | hod             |                 |                 | method used in  |
    |                 |                 |                 | backtracking    |
    |                 |                 |                 | line search     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_scaling_ | OT_STRING       | yes             | Flag indicating |
    | on_demand       |                 |                 | that linear     |
    |                 |                 |                 | scaling is only |
    |                 |                 |                 | done if it      |
    |                 |                 |                 | seems required. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver   | OT_STRING       | mumps           | Linear solver   |
    |                 |                 |                 | used for step   |
    |                 |                 |                 | computations.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_system_s | OT_STRING       | none            | Method for      |
    | caling          |                 |                 | scaling the     |
    |                 |                 |                 | linear system.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_ignore_sin | OT_STRING       | no              | Enables MA27's  |
    | gularity        |                 |                 | ability to      |
    |                 |                 |                 | solve a linear  |
    |                 |                 |                 | system even if  |
    |                 |                 |                 | the matrix is   |
    |                 |                 |                 | singular. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_la_init_fa | OT_REAL         | 5               | Real workspace  |
    | ctor            |                 |                 | memory for      |
    |                 |                 |                 | MA27. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_liw_init_f | OT_REAL         | 5               | Integer         |
    | actor           |                 |                 | workspace       |
    |                 |                 |                 | memory for      |
    |                 |                 |                 | MA27. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_meminc_fac | OT_REAL         | 2               | Increment       |
    | tor             |                 |                 | factor for      |
    |                 |                 |                 | workspace size  |
    |                 |                 |                 | for MA27. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_pivtol     | OT_REAL         | 0.000           | Pivot tolerance |
    |                 |                 |                 | for the linear  |
    |                 |                 |                 | solver MA27.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_pivtolmax  | OT_REAL         | 0.000           | Maximum pivot   |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | the linear      |
    |                 |                 |                 | solver MA27.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma27_skip_inert | OT_STRING       | no              | Always pretend  |
    | ia_check        |                 |                 | inertia is      |
    |                 |                 |                 | correct. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma28_pivtol     | OT_REAL         | 0.010           | Pivot tolerance |
    |                 |                 |                 | for linear      |
    |                 |                 |                 | solver MA28.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_automatic_ | OT_STRING       | no              | Controls MA57   |
    | scaling         |                 |                 | automatic       |
    |                 |                 |                 | scaling (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_block_size | OT_INTEGER      | 16              | Controls block  |
    |                 |                 |                 | size used by    |
    |                 |                 |                 | Level 3 BLAS in |
    |                 |                 |                 | MA57BD (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_node_amalg | OT_INTEGER      | 16              | Node            |
    | amation         |                 |                 | amalgamation    |
    |                 |                 |                 | parameter (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_pivot_orde | OT_INTEGER      | 5               | Controls pivot  |
    | r               |                 |                 | order in MA57   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_pivtol     | OT_REAL         | 0.000           | Pivot tolerance |
    |                 |                 |                 | for the linear  |
    |                 |                 |                 | solver MA57.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_pivtolmax  | OT_REAL         | 0.000           | Maximum pivot   |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | the linear      |
    |                 |                 |                 | solver MA57.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_pre_alloc  | OT_REAL         | 1.050           | Safety factor   |
    |                 |                 |                 | for work space  |
    |                 |                 |                 | memory          |
    |                 |                 |                 | allocation for  |
    |                 |                 |                 | the linear      |
    |                 |                 |                 | solver MA57.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma57_small_pivo | OT_INTEGER      | 0               | If set to 1,    |
    | t_flag          |                 |                 | then when small |
    |                 |                 |                 | entries defined |
    |                 |                 |                 | by CNTL(2) are  |
    |                 |                 |                 | detected they   |
    |                 |                 |                 | are removed and |
    |                 |                 |                 | the             |
    |                 |                 |                 | corresponding   |
    |                 |                 |                 | pivots placed   |
    |                 |                 |                 | at the end of   |
    |                 |                 |                 | the             |
    |                 |                 |                 | factorization.  |
    |                 |                 |                 | This can be     |
    |                 |                 |                 | particularly    |
    |                 |                 |                 | efficient if    |
    |                 |                 |                 | the matrix is   |
    |                 |                 |                 | highly rank     |
    |                 |                 |                 | deficient. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_buffer_lpa | OT_INTEGER      | 4096            | Number of       |
    | ge              |                 |                 | scalars per     |
    |                 |                 |                 | MA77 buffer     |
    |                 |                 |                 | page (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_buffer_npa | OT_INTEGER      | 1600            | Number of pages |
    | ge              |                 |                 | that make up    |
    |                 |                 |                 | MA77 buffer     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_file_size  | OT_INTEGER      | 2097152         | Target size of  |
    |                 |                 |                 | each temporary  |
    |                 |                 |                 | file for MA77,  |
    |                 |                 |                 | scalars per     |
    |                 |                 |                 | type (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_maxstore   | OT_INTEGER      | 0               | Maximum storage |
    |                 |                 |                 | size for MA77   |
    |                 |                 |                 | in-core mode    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_nemin      | OT_INTEGER      | 8               | Node            |
    |                 |                 |                 | Amalgamation    |
    |                 |                 |                 | parameter (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_order      | OT_STRING       | amd             | Controls type   |
    |                 |                 |                 | of ordering     |
    |                 |                 |                 | used by         |
    |                 |                 |                 | HSL_MA77 (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_print_leve | OT_INTEGER      | -1              | Debug printing  |
    | l               |                 |                 | level for the   |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | MA77 (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_small      | OT_REAL         | 0.000           | Zero Pivot      |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_static     | OT_REAL         | 0               | Static Pivoting |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_u          | OT_REAL         | 0.000           | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma77_umax       | OT_REAL         | 0.000           | Maximum         |
    |                 |                 |                 | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_nemin      | OT_INTEGER      | 32              | Node            |
    |                 |                 |                 | Amalgamation    |
    |                 |                 |                 | parameter (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_order      | OT_STRING       | amd             | Controls type   |
    |                 |                 |                 | of ordering     |
    |                 |                 |                 | used by         |
    |                 |                 |                 | HSL_MA86 (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_print_leve | OT_INTEGER      | -1              | Debug printing  |
    | l               |                 |                 | level for the   |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | MA86 (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_scaling    | OT_STRING       | mc64            | Controls        |
    |                 |                 |                 | scaling of      |
    |                 |                 |                 | matrix (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_small      | OT_REAL         | 0.000           | Zero Pivot      |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_static     | OT_REAL         | 0               | Static Pivoting |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_u          | OT_REAL         | 0.000           | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma86_umax       | OT_REAL         | 0.000           | Maximum         |
    |                 |                 |                 | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_nemin      | OT_INTEGER      | 8               | Node            |
    |                 |                 |                 | Amalgamation    |
    |                 |                 |                 | parameter (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_order      | OT_STRING       | auto            | Controls type   |
    |                 |                 |                 | of ordering     |
    |                 |                 |                 | used by         |
    |                 |                 |                 | HSL_MA97 (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_print_leve | OT_INTEGER      | 0               | Debug printing  |
    | l               |                 |                 | level for the   |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | MA97 (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_scaling    | OT_STRING       | dynamic         | Specifies       |
    |                 |                 |                 | strategy for    |
    |                 |                 |                 | scaling in      |
    |                 |                 |                 | HSL_MA97 linear |
    |                 |                 |                 | solver (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_scaling1   | OT_STRING       | mc64            | First scaling.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_scaling2   | OT_STRING       | mc64            | Second scaling. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_scaling3   | OT_STRING       | mc64            | Third scaling.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_small      | OT_REAL         | 0.000           | Zero Pivot      |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_solve_blas | OT_STRING       | no              | Controls if     |
    | 3               |                 |                 | blas2 or blas3  |
    |                 |                 |                 | routines are    |
    |                 |                 |                 | used for solve  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_switch1    | OT_STRING       | od_hd_reuse     | First switch,   |
    |                 |                 |                 | determine when  |
    |                 |                 |                 | ma97_scaling1   |
    |                 |                 |                 | is enabled.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_switch2    | OT_STRING       | never           | Second switch,  |
    |                 |                 |                 | determine when  |
    |                 |                 |                 | ma97_scaling2   |
    |                 |                 |                 | is enabled.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_switch3    | OT_STRING       | never           | Third switch,   |
    |                 |                 |                 | determine when  |
    |                 |                 |                 | ma97_scaling3   |
    |                 |                 |                 | is enabled.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_u          | OT_REAL         | 0.000           | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | ma97_umax       | OT_REAL         | 0.000           | Maximum         |
    |                 |                 |                 | Pivoting        |
    |                 |                 |                 | Threshold (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | magic_steps     | OT_STRING       | no              | Enables magic   |
    |                 |                 |                 | steps. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_cpu_time    | OT_REAL         | 1000000         | Maximum number  |
    |                 |                 |                 | of CPU seconds. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_filter_rese | OT_INTEGER      | 5               | Maximal allowed |
    | ts              |                 |                 | number of       |
    |                 |                 |                 | filter resets   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_hessian_per | OT_REAL         | 1.000e+20       | Maximum value   |
    | turbation       |                 |                 | of              |
    |                 |                 |                 | regularization  |
    |                 |                 |                 | parameter for   |
    |                 |                 |                 | handling        |
    |                 |                 |                 | negative        |
    |                 |                 |                 | curvature. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 3000            | Maximum number  |
    |                 |                 |                 | of iterations.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_refinement_ | OT_INTEGER      | 10              | Maximum number  |
    | steps           |                 |                 | of iterative    |
    |                 |                 |                 | refinement      |
    |                 |                 |                 | steps per       |
    |                 |                 |                 | linear system   |
    |                 |                 |                 | solve. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_resto_iter  | OT_INTEGER      | 3000000         | Maximum number  |
    |                 |                 |                 | of successive   |
    |                 |                 |                 | iterations in   |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_soc         | OT_INTEGER      | 4               | Maximum number  |
    |                 |                 |                 | of second order |
    |                 |                 |                 | correction      |
    |                 |                 |                 | trial steps at  |
    |                 |                 |                 | each iteration. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | max_soft_resto_ | OT_INTEGER      | 10              | Maximum number  |
    | iters           |                 |                 | of iterations   |
    |                 |                 |                 | performed       |
    |                 |                 |                 | successively in |
    |                 |                 |                 | soft            |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mehrotra_algori | OT_STRING       | no              | Indicates if we |
    | thm             |                 |                 | want to do      |
    |                 |                 |                 | Mehrotra's      |
    |                 |                 |                 | algorithm. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | min_alpha_prima | OT_REAL         | 0.000           | LIFENG WRITES   |
    | l               |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | min_hessian_per | OT_REAL         | 0.000           | Smallest        |
    | turbation       |                 |                 | perturbation of |
    |                 |                 |                 | the Hessian     |
    |                 |                 |                 | block. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | min_refinement_ | OT_INTEGER      | 1               | Minimum number  |
    | steps           |                 |                 | of iterative    |
    |                 |                 |                 | refinement      |
    |                 |                 |                 | steps per       |
    |                 |                 |                 | linear system   |
    |                 |                 |                 | solve. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_allow_fast_m | OT_STRING       | yes             | Allow skipping  |
    | onotone_decreas |                 |                 | of barrier      |
    | e               |                 |                 | problem if      |
    |                 |                 |                 | barrier test is |
    |                 |                 |                 | already met.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_init         | OT_REAL         | 0.100           | Initial value   |
    |                 |                 |                 | for the barrier |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_linear_decre | OT_REAL         | 0.200           | Determines      |
    | ase_factor      |                 |                 | linear decrease |
    |                 |                 |                 | rate of barrier |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_max          | OT_REAL         | 100000          | Maximum value   |
    |                 |                 |                 | for barrier     |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_max_fact     | OT_REAL         | 1000            | Factor for      |
    |                 |                 |                 | initialization  |
    |                 |                 |                 | of maximum      |
    |                 |                 |                 | value for       |
    |                 |                 |                 | barrier         |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_min          | OT_REAL         | 0.000           | Minimum value   |
    |                 |                 |                 | for barrier     |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_oracle       | OT_STRING       | quality-        | Oracle for a    |
    |                 |                 | function        | new barrier     |
    |                 |                 |                 | parameter in    |
    |                 |                 |                 | the adaptive    |
    |                 |                 |                 | strategy. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_strategy     | OT_STRING       | monotone        | Update strategy |
    |                 |                 |                 | for barrier     |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_superlinear_ | OT_REAL         | 1.500           | Determines      |
    | decrease_power  |                 |                 | superlinear     |
    |                 |                 |                 | decrease rate   |
    |                 |                 |                 | of barrier      |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mu_target       | OT_REAL         | 0               | Desired value   |
    |                 |                 |                 | of complementar |
    |                 |                 |                 | ity. (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mult_diverg_fea | OT_REAL         | 0.000           | tolerance for   |
    | sibility_tol    |                 |                 | deciding if the |
    |                 |                 |                 | multipliers are |
    |                 |                 |                 | diverging (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mult_diverg_y_t | OT_REAL         | 100000000       | tolerance for   |
    | ol              |                 |                 | deciding if the |
    |                 |                 |                 | multipliers are |
    |                 |                 |                 | diverging (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_dep_tol   | OT_REAL         | 0               | Pivot threshold |
    |                 |                 |                 | for detection   |
    |                 |                 |                 | of linearly     |
    |                 |                 |                 | dependent       |
    |                 |                 |                 | constraints in  |
    |                 |                 |                 | MUMPS. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_mem_perce | OT_INTEGER      | 1000            | Percentage      |
    | nt              |                 |                 | increase in the |
    |                 |                 |                 | estimated       |
    |                 |                 |                 | working space   |
    |                 |                 |                 | for MUMPS. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_permuting | OT_INTEGER      | 7               | Controls        |
    | _scaling        |                 |                 | permuting and   |
    |                 |                 |                 | scaling in      |
    |                 |                 |                 | MUMPS (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_pivot_ord | OT_INTEGER      | 7               | Controls pivot  |
    | er              |                 |                 | order in MUMPS  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_pivtol    | OT_REAL         | 0.000           | Pivot tolerance |
    |                 |                 |                 | for the linear  |
    |                 |                 |                 | solver MUMPS.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_pivtolmax | OT_REAL         | 0.100           | Maximum pivot   |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | the linear      |
    |                 |                 |                 | solver MUMPS.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | mumps_scaling   | OT_INTEGER      | 77              | Controls        |
    |                 |                 |                 | scaling in      |
    |                 |                 |                 | MUMPS (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | neg_curv_test_t | OT_REAL         | 0               | Tolerance for   |
    | ol              |                 |                 | heuristic to    |
    |                 |                 |                 | ignore wrong    |
    |                 |                 |                 | inertia. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | never_use_fact_ | OT_STRING       | no              | Toggle to       |
    | cgpen_direction |                 |                 | switch off the  |
    |                 |                 |                 | fast Chen-      |
    |                 |                 |                 | Goldfarb        |
    |                 |                 |                 | direction (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | never_use_piece | OT_STRING       | no              | Toggle to       |
    | wise_penalty_ls |                 |                 | switch off the  |
    |                 |                 |                 | piecewise       |
    |                 |                 |                 | penalty method  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_lower_bound | OT_REAL         | -1.000e+19      | any bound less  |
    | _inf            |                 |                 | or equal this   |
    |                 |                 |                 | value will be   |
    |                 |                 |                 | considered -inf |
    |                 |                 |                 | (i.e. not lower |
    |                 |                 |                 | bounded). (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_scaling_con | OT_REAL         | 0               | Target value    |
    | str_target_grad |                 |                 | for constraint  |
    | ient            |                 |                 | function        |
    |                 |                 |                 | gradient size.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_scaling_max | OT_REAL         | 100             | Maximum         |
    | _gradient       |                 |                 | gradient after  |
    |                 |                 |                 | NLP scaling.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_scaling_met | OT_STRING       | gradient-based  | Select the      |
    | hod             |                 |                 | technique used  |
    |                 |                 |                 | for scaling the |
    |                 |                 |                 | NLP. (see IPOPT |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_scaling_min | OT_REAL         | 0.000           | Minimum value   |
    | _value          |                 |                 | of gradient-    |
    |                 |                 |                 | based scaling   |
    |                 |                 |                 | values. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_scaling_obj | OT_REAL         | 0               | Target value    |
    | _target_gradien |                 |                 | for objective   |
    | t               |                 |                 | function        |
    |                 |                 |                 | gradient size.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_upper_bound | OT_REAL         | 1.000e+19       | any bound       |
    | _inf            |                 |                 | greater or this |
    |                 |                 |                 | value will be   |
    |                 |                 |                 | considered +inf |
    |                 |                 |                 | (i.e. not upper |
    |                 |                 |                 | bounded). (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nu_inc          | OT_REAL         | 0.000           | Increment of    |
    |                 |                 |                 | the penalty     |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | nu_init         | OT_REAL         | 0.000           | Initial value   |
    |                 |                 |                 | of the penalty  |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | num_linear_vari | OT_INTEGER      | 0               | Number of       |
    | ables           |                 |                 | linear          |
    |                 |                 |                 | variables (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | obj_max_inc     | OT_REAL         | 5               | Determines the  |
    |                 |                 |                 | upper bound on  |
    |                 |                 |                 | the acceptable  |
    |                 |                 |                 | increase of     |
    |                 |                 |                 | barrier         |
    |                 |                 |                 | objective       |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | obj_scaling_fac | OT_REAL         | 1               | Scaling factor  |
    | tor             |                 |                 | for the         |
    |                 |                 |                 | objective       |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | option_file_nam | OT_STRING       | ipopt.opt       | File name of    |
    | e               |                 |                 | options file.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | output_file     | OT_STRING       |                 | File name of    |
    |                 |                 |                 | desired output  |
    |                 |                 |                 | file (leave     |
    |                 |                 |                 | unset for no    |
    |                 |                 |                 | file output).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_co | OT_INTEGER      | 5000            | Maximum Size of |
    | arse_size       |                 |                 | Coarse Grid     |
    |                 |                 |                 | Matrix (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_dr | OT_REAL         | 0.500           | dropping value  |
    | opping_factor   |                 |                 | for incomplete  |
    |                 |                 |                 | factor (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_dr | OT_REAL         | 0.100           | dropping value  |
    | opping_schur    |                 |                 | for sparsify    |
    |                 |                 |                 | schur           |
    |                 |                 |                 | complement      |
    |                 |                 |                 | factor (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_in | OT_REAL         | 5000000         | (see IPOPT      |
    | verse_norm_fact |                 |                 | documentation)  |
    | or              |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_ma | OT_INTEGER      | 10              | Maximum Size of |
    | x_levels        |                 |                 | Grid Levels     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_ma | OT_INTEGER      | 10000000        | max fill for    |
    | x_row_fill      |                 |                 | each row (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iter_re | OT_REAL         | 0.000           | Relative        |
    | lative_tol      |                 |                 | Residual        |
    |                 |                 |                 | Convergence     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_iterati | OT_STRING       | no              | Switch on       |
    | ve              |                 |                 | iterative       |
    |                 |                 |                 | solver in       |
    |                 |                 |                 | Pardiso library |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_matchin | OT_STRING       | complete+2x2    | Matching        |
    | g_strategy      |                 |                 | strategy to be  |
    |                 |                 |                 | used by Pardiso |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_max_dro | OT_INTEGER      | 4               | Maximal number  |
    | ptol_correction |                 |                 | of decreases of |
    | s               |                 |                 | drop tolerance  |
    |                 |                 |                 | during one      |
    |                 |                 |                 | solve. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_max_ite | OT_INTEGER      | 500             | Maximum number  |
    | r               |                 |                 | of Krylov-      |
    |                 |                 |                 | Subspace        |
    |                 |                 |                 | Iteration (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_msglvl  | OT_INTEGER      | 0               | Pardiso message |
    |                 |                 |                 | level (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_out_of_ | OT_INTEGER      | 0               | Enables out-of- |
    | core_power      |                 |                 | core variant of |
    |                 |                 |                 | Pardiso (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_redo_sy | OT_STRING       | no              | Toggle for      |
    | mbolic_fact_onl |                 |                 | handling case   |
    | y_if_inertia_wr |                 |                 | when elements   |
    | ong             |                 |                 | were perturbed  |
    |                 |                 |                 | by Pardiso.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_repeate | OT_STRING       | no              | Interpretation  |
    | d_perturbation_ |                 |                 | of perturbed    |
    | means_singular  |                 |                 | elements. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pardiso_skip_in | OT_STRING       | no              | Always pretend  |
    | ertia_check     |                 |                 | inertia is      |
    |                 |                 |                 | correct. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pass_nonlinear_ | OT_BOOLEAN      | False           | n/a             |
    | variables       |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | pen_des_fact    | OT_REAL         | 0.200           | a parameter     |
    |                 |                 |                 | used in penalty |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | computation     |
    |                 |                 |                 | (for Chen-      |
    |                 |                 |                 | Goldfarb line   |
    |                 |                 |                 | search). (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pen_init_fac    | OT_REAL         | 50              | a parameter     |
    |                 |                 |                 | used to choose  |
    |                 |                 |                 | initial penalty |
    |                 |                 |                 | parameterswhen  |
    |                 |                 |                 | the regularized |
    |                 |                 |                 | Newton method   |
    |                 |                 |                 | is used. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | pen_theta_max_f | OT_REAL         | 10000           | Determines      |
    | act             |                 |                 | upper bound for |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation in    |
    |                 |                 |                 | the filter.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | penalty_init_ma | OT_REAL         | 100000          | Maximal value   |
    | x               |                 |                 | for the intial  |
    |                 |                 |                 | penalty         |
    |                 |                 |                 | parameter (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | penalty_init_mi | OT_REAL         | 1               | Minimal value   |
    | n               |                 |                 | for the intial  |
    |                 |                 |                 | penalty         |
    |                 |                 |                 | parameter for   |
    |                 |                 |                 | line search(for |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | penalty_max     | OT_REAL         | 1.000e+30       | Maximal value   |
    |                 |                 |                 | for the penalty |
    |                 |                 |                 | parameter (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | penalty_update_ | OT_REAL         | 10              | LIFENG WRITES   |
    | compl_tol       |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | penalty_update_ | OT_REAL         | 0.000           | Threshold for   |
    | infeasibility_t |                 |                 | infeasibility   |
    | ol              |                 |                 | in penalty      |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | update test.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | perturb_always_ | OT_STRING       | no              | Active          |
    | cd              |                 |                 | permanent       |
    |                 |                 |                 | perturbation of |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | linearization.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | perturb_dec_fac | OT_REAL         | 0.333           | Decrease factor |
    | t               |                 |                 | for x-s         |
    |                 |                 |                 | perturbation.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | perturb_inc_fac | OT_REAL         | 8               | Increase factor |
    | t               |                 |                 | for x-s         |
    |                 |                 |                 | perturbation.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | perturb_inc_fac | OT_REAL         | 100             | Increase factor |
    | t_first         |                 |                 | for x-s         |
    |                 |                 |                 | perturbation    |
    |                 |                 |                 | for very first  |
    |                 |                 |                 | perturbation.   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | piecewisepenalt | OT_REAL         | 0.000           | LIFENG WRITES   |
    | y_gamma_infeasi |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | piecewisepenalt | OT_REAL         | 0.000           | LIFENG WRITES   |
    | y_gamma_obj     |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | point_perturbat | OT_REAL         | 10              | Maximal         |
    | ion_radius      |                 |                 | perturbation of |
    |                 |                 |                 | an evaluation   |
    |                 |                 |                 | point. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_frequency | OT_INTEGER      | 1               | Determines at   |
    | _iter           |                 |                 | which iteration |
    |                 |                 |                 | frequency the   |
    |                 |                 |                 | summarizing     |
    |                 |                 |                 | iteration       |
    |                 |                 |                 | output line     |
    |                 |                 |                 | should be       |
    |                 |                 |                 | printed. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_frequency | OT_REAL         | 0               | Determines at   |
    | _time           |                 |                 | which time      |
    |                 |                 |                 | frequency the   |
    |                 |                 |                 | summarizing     |
    |                 |                 |                 | iteration       |
    |                 |                 |                 | output line     |
    |                 |                 |                 | should be       |
    |                 |                 |                 | printed. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_info_stri | OT_STRING       | no              | Enables         |
    | ng              |                 |                 | printing of     |
    |                 |                 |                 | additional info |
    |                 |                 |                 | string at end   |
    |                 |                 |                 | of iteration    |
    |                 |                 |                 | output. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_level     | OT_INTEGER      | 5               | Output          |
    |                 |                 |                 | verbosity       |
    |                 |                 |                 | level. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_options_d | OT_STRING       | no              | Switch to print |
    | ocumentation    |                 |                 | all algorithmic |
    |                 |                 |                 | options. (see   |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_options_l | OT_STRING       | no              | Undocumented    |
    | atex_mode       |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOLEAN      | True            | print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about execution |
    |                 |                 |                 | time            |
    +-----------------+-----------------+-----------------+-----------------+
    | print_timing_st | OT_STRING       | no              | Switch to print |
    | atistics        |                 |                 | timing          |
    |                 |                 |                 | statistics.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_user_opti | OT_STRING       | no              | Print all       |
    | ons             |                 |                 | options set by  |
    |                 |                 |                 | the user. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_STRING       | none            | The balancing   |
    | n_balancing_ter |                 |                 | term included   |
    | m               |                 |                 | in the quality  |
    |                 |                 |                 | function for    |
    |                 |                 |                 | centrality.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_STRING       | none            | The penalty     |
    | n_centrality    |                 |                 | term for        |
    |                 |                 |                 | centrality that |
    |                 |                 |                 | is included in  |
    |                 |                 |                 | quality         |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_INTEGER      | 8               | Maximum number  |
    | n_max_section_s |                 |                 | of search steps |
    | teps            |                 |                 | during direct   |
    |                 |                 |                 | search          |
    |                 |                 |                 | procedure       |
    |                 |                 |                 | determining the |
    |                 |                 |                 | optimal         |
    |                 |                 |                 | centering       |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_STRING       | 2-norm-squared  | Norm used for   |
    | n_norm_type     |                 |                 | components of   |
    |                 |                 |                 | the quality     |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_REAL         | 0               | Tolerance for   |
    | n_section_qf_to |                 |                 | the golden      |
    | l               |                 |                 | section search  |
    |                 |                 |                 | procedure       |
    |                 |                 |                 | determining the |
    |                 |                 |                 | optimal         |
    |                 |                 |                 | centering       |
    |                 |                 |                 | parameter (in   |
    |                 |                 |                 | the function    |
    |                 |                 |                 | value space).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | quality_functio | OT_REAL         | 0.010           | Tolerance for   |
    | n_section_sigma |                 |                 | the section     |
    | _tol            |                 |                 | search          |
    |                 |                 |                 | procedure       |
    |                 |                 |                 | determining the |
    |                 |                 |                 | optimal         |
    |                 |                 |                 | centering       |
    |                 |                 |                 | parameter (in   |
    |                 |                 |                 | sigma space).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | recalc_y        | OT_STRING       | no              | Tells the       |
    |                 |                 |                 | algorithm to    |
    |                 |                 |                 | recalculate the |
    |                 |                 |                 | equality and    |
    |                 |                 |                 | inequality      |
    |                 |                 |                 | multipliers as  |
    |                 |                 |                 | least square    |
    |                 |                 |                 | estimates. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | recalc_y_feas_t | OT_REAL         | 0.000           | Feasibility     |
    | ol              |                 |                 | threshold for   |
    |                 |                 |                 | recomputation   |
    |                 |                 |                 | of multipliers. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | replace_bounds  | OT_STRING       | no              | Indicates if    |
    |                 |                 |                 | all variable    |
    |                 |                 |                 | bounds should   |
    |                 |                 |                 | be replaced by  |
    |                 |                 |                 | inequality      |
    |                 |                 |                 | constraints     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | required_infeas | OT_REAL         | 0.900           | Required        |
    | ibility_reducti |                 |                 | reduction of    |
    | on              |                 |                 | infeasibility   |
    |                 |                 |                 | before leaving  |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | residual_improv | OT_REAL         | 1.000           | Minimal         |
    | ement_factor    |                 |                 | required        |
    |                 |                 |                 | reduction of    |
    |                 |                 |                 | residual test   |
    |                 |                 |                 | ratio in        |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | refinement.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | residual_ratio_ | OT_REAL         | 0.000           | Iterative       |
    | max             |                 |                 | refinement      |
    |                 |                 |                 | tolerance (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | residual_ratio_ | OT_REAL         | 0.000           | Threshold for   |
    | singular        |                 |                 | declaring       |
    |                 |                 |                 | linear system   |
    |                 |                 |                 | singular after  |
    |                 |                 |                 | failed          |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | refinement.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | resto_failure_f | OT_REAL         | 0               | Threshold for   |
    | easibility_thre |                 |                 | primal          |
    | shold           |                 |                 | infeasibility   |
    |                 |                 |                 | to declare      |
    |                 |                 |                 | failure of      |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | resto_penalty_p | OT_REAL         | 1000            | Penalty         |
    | arameter        |                 |                 | parameter in    |
    |                 |                 |                 | the restoration |
    |                 |                 |                 | phase objective |
    |                 |                 |                 | function. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | resto_proximity | OT_REAL         | 1               | Weighting       |
    | _weight         |                 |                 | factor for the  |
    |                 |                 |                 | proximity term  |
    |                 |                 |                 | in restoration  |
    |                 |                 |                 | phase           |
    |                 |                 |                 | objective. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | rho             | OT_REAL         | 0.100           | Value in        |
    |                 |                 |                 | penalty         |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | update formula. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | s_max           | OT_REAL         | 100             | Scaling         |
    |                 |                 |                 | threshold for   |
    |                 |                 |                 | the NLP error.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | s_phi           | OT_REAL         | 2.300           | Exponent for    |
    |                 |                 |                 | linear barrier  |
    |                 |                 |                 | function model  |
    |                 |                 |                 | in the          |
    |                 |                 |                 | switching rule. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | s_theta         | OT_REAL         | 1.100           | Exponent for    |
    |                 |                 |                 | current         |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation in    |
    |                 |                 |                 | the switching   |
    |                 |                 |                 | rule. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | sb              | OT_STRING       | no              | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | sigma_max       | OT_REAL         | 100             | Maximum value   |
    |                 |                 |                 | of the          |
    |                 |                 |                 | centering       |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | sigma_min       | OT_REAL         | 0.000           | Minimum value   |
    |                 |                 |                 | of the          |
    |                 |                 |                 | centering       |
    |                 |                 |                 | parameter. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | skip_corr_if_ne | OT_STRING       | yes             | Skip the        |
    | g_curv          |                 |                 | corrector step  |
    |                 |                 |                 | in negative     |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | iteration       |
    |                 |                 |                 | (unsupported!). |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | skip_corr_in_mo | OT_STRING       | yes             | Skip the        |
    | notone_mode     |                 |                 | corrector step  |
    |                 |                 |                 | during monotone |
    |                 |                 |                 | barrier         |
    |                 |                 |                 | parameter mode  |
    |                 |                 |                 | (unsupported!). |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | skip_finalize_s | OT_STRING       | no              | Indicates if    |
    | olution_call    |                 |                 | call to NLP::Fi |
    |                 |                 |                 | nalizeSolution  |
    |                 |                 |                 | after           |
    |                 |                 |                 | optimization    |
    |                 |                 |                 | should be       |
    |                 |                 |                 | suppressed (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | slack_bound_fra | OT_REAL         | 0.010           | Desired minimum |
    | c               |                 |                 | relative        |
    |                 |                 |                 | distance from   |
    |                 |                 |                 | the initial     |
    |                 |                 |                 | slack to bound. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | slack_bound_pus | OT_REAL         | 0.010           | Desired minimum |
    | h               |                 |                 | absolute        |
    |                 |                 |                 | distance from   |
    |                 |                 |                 | the initial     |
    |                 |                 |                 | slack to bound. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | slack_move      | OT_REAL         | 0.000           | Correction size |
    |                 |                 |                 | for very small  |
    |                 |                 |                 | slacks. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | soft_resto_pder | OT_REAL         | 1.000           | Required        |
    | ror_reduction_f |                 |                 | reduction in    |
    | actor           |                 |                 | primal-dual     |
    |                 |                 |                 | error in the    |
    |                 |                 |                 | soft            |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | start_with_rest | OT_STRING       | no              | Tells algorithm |
    | o               |                 |                 | to switch to    |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | phase in first  |
    |                 |                 |                 | iteration. (see |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | suppress_all_ou | OT_STRING       | no              | Undocumented    |
    | tput            |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | tau_min         | OT_REAL         | 0.990           | Lower bound on  |
    |                 |                 |                 | fraction-to-    |
    |                 |                 |                 | the-boundary    |
    |                 |                 |                 | parameter tau.  |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | theta_max_fact  | OT_REAL         | 10000           | Determines      |
    |                 |                 |                 | upper bound for |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation in    |
    |                 |                 |                 | the filter.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | theta_min       | OT_REAL         | 0.000           | LIFENG WRITES   |
    |                 |                 |                 | THIS. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | theta_min_fact  | OT_REAL         | 0.000           | Determines      |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation       |
    |                 |                 |                 | threshold in    |
    |                 |                 |                 | the switching   |
    |                 |                 |                 | rule. (see      |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | tiny_step_tol   | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | detecting       |
    |                 |                 |                 | numerically     |
    |                 |                 |                 | insignificant   |
    |                 |                 |                 | steps. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | tiny_step_y_tol | OT_REAL         | 0.010           | Tolerance for   |
    |                 |                 |                 | quitting        |
    |                 |                 |                 | because of      |
    |                 |                 |                 | numerically     |
    |                 |                 |                 | insignificant   |
    |                 |                 |                 | steps. (see     |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | tol             | OT_REAL         | 0.000           | Desired         |
    |                 |                 |                 | convergence     |
    |                 |                 |                 | tolerance       |
    |                 |                 |                 | (relative).     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | var_integer_md  | OT_DICTIONARY   | None            | Integer         |
    |                 |                 |                 | metadata (a     |
    |                 |                 |                 | dictionary with |
    |                 |                 |                 | lists of        |
    |                 |                 |                 | integers) about |
    |                 |                 |                 | variables to be |
    |                 |                 |                 | passed to IPOPT |
    +-----------------+-----------------+-----------------+-----------------+
    | var_numeric_md  | OT_DICTIONARY   | None            | Numeric         |
    |                 |                 |                 | metadata (a     |
    |                 |                 |                 | dictionary with |
    |                 |                 |                 | lists of reals) |
    |                 |                 |                 | about variables |
    |                 |                 |                 | to be passed to |
    |                 |                 |                 | IPOPT           |
    +-----------------+-----------------+-----------------+-----------------+
    | var_string_md   | OT_DICTIONARY   | None            | String metadata |
    |                 |                 |                 | (a dictionary   |
    |                 |                 |                 | with lists of   |
    |                 |                 |                 | strings) about  |
    |                 |                 |                 | variables to be |
    |                 |                 |                 | passed to IPOPT |
    +-----------------+-----------------+-----------------+-----------------+
    | vartheta        | OT_REAL         | 0.500           | a parameter     |
    |                 |                 |                 | used to check   |
    |                 |                 |                 | if the fast     |
    |                 |                 |                 | direction can   |
    |                 |                 |                 | be used asthe   |
    |                 |                 |                 | line search     |
    |                 |                 |                 | direction (for  |
    |                 |                 |                 | Chen-Goldfarb   |
    |                 |                 |                 | line search).   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_boun | OT_REAL         | 0.001           | same as         |
    | d_frac          |                 |                 | bound_frac for  |
    |                 |                 |                 | the regular     |
    |                 |                 |                 | initializer.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_boun | OT_REAL         | 0.001           | same as         |
    | d_push          |                 |                 | bound_push for  |
    |                 |                 |                 | the regular     |
    |                 |                 |                 | initializer.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_enti | OT_STRING       | no              | Tells algorithm |
    | re_iterate      |                 |                 | whether to use  |
    |                 |                 |                 | the GetWarmStar |
    |                 |                 |                 | tIterate method |
    |                 |                 |                 | in the NLP.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_init | OT_STRING       | no              | Warm-start for  |
    | _point          |                 |                 | initial point   |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_mult | OT_REAL         | 0.001           | same as         |
    | _bound_push     |                 |                 | mult_bound_push |
    |                 |                 |                 | for the regular |
    |                 |                 |                 | initializer.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_mult | OT_REAL         | 1000000         | Maximum initial |
    | _init_max       |                 |                 | value for the   |
    |                 |                 |                 | equality        |
    |                 |                 |                 | multipliers.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_same | OT_STRING       | no              | Indicates       |
    | _structure      |                 |                 | whether a       |
    |                 |                 |                 | problem with a  |
    |                 |                 |                 | structure       |
    |                 |                 |                 | identical to    |
    |                 |                 |                 | the previous    |
    |                 |                 |                 | one is to be    |
    |                 |                 |                 | solved. (see    |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_slac | OT_REAL         | 0.001           | same as slack_b |
    | k_bound_frac    |                 |                 | ound_frac for   |
    |                 |                 |                 | the regular     |
    |                 |                 |                 | initializer.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_slac | OT_REAL         | 0.001           | same as slack_b |
    | k_bound_push    |                 |                 | ound_push for   |
    |                 |                 |                 | the regular     |
    |                 |                 |                 | initializer.    |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start_targ | OT_REAL         | 0               | Unsupported!    |
    | et_mu           |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | watchdog_shorte | OT_INTEGER      | 10              | Number of       |
    | ned_iter_trigge |                 |                 | shortened       |
    | r               |                 |                 | iterations that |
    |                 |                 |                 | trigger the     |
    |                 |                 |                 | watchdog. (see  |
    |                 |                 |                 | IPOPT           |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | watchdog_trial_ | OT_INTEGER      | 3               | Maximum number  |
    | iter_max        |                 |                 | of watchdog     |
    |                 |                 |                 | iterations.     |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+
    | wsmp_iterative  | OT_STRING       | no              | Switches to     |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | solver in WSMP. |
    |                 |                 |                 | (see IPOPT      |
    |                 |                 |                 | documentation)  |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+

    >List of available stats

    +--------------------+
    |         Id         |
    +====================+
    | con_integer_md     |
    +--------------------+
    | con_numeric_md     |
    +--------------------+
    | con_string_md      |
    +--------------------+
    | iter_count         |
    +--------------------+
    | iteration          |
    +--------------------+
    | iterations         |
    +--------------------+
    | n_eval_f           |
    +--------------------+
    | n_eval_g           |
    +--------------------+
    | n_eval_grad_f      |
    +--------------------+
    | n_eval_h           |
    +--------------------+
    | n_eval_jac_g       |
    +--------------------+
    | return_status      |
    +--------------------+
    | t_callback_fun     |
    +--------------------+
    | t_callback_prepare |
    +--------------------+
    | t_eval_f           |
    +--------------------+
    | t_eval_g           |
    +--------------------+
    | t_eval_grad_f      |
    +--------------------+
    | t_eval_h           |
    +--------------------+
    | t_eval_jac_g       |
    +--------------------+
    | t_mainloop         |
    +--------------------+
    | var_integer_md     |
    +--------------------+
    | var_numeric_md     |
    +--------------------+
    | var_string_md      |
    +--------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    knitro
    ------



    KNITRO interface

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | BarRule         | OT_INTEGER      | 0               | Barrier Rule    |
    +-----------------+-----------------+-----------------+-----------------+
    | Debug           | OT_INTEGER      | 0               | Debug level     |
    +-----------------+-----------------+-----------------+-----------------+
    | Delta           | OT_REAL         | 1               | Initial region  |
    |                 |                 |                 | scaling factor  |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasModeTol     | OT_REAL         | 0.000           | Feasible mode   |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasTol         | OT_REAL         | 0.000           | Feasible        |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasTolAbs      | OT_REAL         | 0               | Absolute        |
    |                 |                 |                 | feasible        |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | Feasible        | OT_BOOLEAN      | 1               | Allow           |
    |                 |                 |                 | infeasible      |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | GradOpt         | OT_INTEGER      | 1               | Gradient        |
    |                 |                 |                 | calculation     |
    |                 |                 |                 | method          |
    +-----------------+-----------------+-----------------+-----------------+
    | HessOpt         | OT_INTEGER      | 1               | Hessian         |
    |                 |                 |                 | calculation     |
    |                 |                 |                 | method          |
    +-----------------+-----------------+-----------------+-----------------+
    | HonorBnds       | OT_BOOLEAN      | 0               | Enforce bounds  |
    +-----------------+-----------------+-----------------+-----------------+
    | InitPt          | OT_BOOLEAN      | 0               | Use initial     |
    |                 |                 |                 | point strategy  |
    +-----------------+-----------------+-----------------+-----------------+
    | LmSize          | OT_INTEGER      | 10              | Memory pairsize |
    |                 |                 |                 | limit           |
    +-----------------+-----------------+-----------------+-----------------+
    | LpSolver        | OT_BOOLEAN      | 0               | Use LpSolver    |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxCgIt         | OT_INTEGER      | 0               | Maximum         |
    |                 |                 |                 | conjugate       |
    |                 |                 |                 | gradient        |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxIt           | OT_INTEGER      | 10000           | Iteration limit |
    +-----------------+-----------------+-----------------+-----------------+
    | Mu              | OT_REAL         | 0.100           | Initial barrier |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | Multistart      | OT_BOOLEAN      | 0               | Use multistart  |
    +-----------------+-----------------+-----------------+-----------------+
    | NewPoint        | OT_BOOLEAN      | 0               | Select new-     |
    |                 |                 |                 | point feature   |
    +-----------------+-----------------+-----------------+-----------------+
    | ObjRange        | OT_REAL         | 1.000e+20       | Maximum         |
    |                 |                 |                 | objective value |
    +-----------------+-----------------+-----------------+-----------------+
    | OptTol          | OT_REAL         | 0.000           | Relative        |
    |                 |                 |                 | optimality      |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | OptTolAbs       | OT_REAL         | 0               | Absolute        |
    |                 |                 |                 | optimality      |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | OutLev          | OT_INTEGER      | 2               | Log output      |
    |                 |                 |                 | level           |
    +-----------------+-----------------+-----------------+-----------------+
    | Pivot           | OT_REAL         | 0.000           | Initial pivot   |
    |                 |                 |                 | threshold       |
    +-----------------+-----------------+-----------------+-----------------+
    | Scale           | OT_BOOLEAN      | 1               | Perform scaling |
    +-----------------+-----------------+-----------------+-----------------+
    | ShiftInit       | OT_BOOLEAN      | 1               | Interior-point  |
    |                 |                 |                 | shifting        |
    |                 |                 |                 | initial point   |
    +-----------------+-----------------+-----------------+-----------------+
    | Soc             | OT_INTEGER      | 1               | Second order    |
    |                 |                 |                 | correction      |
    +-----------------+-----------------+-----------------+-----------------+
    | XTol            | OT_REAL         | 0.000           | Relative        |
    |                 |                 |                 | solution change |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | contype         | OT_INTEGERVECTO |                 |                 |
    |                 | R               |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+

    >List of available stats

    +---------------+
    |      Id       |
    +===============+
    | return_status |
    +---------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    snopt
    -----



    SNOPT interface

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | Backup basis    | OT_INTEGER      | None            | 0 * output      |
    | file            |                 |                 | extra basis map |
    +-----------------+-----------------+-----------------+-----------------+
    | Central         | OT_REAL         | None            | 6.7e-5 * (      |
    | difference      |                 |                 | Function        |
    | interval        |                 |                 | precision)^1/3  |
    +-----------------+-----------------+-----------------+-----------------+
    | Check frequency | OT_INTEGER      | None            | 60 * test row   |
    |                 |                 |                 | residuals kAx   |
    |                 |                 |                 | sk              |
    +-----------------+-----------------+-----------------+-----------------+
    | Crash option    | OT_INTEGER      | None            | 3 * first basis |
    |                 |                 |                 | is essentially  |
    |                 |                 |                 | triangular      |
    +-----------------+-----------------+-----------------+-----------------+
    | Crash tolerance | OT_REAL         | None            | 0.100           |
    +-----------------+-----------------+-----------------+-----------------+
    | Debug level     | OT_INTEGER      | None            | 0 * for         |
    |                 |                 |                 | developers      |
    +-----------------+-----------------+-----------------+-----------------+
    | Derivative      | OT_INTEGER      | None            | 3               |
    | level           |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Difference      | OT_REAL         | None            | 5.5e-7 * (      |
    | interval        |                 |                 | Function        |
    |                 |                 |                 | precision)^1/2  |
    +-----------------+-----------------+-----------------+-----------------+
    | Dump file       | OT_INTEGER      | None            | 0 * output Load |
    |                 |                 |                 | data            |
    +-----------------+-----------------+-----------------+-----------------+
    | Elastic weight  | OT_REAL         | None            | 1.0e+4 * used   |
    |                 |                 |                 | only during     |
    |                 |                 |                 | elastic mode    |
    +-----------------+-----------------+-----------------+-----------------+
    | Expand          | OT_INTEGER      | None            | 10000 * for     |
    | frequency       |                 |                 | anti-cycling    |
    |                 |                 |                 | procedure       |
    +-----------------+-----------------+-----------------+-----------------+
    | Factorization   | OT_INTEGER      | None            | 50 * 100 for    |
    | frequency       |                 |                 | LPs             |
    +-----------------+-----------------+-----------------+-----------------+
    | Function        | OT_REAL         | None            | 3.0e-13 * e^0.8 |
    | precision       |                 |                 | (almost full    |
    |                 |                 |                 | accuracy)       |
    +-----------------+-----------------+-----------------+-----------------+
    | Hessian         | OT_STRING       | None            | full memory *   |
    |                 |                 |                 | default if n1   |
    |                 |                 |                 | 75  limited     |
    |                 |                 |                 | memory *        |
    |                 |                 |                 | default if n1 > |
    |                 |                 |                 | 75              |
    +-----------------+-----------------+-----------------+-----------------+
    | Hessian flush   | OT_INTEGER      | None            | 999999 * no     |
    |                 |                 |                 | flushing        |
    +-----------------+-----------------+-----------------+-----------------+
    | Hessian         | OT_INTEGER      | None            | 999999 * for    |
    | frequency       |                 |                 | full Hessian    |
    |                 |                 |                 | (never reset)   |
    +-----------------+-----------------+-----------------+-----------------+
    | Hessian updates | OT_INTEGER      | None            | 10 * for        |
    |                 |                 |                 | limited memory  |
    |                 |                 |                 | Hessian         |
    +-----------------+-----------------+-----------------+-----------------+
    | Insert file     | OT_INTEGER      | None            | 0 * input in    |
    |                 |                 |                 | industry format |
    +-----------------+-----------------+-----------------+-----------------+
    | Iterations      | OT_INTEGER      | None            | 10000 * or 20m  |
    | limit           |                 |                 | if that is more |
    +-----------------+-----------------+-----------------+-----------------+
    | LU              | OT_STRING       | None            | LU partial      |
    |                 |                 |                 | pivoting *      |
    |                 |                 |                 | default         |
    |                 |                 |                 | threshold       |
    |                 |                 |                 | pivoting        |
    |                 |                 |                 | strategy  LU    |
    |                 |                 |                 | rook pivoting * |
    |                 |                 |                 | threshold rook  |
    |                 |                 |                 | pivoting  LU    |
    |                 |                 |                 | complete        |
    |                 |                 |                 | pivoting *      |
    |                 |                 |                 | threshold       |
    |                 |                 |                 | complete        |
    |                 |                 |                 | pivoting        |
    +-----------------+-----------------+-----------------+-----------------+
    | LU factor       | OT_REAL         | None            | 3.99 * for NP   |
    | tolerance       |                 |                 | (100.0 for LP)  |
    +-----------------+-----------------+-----------------+-----------------+
    | LU singularity  | OT_REAL         | None            | 0.000           |
    | tolerance       |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | LU update       | OT_REAL         | None            | 3.99 * for NP ( |
    | tolerance       |                 |                 | 10.0 for LP)    |
    +-----------------+-----------------+-----------------+-----------------+
    | Linesearch      | OT_REAL         | None            | 0.9 * smaller   |
    | tolerance       |                 |                 | for more        |
    |                 |                 |                 | accurate search |
    +-----------------+-----------------+-----------------+-----------------+
    | Load file       | OT_INTEGER      | None            | 0 * input names |
    |                 |                 |                 | and values      |
    +-----------------+-----------------+-----------------+-----------------+
    | Major           | OT_REAL         | None            | 1.0e-6 * target |
    | feasibility     |                 |                 | nonlinear       |
    | tolerance       |                 |                 | constraint      |
    |                 |                 |                 | violation       |
    +-----------------+-----------------+-----------------+-----------------+
    | Major           | OT_INTEGER      | None            | 1000 * or m if  |
    | iterations      |                 |                 | that is more    |
    | limit           |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Major           | OT_REAL         | None            | 1.0e-6 * target |
    | optimality      |                 |                 | complementarity |
    | tolerance       |                 |                 | gap             |
    +-----------------+-----------------+-----------------+-----------------+
    | Major print     | OT_INTEGER      | None            | 1 * 1-line      |
    | level           |                 |                 | major iteration |
    |                 |                 |                 | log             |
    +-----------------+-----------------+-----------------+-----------------+
    | Major step      | OT_REAL         | None            | 2               |
    | limit           |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Minor           | OT_REAL         | None            | 1.0e-6 * for    |
    | feasibility     |                 |                 | satisfying the  |
    | tolerance       |                 |                 | QP bounds       |
    +-----------------+-----------------+-----------------+-----------------+
    | Minor           | OT_INTEGER      | None            | 500 * or 3m if  |
    | iterations      |                 |                 | that is more    |
    | limit           |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Minor print     | OT_INTEGER      | None            | 1 * 1-line      |
    | level           |                 |                 | minor iteration |
    |                 |                 |                 | log             |
    +-----------------+-----------------+-----------------+-----------------+
    | New basis file  | OT_INTEGER      | None            | 0 * output      |
    |                 |                 |                 | basis map       |
    +-----------------+-----------------+-----------------+-----------------+
    | New superbasics | OT_INTEGER      | None            | 99 * controls   |
    | limit           |                 |                 | early           |
    |                 |                 |                 | termination of  |
    |                 |                 |                 | QPs             |
    +-----------------+-----------------+-----------------+-----------------+
    | Old basis file  | OT_INTEGER      | None            | 0 * input basis |
    |                 |                 |                 | map             |
    +-----------------+-----------------+-----------------+-----------------+
    | Partial price   | OT_INTEGER      | None            | 1 * 10 for      |
    |                 |                 |                 | large LPs       |
    +-----------------+-----------------+-----------------+-----------------+
    | Penalty         | OT_REAL         | None            | 0.0 * initial   |
    | parameter       |                 |                 | penalty         |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | Pivot tolerance | OT_REAL         | None            | 3.7e-11 * e^2/3 |
    +-----------------+-----------------+-----------------+-----------------+
    | Print frequency | OT_INTEGER      | None            | 100 * minor     |
    |                 |                 |                 | iterations log  |
    |                 |                 |                 | on Print file   |
    +-----------------+-----------------+-----------------+-----------------+
    | Proximal point  | OT_INTEGER      | None            | 1 * satisfies   |
    | method          |                 |                 | linear          |
    |                 |                 |                 | constraints     |
    |                 |                 |                 | near x0         |
    +-----------------+-----------------+-----------------+-----------------+
    | Punch file      | OT_INTEGER      | None            | 0 * output      |
    |                 |                 |                 | Insert data     |
    +-----------------+-----------------+-----------------+-----------------+
    | QPSolver        | OT_STRING       | None            | Cholesky *      |
    |                 |                 |                 | default         |
    +-----------------+-----------------+-----------------+-----------------+
    | Reduced Hessian | OT_INTEGER      | None            | 2000 * or       |
    | dimension       |                 |                 | Superbasics     |
    |                 |                 |                 | limit if that   |
    |                 |                 |                 | is less         |
    +-----------------+-----------------+-----------------+-----------------+
    | Save frequency  | OT_INTEGER      | None            | 100 * save      |
    |                 |                 |                 | basis map       |
    +-----------------+-----------------+-----------------+-----------------+
    | Scale option    | OT_INTEGER      | None            | 1 * linear      |
    |                 |                 |                 | constraints and |
    |                 |                 |                 | variables       |
    +-----------------+-----------------+-----------------+-----------------+
    | Scale tolerance | OT_REAL         | None            | 0.900           |
    +-----------------+-----------------+-----------------+-----------------+
    | Solution        | OT_STRING       | None            | Yes * on the    |
    |                 |                 |                 | Print file      |
    +-----------------+-----------------+-----------------+-----------------+
    | Solution file   | OT_INTEGER      | None            | 0 * different   |
    |                 |                 |                 | from printed    |
    |                 |                 |                 | solution        |
    +-----------------+-----------------+-----------------+-----------------+
    | Sticky          | OT_STRING       | None            | No * Yes makes  |
    | parameters      |                 |                 | parameter       |
    |                 |                 |                 | values persist  |
    +-----------------+-----------------+-----------------+-----------------+
    | Summary         | OT_INTEGER      | None            | 100 * minor     |
    | frequency       |                 |                 | iterations log  |
    |                 |                 |                 | on Summary file |
    +-----------------+-----------------+-----------------+-----------------+
    | Superbasics     | OT_INTEGER      | None            | n1 + 1 * n1 =   |
    | limit           |                 |                 | number of       |
    |                 |                 |                 | nonlinear       |
    |                 |                 |                 | variables       |
    +-----------------+-----------------+-----------------+-----------------+
    | System          | OT_STRING       | None            | No * Yes prints |
    | information     |                 |                 | more system     |
    |                 |                 |                 | information     |
    +-----------------+-----------------+-----------------+-----------------+
    | Timing level    | OT_INTEGER      | None            | 3 * print cpu   |
    |                 |                 |                 | times           |
    +-----------------+-----------------+-----------------+-----------------+
    | Unbounded       | OT_REAL         | None            | 1.000e+15       |
    | objective       |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Unbounded step  | OT_REAL         | None            | 1.000e+18       |
    | size            |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | Verify level    | OT_INTEGER      | None            | 0 * cheap check |
    |                 |                 |                 | on gradients    |
    +-----------------+-----------------+-----------------+-----------------+
    | Violation limit | OT_REAL         | None            | 10.0 * unscaled |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation limit |
    +-----------------+-----------------+-----------------+-----------------+
    | detect_linear   | OT_BOOLEAN      | True            | Make an effort  |
    |                 |                 |                 | to treat linear |
    |                 |                 |                 | constraints and |
    |                 |                 |                 | linear          |
    |                 |                 |                 | variables       |
    |                 |                 |                 | specially.      |
    +-----------------+-----------------+-----------------+-----------------+
    | print file      | OT_STRING       | None            | n/a             |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOLEAN      | True            | print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about execution |
    |                 |                 |                 | time            |
    +-----------------+-----------------+-----------------+-----------------+
    | specs file      | OT_STRING       | None            | n/a             |
    +-----------------+-----------------+-----------------+-----------------+
    | start           | OT_STRING       | Cold            |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | summary         | OT_BOOLEAN      | True            | n/a             |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-----------+
    |    Id     |
    +===========+
    | eval_nlp  |
    +-----------+
    | setup_nlp |
    +-----------+

    >List of available stats

    +----------------+
    |       Id       |
    +================+
    | iter_count     |
    +----------------+
    | iterations     |
    +----------------+
    | n_callback_fun |
    +----------------+
    | n_eval_grad_f  |
    +----------------+
    | n_eval_jac_g   |
    +----------------+
    | return_status  |
    +----------------+
    | t_callback_fun |
    +----------------+
    | t_eval_grad_f  |
    +----------------+
    | t_eval_jac_g   |
    +----------------+
    | t_mainloop     |
    +----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    worhp
    -----



    WORHP interface

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | AcceptTolFeas   | OT_REAL         | 0.001           | Tolerance for   |
    |                 |                 |                 | acceptable      |
    |                 |                 |                 | feasibility     |
    +-----------------+-----------------+-----------------+-----------------+
    | AcceptTolOpti   | OT_REAL         | 0.001           | Tolerance for   |
    |                 |                 |                 | acceptable      |
    |                 |                 |                 | optimality      |
    +-----------------+-----------------+-----------------+-----------------+
    | AlphaMinConst   | OT_BOOLEAN      | False           | Use a constant  |
    |                 |                 |                 | lower bound on  |
    |                 |                 |                 | Armijo stepsize |
    |                 |                 |                 | in Filter       |
    +-----------------+-----------------+-----------------+-----------------+
    | Ares            | OT_INTEGERVECTO | [42, 41, 42,    | Armijo recovery |
    |                 | R               | 43, 44, 41, 50] | strategies.     |
    |                 |                 |                 | Vector of size  |
    |                 |                 |                 | 7               |
    +-----------------+-----------------+-----------------+-----------------+
    | ArmijoBeta      | OT_REAL         | 0.712           | Trial stepsize  |
    |                 |                 |                 | decrease factor |
    |                 |                 |                 | for Armijo rule |
    +-----------------+-----------------+-----------------+-----------------+
    | ArmijoMaxAlpha  | OT_REAL         | 1               | Initial alpha   |
    |                 |                 |                 | for Armijo rule |
    +-----------------+-----------------+-----------------+-----------------+
    | ArmijoMinAlpha  | OT_REAL         | 0.000           | Lower bound on  |
    |                 |                 |                 | alpha for       |
    |                 |                 |                 | Armijo rule     |
    +-----------------+-----------------+-----------------+-----------------+
    | ArmijoMinAlphaR | OT_REAL         | 0.000           | Lower bound on  |
    | ec              |                 |                 | alpha for       |
    |                 |                 |                 | Armijo rule     |
    |                 |                 |                 | during recovery |
    +-----------------+-----------------+-----------------+-----------------+
    | ArmijoSigma     | OT_REAL         | 0.005           | Scale factor    |
    |                 |                 |                 | for linearised  |
    |                 |                 |                 | descent check   |
    |                 |                 |                 | in Armijo rule  |
    +-----------------+-----------------+-----------------+-----------------+
    | AutoQPRecovery  | OT_BOOLEAN      | True            | Enable          |
    |                 |                 |                 | automatic QP    |
    |                 |                 |                 | recovery        |
    +-----------------+-----------------+-----------------+-----------------+
    | BFGSmaxblockSiz | OT_INTEGER      | 300             | Block size      |
    | e               |                 |                 | parameter used  |
    |                 |                 |                 | by certain BFGS |
    |                 |                 |                 | methods         |
    +-----------------+-----------------+-----------------+-----------------+
    | BFGSmethod      | OT_INTEGER      | 0               | Choose BFGS     |
    |                 |                 |                 | method (0:      |
    |                 |                 |                 | dense, 1-3:     |
    |                 |                 |                 | block, 100+:    |
    |                 |                 |                 | sparse)         |
    +-----------------+-----------------+-----------------+-----------------+
    | BFGSminblockSiz | OT_INTEGER      | 300             | Block size      |
    | e               |                 |                 | parameter used  |
    |                 |                 |                 | by certain BFGS |
    |                 |                 |                 | methods         |
    +-----------------+-----------------+-----------------+-----------------+
    | BFGSrestart     | OT_INTEGER      | 50              | Restart BFGS    |
    |                 |                 |                 | update after    |
    |                 |                 |                 | this many       |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | BettsFactor     | OT_REAL         | 2.100           | Update factor   |
    |                 |                 |                 | for Betts'      |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | regularisation  |
    +-----------------+-----------------+-----------------+-----------------+
    | BettsPoint      | OT_REAL         | 1               | Smallest        |
    |                 |                 |                 | eigenvalue of   |
    |                 |                 |                 | the regularised |
    |                 |                 |                 | Hessian         |
    +-----------------+-----------------+-----------------+-----------------+
    | BoundTolFac     | OT_REAL         | 1000            | Factor in       |
    |                 |                 |                 | determining     |
    |                 |                 |                 | active          |
    |                 |                 |                 | constraints by  |
    |                 |                 |                 | KKT             |
    +-----------------+-----------------+-----------------+-----------------+
    | CheckFJ         | OT_REAL         | 1.000e+12       | Upper bound     |
    |                 |                 |                 | used by Fritz-  |
    |                 |                 |                 | John heuristic  |
    +-----------------+-----------------+-----------------+-----------------+
    | CheckStructureD | OT_BOOLEAN      | True            | Enable          |
    | F               |                 |                 | structural      |
    |                 |                 |                 | checking of DF  |
    +-----------------+-----------------+-----------------+-----------------+
    | CheckStructureD | OT_BOOLEAN      | True            | Enable          |
    | G               |                 |                 | structural      |
    |                 |                 |                 | checking of DG  |
    +-----------------+-----------------+-----------------+-----------------+
    | CheckStructureH | OT_BOOLEAN      | True            | Enable          |
    | M               |                 |                 | structural      |
    |                 |                 |                 | checking of HM  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepBettsSum | OT_REAL         | 0.500           | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepConStop  | OT_REAL         | 0.000           | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepConvio   | OT_REAL         | 1               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepMaxIter  | OT_INTEGER      | 50              | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepMethod   | OT_INTEGER      | 0               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepMode     | OT_INTEGER      | 1               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepPFactor  | OT_REAL         | 1               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepPMax     | OT_REAL         | 1000000         | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | CorStepRecovery | OT_BOOLEAN      | False           | (experimental)  |
    | DX              |                 |                 |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | CurvBCond       | OT_REAL         | 0.020           | Block BFGS      |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | condition bound |
    +-----------------+-----------------+-----------------+-----------------+
    | CurvBFac        | OT_REAL         | 0.300           | Block BFGS      |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | condition       |
    |                 |                 |                 | regularisation  |
    |                 |                 |                 | factor          |
    +-----------------+-----------------+-----------------+-----------------+
    | CurvCond        | OT_REAL         | 0.020           | BFGS Curvature  |
    |                 |                 |                 | condition bound |
    +-----------------+-----------------+-----------------+-----------------+
    | CurvFac         | OT_REAL         | 0.300           | BFGS curvature  |
    |                 |                 |                 | condition       |
    |                 |                 |                 | regularisation  |
    |                 |                 |                 | factor          |
    +-----------------+-----------------+-----------------+-----------------+
    | DebugMarker05   | OT_INTEGER      | 42              | Debug marker.   |
    |                 |                 |                 | Used to find    |
    |                 |                 |                 | memory alignmen |
    |                 |                 |                 | t/padding       |
    |                 |                 |                 | issues          |
    +-----------------+-----------------+-----------------+-----------------+
    | DebugMarker06   | OT_INTEGER      | 42              | Debug marker.   |
    |                 |                 |                 | Used to find    |
    |                 |                 |                 | memory alignmen |
    |                 |                 |                 | t/padding       |
    |                 |                 |                 | issues          |
    +-----------------+-----------------+-----------------+-----------------+
    | FGtogether      | OT_BOOLEAN      | False           | F and G cannot  |
    |                 |                 |                 | be evaluated    |
    |                 |                 |                 | separately      |
    +-----------------+-----------------+-----------------+-----------------+
    | FJandND         | OT_BOOLEAN      | False           | Enable Fritz-   |
    |                 |                 |                 | John and non-   |
    |                 |                 |                 | differentiable  |
    |                 |                 |                 | check           |
    |                 |                 |                 | heuristics      |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasibleDual    | OT_BOOLEAN      | False           | Activate dual   |
    |                 |                 |                 | feasibility     |
    |                 |                 |                 | mode            |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasibleInit    | OT_BOOLEAN      | False           | Activate        |
    |                 |                 |                 | initial         |
    |                 |                 |                 | feasibility     |
    |                 |                 |                 | mode            |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasibleInitTol | OT_REAL         | 0.001           | Feasibility     |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | no-objective    |
    |                 |                 |                 | feasible mode   |
    +-----------------+-----------------+-----------------+-----------------+
    | FeasibleOnly    | OT_BOOLEAN      | False           | Activate        |
    |                 |                 |                 | feasible-only   |
    |                 |                 |                 | mode            |
    +-----------------+-----------------+-----------------+-----------------+
    | FidifEps        | OT_REAL         | 0.000           | Finite          |
    |                 |                 |                 | difference      |
    |                 |                 |                 | perturbation    |
    +-----------------+-----------------+-----------------+-----------------+
    | FidifHM         | OT_BOOLEAN      | False           | Approximate     |
    |                 |                 |                 | Hessian by      |
    |                 |                 |                 | finite          |
    |                 |                 |                 | differences     |
    |                 |                 |                 | (otherwise      |
    |                 |                 |                 | BFGS)           |
    +-----------------+-----------------+-----------------+-----------------+
    | FilterBisecAlph | OT_BOOLEAN      | True            | Filter          |
    | a               |                 |                 | heuristic to    |
    |                 |                 |                 | save Armijo     |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | FilterGammaCV   | OT_REAL         | 0.000           | Constraint      |
    |                 |                 |                 | violation       |
    |                 |                 |                 | decrease factor |
    |                 |                 |                 | in Filter       |
    |                 |                 |                 | acceptance      |
    |                 |                 |                 | check           |
    +-----------------+-----------------+-----------------+-----------------+
    | FilterGammaF    | OT_REAL         | 0.000           | Objective       |
    |                 |                 |                 | decrease factor |
    |                 |                 |                 | in Filter       |
    |                 |                 |                 | acceptance      |
    |                 |                 |                 | check           |
    +-----------------+-----------------+-----------------+-----------------+
    | FilterIntersecA | OT_BOOLEAN      | True            | Filter          |
    | lpha            |                 |                 | heuristic to    |
    |                 |                 |                 | save Armijo     |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | FirstDifCentral | OT_BOOLEAN      | True            | Use central     |
    |                 |                 |                 | finite          |
    |                 |                 |                 | difference      |
    |                 |                 |                 | quotient for    |
    |                 |                 |                 | first           |
    |                 |                 |                 | derivatives     |
    +-----------------+-----------------+-----------------+-----------------+
    | FocusOnFeas     | OT_BOOLEAN      | True            | Enable Focus-   |
    |                 |                 |                 | on-Feasibility  |
    |                 |                 |                 | mode            |
    +-----------------+-----------------+-----------------+-----------------+
    | FocusOnFeasFact | OT_REAL         | 1.360           | Factor in       |
    | or              |                 |                 | Focus-on-       |
    |                 |                 |                 | Feasibility     |
    |                 |                 |                 | mode            |
    +-----------------+-----------------+-----------------+-----------------+
    | GammaAlpha      | OT_REAL         | 0.050           | Safety factor   |
    |                 |                 |                 | for alphamin    |
    |                 |                 |                 | calculation by  |
    |                 |                 |                 | Filter          |
    +-----------------+-----------------+-----------------+-----------------+
    | GroupMethod     | OT_INTEGER      | 1               | Select method   |
    |                 |                 |                 | to determine    |
    |                 |                 |                 | graph colouring |
    |                 |                 |                 | groups          |
    +-----------------+-----------------+-----------------+-----------------+
    | IgnoreFilterCri | OT_BOOLEAN      | False           | Activate        |
    | t               |                 |                 | accelerating    |
    |                 |                 |                 | heuristics for  |
    |                 |                 |                 | Filter          |
    +-----------------+-----------------+-----------------+-----------------+
    | IncBettsTau     | OT_REAL         | 2               | Increase factor |
    |                 |                 |                 | for Betts'      |
    |                 |                 |                 | update          |
    |                 |                 |                 | dampening term  |
    +-----------------+-----------------+-----------------+-----------------+
    | IncBettsTauMore | OT_REAL         | 100             | Larger increase |
    |                 |                 |                 | factor for      |
    |                 |                 |                 | Betts' update   |
    |                 |                 |                 | dampening term  |
    +-----------------+-----------------+-----------------+-----------------+
    | IncreaseIWS     | OT_REAL         | 1               | Increase factor |
    |                 |                 |                 | for estimated   |
    |                 |                 |                 | integer         |
    |                 |                 |                 | workspace       |
    |                 |                 |                 | requirement     |
    +-----------------+-----------------+-----------------+-----------------+
    | IncreaseRWS     | OT_REAL         | 1               | Increase factor |
    |                 |                 |                 | for estimated   |
    |                 |                 |                 | real workspace  |
    |                 |                 |                 | requirement     |
    +-----------------+-----------------+-----------------+-----------------+
    | Infty           | OT_REAL         | 1.000e+20       | Upper bound for |
    |                 |                 |                 | numbers to be   |
    |                 |                 |                 | regarded as     |
    |                 |                 |                 | finite          |
    +-----------------+-----------------+-----------------+-----------------+
    | InftyUnbounded  | OT_REAL         | 1.000e+20       | Tolerance for   |
    |                 |                 |                 | unboundedness   |
    |                 |                 |                 | detection       |
    |                 |                 |                 | heuristic       |
    +-----------------+-----------------+-----------------+-----------------+
    | InitialLMest    | OT_BOOLEAN      | True            | Enable initial  |
    |                 |                 |                 | Lagrange        |
    |                 |                 |                 | multiplier      |
    |                 |                 |                 | estimate        |
    +-----------------+-----------------+-----------------+-----------------+
    | KeepAcceptableS | OT_BOOLEAN      | True            | Save acceptable |
    | ol              |                 |                 | solutions as    |
    |                 |                 |                 | fallback        |
    +-----------------+-----------------+-----------------+-----------------+
    | LMestQPipComTol | OT_REAL         | 0.003           | IP              |
    |                 |                 |                 | complementarity |
    |                 |                 |                 | tolerance in    |
    |                 |                 |                 | initial         |
    |                 |                 |                 | multiplier      |
    |                 |                 |                 | estimate        |
    +-----------------+-----------------+-----------------+-----------------+
    | LMestQPipResTol | OT_REAL         | 1               | IP residual     |
    |                 |                 |                 | tolerance in    |
    |                 |                 |                 | initial         |
    |                 |                 |                 | multiplier      |
    |                 |                 |                 | estimate        |
    +-----------------+-----------------+-----------------+-----------------+
    | LinMult         | OT_BOOLEAN      | False           | Control         |
    |                 |                 |                 | Lagrange        |
    |                 |                 |                 | multiplier      |
    |                 |                 |                 | update          |
    +-----------------+-----------------+-----------------+-----------------+
    | LogLevel        | OT_INTEGER      | 0               | Enable XML      |
    |                 |                 |                 | logfiles and    |
    |                 |                 |                 | writing         |
    |                 |                 |                 | interval        |
    +-----------------+-----------------+-----------------+-----------------+
    | LogResult       | OT_INTEGER      | 0               | Enable XML      |
    |                 |                 |                 | result logging  |
    |                 |                 |                 | and detail      |
    |                 |                 |                 | level           |
    +-----------------+-----------------+-----------------+-----------------+
    | LowPassAlphaF   | OT_REAL         | 0.950           | Lowpass-filter  |
    |                 |                 |                 | update factor   |
    |                 |                 |                 | for objective   |
    |                 |                 |                 | values          |
    +-----------------+-----------------+-----------------+-----------------+
    | LowPassAlphaG   | OT_REAL         | 0.950           | Lowpass-filter  |
    |                 |                 |                 | update factor   |
    |                 |                 |                 | for constraint  |
    |                 |                 |                 | values          |
    +-----------------+-----------------+-----------------+-----------------+
    | LowPassAlphaMer | OT_REAL         | 0.100           | Lowpass-filter  |
    | it              |                 |                 | update factor   |
    |                 |                 |                 | for merit       |
    |                 |                 |                 | function values |
    +-----------------+-----------------+-----------------+-----------------+
    | LowPassFilter   | OT_BOOLEAN      | True            | Enable lowpass- |
    |                 |                 |                 | filter          |
    |                 |                 |                 | termination     |
    |                 |                 |                 | criterion       |
    +-----------------+-----------------+-----------------+-----------------+
    | MAPivotThreshol | OT_REAL         | 0.000           | Pivoting        |
    | d               |                 |                 | tolerance for   |
    |                 |                 |                 | MA solvers      |
    +-----------------+-----------------+-----------------+-----------------+
    | MatrixCC        | OT_BOOLEAN      | False           | Not to be       |
    |                 |                 |                 | included into a |
    |                 |                 |                 | parameter file! |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxCalls        | OT_INTEGER      | 2.147e+09       | Upper bound to  |
    |                 |                 |                 | Reverse         |
    |                 |                 |                 | Communication   |
    |                 |                 |                 | calls           |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxForce        | OT_INTEGER      | 1000            | Maximum number  |
    |                 |                 |                 | of Force        |
    |                 |                 |                 | recovery        |
    |                 |                 |                 | strategy steps  |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxGPart        | OT_INTEGER      | 1               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxIter         | OT_INTEGER      | 500             | Upper bound on  |
    |                 |                 |                 | major           |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxLScounter    | OT_INTEGER      | 3               | Control         |
    |                 |                 |                 | activation of   |
    |                 |                 |                 | Filter          |
    |                 |                 |                 | acceleration    |
    |                 |                 |                 | heuristics      |
    +-----------------+-----------------+-----------------+-----------------+
    | MaxNorm         | OT_BOOLEAN      | True            | Select max-norm |
    |                 |                 |                 | instead of      |
    |                 |                 |                 | 1-norm in       |
    |                 |                 |                 | Filter          |
    +-----------------+-----------------+-----------------+-----------------+
    | MeritFunction   | OT_INTEGER      | 4               | Select merit    |
    |                 |                 |                 | function and    |
    |                 |                 |                 | penalty update  |
    |                 |                 |                 | [0, 3..5]       |
    +-----------------+-----------------+-----------------+-----------------+
    | MeritGradTol    | OT_REAL         | 0.000           | Threshold of    |
    |                 |                 |                 | meritfunction   |
    |                 |                 |                 | gradient for    |
    |                 |                 |                 | increasing      |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | regularisation  |
    +-----------------+-----------------+-----------------+-----------------+
    | MinBettsTau     | OT_REAL         | 0.000           | Lower bound for |
    |                 |                 |                 | Betts' update   |
    |                 |                 |                 | dampening term  |
    +-----------------+-----------------+-----------------+-----------------+
    | MoreRelax       | OT_BOOLEAN      | False           | Introduce one   |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | variable for    |
    |                 |                 |                 | every           |
    |                 |                 |                 | constraint      |
    +-----------------+-----------------+-----------------+-----------------+
    | NLPmethod       | OT_INTEGER      | 1               | Select (1)      |
    |                 |                 |                 | Meritfunction   |
    |                 |                 |                 | or (3) Filter   |
    |                 |                 |                 | globalisation   |
    +-----------------+-----------------+-----------------+-----------------+
    | NLPprint        | OT_INTEGER      | 2               | NLP print level |
    |                 |                 |                 | [-1..4]         |
    +-----------------+-----------------+-----------------+-----------------+
    | PairMethod      | OT_INTEGER      | 1               | Select method   |
    |                 |                 |                 | to determine    |
    |                 |                 |                 | graph colouring |
    |                 |                 |                 | pairgroups      |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdEpsBar    | OT_REAL         | 0.900           | Penalty update  |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | factor for      |
    |                 |                 |                 | MeritFunction = |
    |                 |                 |                 | 3               |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdEpsKFac   | OT_REAL         | 2               | Penalty update  |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | factor for      |
    |                 |                 |                 | MeritFunction = |
    |                 |                 |                 | 4               |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdEpsKSeque | OT_INTEGER      | 2               | Penalty update  |
    | nce             |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdMaxDeltaK | OT_REAL         | 11              | Max penalty for |
    |                 |                 |                 | MeritFunction = |
    |                 |                 |                 | 4               |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdMaxFac    | OT_REAL         | 100000000       | Max factor for  |
    |                 |                 |                 | increasing      |
    |                 |                 |                 | penalty for     |
    |                 |                 |                 | MeritFunction = |
    |                 |                 |                 | 4               |
    +-----------------+-----------------+-----------------+-----------------+
    | PenUpdRBar      | OT_REAL         | 2               | Penalty update  |
    |                 |                 |                 | parameter for   |
    |                 |                 |                 | MeritFunction = |
    |                 |                 |                 | 3               |
    +-----------------+-----------------+-----------------+-----------------+
    | PrecisionF      | OT_REAL         | 0.000           | (currently      |
    |                 |                 |                 | unused)         |
    |                 |                 |                 | Relative        |
    |                 |                 |                 | precision of    |
    |                 |                 |                 | objective       |
    +-----------------+-----------------+-----------------+-----------------+
    | PrecisionG      | OT_REAL         | 0.000           | (currently      |
    |                 |                 |                 | unused)         |
    |                 |                 |                 | Relative        |
    |                 |                 |                 | precision of    |
    |                 |                 |                 | constraints     |
    +-----------------+-----------------+-----------------+-----------------+
    | QPscaleParam    | OT_REAL         | 0               | (currently      |
    |                 |                 |                 | unused) Scaling |
    |                 |                 |                 | factor for QP   |
    +-----------------+-----------------+-----------------+-----------------+
    | QuadraticProble | OT_BOOLEAN      | False           | Not to be       |
    | m               |                 |                 | included into a |
    |                 |                 |                 | parameter file! |
    +-----------------+-----------------+-----------------+-----------------+
    | ReduceBettsTau  | OT_REAL         | 0.300           | Decrease factor |
    |                 |                 |                 | for Betts'      |
    |                 |                 |                 | update          |
    |                 |                 |                 | dampening term  |
    +-----------------+-----------------+-----------------+-----------------+
    | RegStrategy     | OT_INTEGER      | 1               | Select Hessian  |
    |                 |                 |                 | regularisation  |
    |                 |                 |                 | strategy in     |
    |                 |                 |                 | Filter          |
    +-----------------+-----------------+-----------------+-----------------+
    | ReinitFilter    | OT_BOOLEAN      | False           | Enables Filter- |
    |                 |                 |                 | reinitialisatio |
    |                 |                 |                 | n accelerating  |
    |                 |                 |                 | heuristic       |
    +-----------------+-----------------+-----------------+-----------------+
    | RelaxMaxDelta   | OT_REAL         | 0.920           | Upper bound for |
    |                 |                 |                 | accepting the   |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | variable        |
    +-----------------+-----------------+-----------------+-----------------+
    | RelaxMaxPen     | OT_REAL         | 50000000        | Upper bound on  |
    |                 |                 |                 | the constraint  |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | penalty         |
    +-----------------+-----------------+-----------------+-----------------+
    | RelaxRho        | OT_REAL         | 6               | Update factor   |
    |                 |                 |                 | for the         |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | penalty         |
    +-----------------+-----------------+-----------------+-----------------+
    | RelaxStart      | OT_REAL         | 1               | Initial value   |
    |                 |                 |                 | of the          |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | penalty         |
    +-----------------+-----------------+-----------------+-----------------+
    | RestUntilFeas   | OT_BOOLEAN      | False           | Do restoration  |
    |                 |                 |                 | until a         |
    |                 |                 |                 | feasible        |
    |                 |                 |                 | solution is     |
    |                 |                 |                 | found           |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaleConIter    | OT_BOOLEAN      | False           | Scale           |
    |                 |                 |                 | constraints in  |
    |                 |                 |                 | every iteration |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaleFacObj     | OT_REAL         | 10              | Value to scale  |
    |                 |                 |                 | large objective |
    |                 |                 |                 | functions to    |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaleFacQP      | OT_REAL         | 10              | Upper bound on  |
    |                 |                 |                 | resulting       |
    |                 |                 |                 | matrix norm for |
    |                 |                 |                 | QP scaling      |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaledFD        | OT_BOOLEAN      | True            | Use a scaled    |
    |                 |                 |                 | perturbation    |
    |                 |                 |                 | for finite      |
    |                 |                 |                 | differences     |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaledKKT       | OT_BOOLEAN      | True            | Scale KKT       |
    |                 |                 |                 | conditions      |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaledObj       | OT_BOOLEAN      | True            | Scale the       |
    |                 |                 |                 | objective       |
    |                 |                 |                 | function        |
    +-----------------+-----------------+-----------------+-----------------+
    | ScaledQP        | OT_BOOLEAN      | True            | Scale some      |
    |                 |                 |                 | matrices handed |
    |                 |                 |                 | to the QP       |
    +-----------------+-----------------+-----------------+-----------------+
    | StartBettsTau   | OT_REAL         | 0.100           | Initial value   |
    |                 |                 |                 | for Betts'      |
    |                 |                 |                 | update          |
    |                 |                 |                 | dampening term  |
    +-----------------+-----------------+-----------------+-----------------+
    | SwitchingDelta  | OT_REAL         | 0.010           | Filter          |
    |                 |                 |                 | switching       |
    |                 |                 |                 | condition       |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | SwitchingSCV    | OT_REAL         | 1.100           | Filter          |
    |                 |                 |                 | switching       |
    |                 |                 |                 | condition       |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | SwitchingSF     | OT_REAL         | 2.300           | Filter          |
    |                 |                 |                 | switching       |
    |                 |                 |                 | condition       |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | TakeQPSol       | OT_BOOLEAN      | False           | Evaluate QP     |
    |                 |                 |                 | search          |
    |                 |                 |                 | direction       |
    |                 |                 |                 | regardless of   |
    |                 |                 |                 | convergence     |
    +-----------------+-----------------+-----------------+-----------------+
    | Timeout         | OT_REAL         | 300             | Timeout in      |
    |                 |                 |                 | seconds         |
    +-----------------+-----------------+-----------------+-----------------+
    | TolComp         | OT_REAL         | 0.001           | Complementarity |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | TolFeas         | OT_REAL         | 0.000           | Feasibility     |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | TolOpti         | OT_REAL         | 0.000           | Optimality      |
    |                 |                 |                 | tolerance       |
    +-----------------+-----------------+-----------------+-----------------+
    | TolWeakActive   | OT_REAL         | 1               | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | TooBig          | OT_BOOLEAN      | True            | Enable too-big  |
    |                 |                 |                 | termination     |
    |                 |                 |                 | heuristics      |
    +-----------------+-----------------+-----------------+-----------------+
    | TooBigCV        | OT_REAL         | 1.000e+25       | Upper bound on  |
    |                 |                 |                 | constraint      |
    |                 |                 |                 | violation for   |
    |                 |                 |                 | too-big         |
    |                 |                 |                 | heuristic       |
    +-----------------+-----------------+-----------------+-----------------+
    | TooBigKKT       | OT_REAL         | 1.000e+30       | Upper bound on  |
    |                 |                 |                 | KKT values for  |
    |                 |                 |                 | too-big         |
    |                 |                 |                 | heuristic       |
    +-----------------+-----------------+-----------------+-----------------+
    | UserDF          | OT_BOOLEAN      | True            | Objective       |
    |                 |                 |                 | gradient values |
    |                 |                 |                 | supplied by     |
    |                 |                 |                 | caller          |
    +-----------------+-----------------+-----------------+-----------------+
    | UserDG          | OT_BOOLEAN      | True            | Jacobian values |
    |                 |                 |                 | supplied by     |
    |                 |                 |                 | caller          |
    +-----------------+-----------------+-----------------+-----------------+
    | UserHM          | OT_BOOLEAN      | True            | Hessian values  |
    |                 |                 |                 | supplied by     |
    |                 |                 |                 | caller          |
    +-----------------+-----------------+-----------------+-----------------+
    | UserHMstructure | OT_INTEGER      | 2               | Enable          |
    |                 |                 |                 | automatic       |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | structure       |
    |                 |                 |                 | generation or   |
    |                 |                 |                 | checking        |
    +-----------------+-----------------+-----------------+-----------------+
    | WeakActiveSet   | OT_BOOLEAN      | False           | (experimental)  |
    +-----------------+-----------------+-----------------+-----------------+
    | eps             | OT_REAL         | 0.000           | Machine epsilon |
    +-----------------+-----------------+-----------------+-----------------+
    | internalParChan | OT_INTEGER      | 0               | Counter for     |
    | ged             |                 |                 | changed         |
    |                 |                 |                 | parameters.     |
    |                 |                 |                 | Internal use    |
    |                 |                 |                 | only.           |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOLEAN      | True            | Print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about execution |
    |                 |                 |                 | time            |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipBarrier    | OT_REAL         | 7.800           | IP barrier      |
    |                 |                 |                 | parameter.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipComTol     | OT_REAL         | 0.000           | IP              |
    |                 |                 |                 | complementarity |
    |                 |                 |                 | tolerance.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipFracBound  | OT_REAL         | 0.880           | IP fraction-to- |
    |                 |                 |                 | the-boundary    |
    |                 |                 |                 | parameter.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipLsMethod   | OT_STRING       | None            | Select the      |
    |                 |                 |                 | direct linear   |
    |                 |                 |                 | solver used by  |
    |                 |                 |                 | the IP method.  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipMinAlpha   | OT_REAL         | 0.000           | IP line search  |
    |                 |                 |                 | minimum step    |
    |                 |                 |                 | size.           |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipRelaxDiv   | OT_REAL         | 2               | The relaxation  |
    |                 |                 |                 | term is divided |
    |                 |                 |                 | by this value   |
    |                 |                 |                 | if successful.  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipRelaxMax   | OT_REAL         | 0.000           | Maximum         |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | value.          |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipRelaxMin   | OT_REAL         | 0.000           | Mimimum         |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | value.          |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipRelaxMult  | OT_REAL         | 10              | The relaxation  |
    |                 |                 |                 | term is         |
    |                 |                 |                 | multiplied by   |
    |                 |                 |                 | this value if   |
    |                 |                 |                 | unsuccessful.   |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipResTol     | OT_REAL         | 0.000           | IP residuals    |
    |                 |                 |                 | tolerance.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_ipTryRelax   | OT_BOOLEAN      | True            | Enable          |
    |                 |                 |                 | relaxation      |
    |                 |                 |                 | strategy when   |
    |                 |                 |                 | encountering an |
    |                 |                 |                 | error.          |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsItMaxIter  | OT_INTEGER      | 1000            | Maximum number  |
    |                 |                 |                 | of iterations   |
    |                 |                 |                 | of the          |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | linear solvers. |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsItMethod   | OT_STRING       | None            | Select the      |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsItPrecondM | OT_STRING       | None            | Select          |
    | ethod           |                 |                 | preconditioner  |
    |                 |                 |                 | for the         |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsRefineMaxI | OT_INTEGER      | 10              | Maximum number  |
    | ter             |                 |                 | of iterative    |
    |                 |                 |                 | refinement      |
    |                 |                 |                 | steps of the    |
    |                 |                 |                 | direct linear   |
    |                 |                 |                 | solvers.        |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsScale      | OT_BOOLEAN      | True            | Enables scaling |
    |                 |                 |                 | on linear       |
    |                 |                 |                 | solver level.   |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsTol        | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | the linear      |
    |                 |                 |                 | solver.         |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_lsTrySimple  | OT_BOOLEAN      | False           | Some matrices   |
    |                 |                 |                 | can be solved   |
    |                 |                 |                 | without calling |
    |                 |                 |                 | a linear        |
    |                 |                 |                 | equation solver |
    |                 |                 |                 | .Currently only |
    |                 |                 |                 | diagonal        |
    |                 |                 |                 | matrices are    |
    |                 |                 |                 | supported.Non-  |
    |                 |                 |                 | diagonal        |
    |                 |                 |                 | matrices will   |
    |                 |                 |                 | besolved with   |
    |                 |                 |                 | the chosen      |
    |                 |                 |                 | linear equation |
    |                 |                 |                 | solver.         |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_maxIter      | OT_INTEGER      | 80              | Imposes an      |
    |                 |                 |                 | upper limit on  |
    |                 |                 |                 | the number of   |
    |                 |                 |                 | minor solver    |
    |                 |                 |                 | iterations,     |
    |                 |                 |                 | i.e. for the    |
    |                 |                 |                 | quadratic       |
    |                 |                 |                 | subproblem      |
    |                 |                 |                 | solver.If the   |
    |                 |                 |                 | limit is        |
    |                 |                 |                 | reached before  |
    |                 |                 |                 | convergence,    |
    |                 |                 |                 | WORHP will      |
    |                 |                 |                 | activate QP     |
    |                 |                 |                 | recovery        |
    |                 |                 |                 | strategies to   |
    |                 |                 |                 | prevent a       |
    |                 |                 |                 | solver          |
    |                 |                 |                 | breakdown.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_method       | OT_STRING       | None            | Select the      |
    |                 |                 |                 | solution method |
    |                 |                 |                 | used by the QP  |
    |                 |                 |                 | solver.         |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnBeta      | OT_REAL         | 0.900           | NSN stepsize    |
    |                 |                 |                 | decrease        |
    |                 |                 |                 | factor.         |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnGradStep  | OT_BOOLEAN      | True            | Enable gradient |
    |                 |                 |                 | steps in the    |
    |                 |                 |                 | NSN method.     |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnKKT       | OT_REAL         | 0.000           | NSN KKT         |
    |                 |                 |                 | tolerance.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnLsMethod  | OT_STRING       | None            | Select the      |
    |                 |                 |                 | direct linear   |
    |                 |                 |                 | solver used by  |
    |                 |                 |                 | the NSN method. |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnMinAlpha  | OT_REAL         | 0.000           | NSN line search |
    |                 |                 |                 | minimum step    |
    |                 |                 |                 | size.           |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_nsnSigma     | OT_REAL         | 0.010           | NSN line search |
    |                 |                 |                 | slope           |
    |                 |                 |                 | parameter.      |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_printLevel   | OT_STRING       | None            | Controls the    |
    |                 |                 |                 | amount of QP    |
    |                 |                 |                 | solver output.  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_scaleIntern  | OT_BOOLEAN      | False           | Enable scaling  |
    |                 |                 |                 | on QP level.    |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_strict       | OT_BOOLEAN      | True            | Use strict      |
    |                 |                 |                 | termination     |
    |                 |                 |                 | criteria in IP  |
    |                 |                 |                 | method.         |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+

    >List of available stats

    +--------------------+
    |         Id         |
    +====================+
    | iter_count         |
    +--------------------+
    | iteration          |
    +--------------------+
    | iterations         |
    +--------------------+
    | n_eval_f           |
    +--------------------+
    | n_eval_g           |
    +--------------------+
    | n_eval_grad_f      |
    +--------------------+
    | n_eval_h           |
    +--------------------+
    | n_eval_jac_g       |
    +--------------------+
    | return_code        |
    +--------------------+
    | return_status      |
    +--------------------+
    | t_callback_fun     |
    +--------------------+
    | t_callback_prepare |
    +--------------------+
    | t_eval_f           |
    +--------------------+
    | t_eval_g           |
    +--------------------+
    | t_eval_grad_f      |
    +--------------------+
    | t_eval_h           |
    +--------------------+
    | t_eval_jac_g       |
    +--------------------+
    | t_mainloop         |
    +--------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    scpgen
    ------



    A structure-exploiting sequential quadratic programming (to be come
    sequential convex programming) method for nonlinear programming.

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | beta            | OT_REAL         | 0.800           | Line-search     |
    |                 |                 |                 | parameter,      |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | factor of       |
    |                 |                 |                 | stepsize        |
    +-----------------+-----------------+-----------------+-----------------+
    | c1              | OT_REAL         | 0.000           | Armijo          |
    |                 |                 |                 | condition,      |
    |                 |                 |                 | coefficient of  |
    |                 |                 |                 | decrease in     |
    |                 |                 |                 | merit           |
    +-----------------+-----------------+-----------------+-----------------+
    | codegen         | OT_BOOLEAN      | false           | C-code          |
    |                 |                 |                 | generation      |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | "gcc -fPIC -O2" | Compiler        |
    |                 |                 |                 | command to be   |
    |                 |                 |                 | used for        |
    |                 |                 |                 | compiling       |
    |                 |                 |                 | generated code  |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_approxi | OT_STRING       | "exact"         | gauss-          |
    | mation          |                 |                 | newton|exact    |
    +-----------------+-----------------+-----------------+-----------------+
    | lbfgs_memory    | OT_INTEGER      | 10              | Size of L-BFGS  |
    |                 |                 |                 | memory.         |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 50              | Maximum number  |
    |                 |                 |                 | of SQP          |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter_ls     | OT_INTEGER      | 1               | Maximum number  |
    |                 |                 |                 | of linesearch   |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | merit_memsize   | OT_INTEGER      | 4               | Size of memory  |
    |                 |                 |                 | to store        |
    |                 |                 |                 | history of      |
    |                 |                 |                 | merit function  |
    |                 |                 |                 | values          |
    +-----------------+-----------------+-----------------+-----------------+
    | merit_start     | OT_REAL         | 0.000           | Lower bound for |
    |                 |                 |                 | the merit       |
    |                 |                 |                 | function        |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | name_x          | OT_STRINGVECTOR | GenericType()   | Names of the    |
    |                 |                 |                 | variables.      |
    +-----------------+-----------------+-----------------+-----------------+
    | print_header    | OT_BOOLEAN      | true            | Print the       |
    |                 |                 |                 | header with     |
    |                 |                 |                 | problem         |
    |                 |                 |                 | statistics      |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOLEAN      | true            | Print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about execution |
    |                 |                 |                 | time            |
    +-----------------+-----------------+-----------------+-----------------+
    | print_x         | OT_INTEGERVECTO | GenericType()   | Which variables |
    |                 | R               |                 | to print.       |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_solver       | OT_STRING       | GenericType()   | The QP solver   |
    |                 |                 |                 | to be used by   |
    |                 |                 |                 | the SQP method  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_solver_optio | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ns              |                 |                 | passed to the   |
    |                 |                 |                 | QP solver       |
    +-----------------+-----------------+-----------------+-----------------+
    | reg_threshold   | OT_REAL         | 0.000           | Threshold for   |
    |                 |                 |                 | the             |
    |                 |                 |                 | regularization. |
    +-----------------+-----------------+-----------------+-----------------+
    | regularize      | OT_BOOLEAN      | false           | Automatic       |
    |                 |                 |                 | regularization  |
    |                 |                 |                 | of Lagrange     |
    |                 |                 |                 | Hessian.        |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_du          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | dual            |
    |                 |                 |                 | infeasability   |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_pr          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | primal          |
    |                 |                 |                 | infeasibility   |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_pr_step     | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | the step size   |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_reg         | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | regularization  |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | dx          |
    +-------------+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+
    | qp          |
    +-------------+

    >List of available stats

    +------------+
    |     Id     |
    +============+
    | iter_count |
    +------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqpmethod
    ---------



    A textbook SQPMethod

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | beta            | OT_REAL         | 0.800           | Line-search     |
    |                 |                 |                 | parameter,      |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | factor of       |
    |                 |                 |                 | stepsize        |
    +-----------------+-----------------+-----------------+-----------------+
    | c1              | OT_REAL         | 0.000           | Armijo          |
    |                 |                 |                 | condition,      |
    |                 |                 |                 | coefficient of  |
    |                 |                 |                 | decrease in     |
    |                 |                 |                 | merit           |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_approxi | OT_STRING       | "exact"         | limited-        |
    | mation          |                 |                 | memory|exact    |
    +-----------------+-----------------+-----------------+-----------------+
    | lbfgs_memory    | OT_INTEGER      | 10              | Size of L-BFGS  |
    |                 |                 |                 | memory.         |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 50              | Maximum number  |
    |                 |                 |                 | of SQP          |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter_ls     | OT_INTEGER      | 3               | Maximum number  |
    |                 |                 |                 | of linesearch   |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | merit_memory    | OT_INTEGER      | 4               | Size of memory  |
    |                 |                 |                 | to store        |
    |                 |                 |                 | history of      |
    |                 |                 |                 | merit function  |
    |                 |                 |                 | values          |
    +-----------------+-----------------+-----------------+-----------------+
    | min_step_size   | OT_REAL         | 0.000           | The size (inf-  |
    |                 |                 |                 | norm) of the    |
    |                 |                 |                 | step size       |
    |                 |                 |                 | should not      |
    |                 |                 |                 | become smaller  |
    |                 |                 |                 | than this.      |
    +-----------------+-----------------+-----------------+-----------------+
    | print_header    | OT_BOOLEAN      | true            | Print the       |
    |                 |                 |                 | header with     |
    |                 |                 |                 | problem         |
    |                 |                 |                 | statistics      |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOLEAN      | true            | Print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about execution |
    |                 |                 |                 | time            |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_solver       | OT_STRING       | GenericType()   | The QP solver   |
    |                 |                 |                 | to be used by   |
    |                 |                 |                 | the SQP method  |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_solver_optio | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ns              |                 |                 | passed to the   |
    |                 |                 |                 | QP solver       |
    +-----------------+-----------------+-----------------+-----------------+
    | regularize      | OT_BOOLEAN      | false           | Automatic       |
    |                 |                 |                 | regularization  |
    |                 |                 |                 | of Lagrange     |
    |                 |                 |                 | Hessian.        |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_du          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | dual            |
    |                 |                 |                 | infeasability   |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_pr          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | primal          |
    |                 |                 |                 | infeasibility   |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | bfgs        |
    +-------------+
    | dx          |
    +-------------+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+
    | qp          |
    +-------------+

    >List of available stats

    +--------------------+
    |         Id         |
    +====================+
    | iter_count         |
    +--------------------+
    | iteration          |
    +--------------------+
    | iterations         |
    +--------------------+
    | n_eval_f           |
    +--------------------+
    | n_eval_g           |
    +--------------------+
    | n_eval_grad_f      |
    +--------------------+
    | n_eval_h           |
    +--------------------+
    | n_eval_jac_g       |
    +--------------------+
    | return_status      |
    +--------------------+
    | t_callback_fun     |
    +--------------------+
    | t_callback_prepare |
    +--------------------+
    | t_eval_f           |
    +--------------------+
    | t_eval_g           |
    +--------------------+
    | t_eval_grad_f      |
    +--------------------+
    | t_eval_h           |
    +--------------------+
    | t_eval_jac_g       |
    +--------------------+
    | t_mainloop         |
    +--------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    stabilizedsqp
    -------------



    Stabilized Sequential Quadratic Programming method.

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | TReta1          | OT_REAL         | 0.800           | Required        |
    |                 |                 |                 | predicted /     |
    |                 |                 |                 | actual decrease |
    |                 |                 |                 | for TR increase |
    +-----------------+-----------------+-----------------+-----------------+
    | TReta2          | OT_REAL         | 0.200           | Required        |
    |                 |                 |                 | predicted /     |
    |                 |                 |                 | actual decrease |
    |                 |                 |                 | for TR decrease |
    +-----------------+-----------------+-----------------+-----------------+
    | alphaMin        | OT_REAL         | 0.001           | Used to check   |
    |                 |                 |                 | whether to      |
    |                 |                 |                 | increase rho.   |
    +-----------------+-----------------+-----------------+-----------------+
    | beta            | OT_REAL         | 0.500           | Line-search     |
    |                 |                 |                 | parameter,      |
    |                 |                 |                 | restoration     |
    |                 |                 |                 | factor of       |
    |                 |                 |                 | stepsize        |
    +-----------------+-----------------+-----------------+-----------------+
    | c1              | OT_REAL         | 0.001           | Armijo          |
    |                 |                 |                 | condition,      |
    |                 |                 |                 | coefficient of  |
    |                 |                 |                 | decrease in     |
    |                 |                 |                 | merit           |
    +-----------------+-----------------+-----------------+-----------------+
    | dvMax0          | OT_REAL         | 100             | Parameter used  |
    |                 |                 |                 | to defined the  |
    |                 |                 |                 | max step        |
    |                 |                 |                 | length.         |
    +-----------------+-----------------+-----------------+-----------------+
    | eps_active      | OT_REAL         | 0.000           | Threshold for   |
    |                 |                 |                 | the epsilon-    |
    |                 |                 |                 | active set.     |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma1          | OT_REAL         | 2               | Trust region    |
    |                 |                 |                 | increase        |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma2          | OT_REAL         | 1               | Trust region    |
    |                 |                 |                 | update          |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | gamma3          | OT_REAL         | 1               | Trust region    |
    |                 |                 |                 | decrease        |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | hessian_approxi | OT_STRING       | "exact"         | limited-        |
    | mation          |                 |                 | memory|exact    |
    +-----------------+-----------------+-----------------+-----------------+
    | lbfgs_memory    | OT_INTEGER      | 10              | Size of L-BFGS  |
    |                 |                 |                 | memory.         |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter        | OT_INTEGER      | 100             | Maximum number  |
    |                 |                 |                 | of SQP          |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | max_iter_ls     | OT_INTEGER      | 20              | Maximum number  |
    |                 |                 |                 | of linesearch   |
    |                 |                 |                 | iterations      |
    +-----------------+-----------------+-----------------+-----------------+
    | max_time        | OT_REAL         | 1.000e+12       | Timeout         |
    +-----------------+-----------------+-----------------+-----------------+
    | merit_memory    | OT_INTEGER      | 4               | Size of memory  |
    |                 |                 |                 | to store        |
    |                 |                 |                 | history of      |
    |                 |                 |                 | merit function  |
    |                 |                 |                 | values          |
    +-----------------+-----------------+-----------------+-----------------+
    | min_step_size   | OT_REAL         | 0.000           | The size (inf-  |
    |                 |                 |                 | norm) of the    |
    |                 |                 |                 | step size       |
    |                 |                 |                 | should not      |
    |                 |                 |                 | become smaller  |
    |                 |                 |                 | than this.      |
    +-----------------+-----------------+-----------------+-----------------+
    | muR0            | OT_REAL         | 0.000           | Initial choice  |
    |                 |                 |                 | of              |
    |                 |                 |                 | regularization  |
    |                 |                 |                 | parameter       |
    +-----------------+-----------------+-----------------+-----------------+
    | nu              | OT_REAL         | 1               | Parameter for   |
    |                 |                 |                 | primal-dual     |
    |                 |                 |                 | augmented       |
    |                 |                 |                 | Lagrangian.     |
    +-----------------+-----------------+-----------------+-----------------+
    | phiWeight       | OT_REAL         | 0.000           | Weight used in  |
    |                 |                 |                 | pseudo-filter.  |
    +-----------------+-----------------+-----------------+-----------------+
    | print_header    | OT_BOOLEAN      | true            | Print the       |
    |                 |                 |                 | header with     |
    |                 |                 |                 | problem         |
    |                 |                 |                 | statistics      |
    +-----------------+-----------------+-----------------+-----------------+
    | regularize      | OT_BOOLEAN      | false           | Automatic       |
    |                 |                 |                 | regularization  |
    |                 |                 |                 | of Lagrange     |
    |                 |                 |                 | Hessian.        |
    +-----------------+-----------------+-----------------+-----------------+
    | stabilized_qp_s | OT_STRING       | GenericType()   | The Stabilized  |
    | olver           |                 |                 | QP solver to be |
    |                 |                 |                 | used by the SQP |
    |                 |                 |                 | method          |
    +-----------------+-----------------+-----------------+-----------------+
    | stabilized_qp_s | OT_DICTIONARY   | GenericType()   | Options to be   |
    | olver_options   |                 |                 | passed to the   |
    |                 |                 |                 | Stabilized QP   |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+
    | tau0            | OT_REAL         | 0.010           | Initial         |
    |                 |                 |                 | parameter for   |
    |                 |                 |                 | the merit       |
    |                 |                 |                 | function        |
    |                 |                 |                 | optimality      |
    |                 |                 |                 | threshold.      |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_du          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | dual            |
    |                 |                 |                 | infeasability   |
    +-----------------+-----------------+-----------------+-----------------+
    | tol_pr          | OT_REAL         | 0.000           | Stopping        |
    |                 |                 |                 | criterion for   |
    |                 |                 |                 | primal          |
    |                 |                 |                 | infeasibility   |
    +-----------------+-----------------+-----------------+-----------------+
    | yEinitial       | OT_STRING       | "simple"        | Initial         |
    |                 |                 |                 | multiplier.     |
    |                 |                 |                 | Simple (all     |
    |                 |                 |                 | zero) or least  |
    |                 |                 |                 | (LSQ).          |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available monitors

    +-------------+
    |     Id      |
    +=============+
    | dx          |
    +-------------+
    | eval_f      |
    +-------------+
    | eval_g      |
    +-------------+
    | eval_grad_f |
    +-------------+
    | eval_h      |
    +-------------+
    | eval_jac_g  |
    +-------------+
    | qp          |
    +-------------+

    >List of available stats

    +---------------+
    |      Id       |
    +===============+
    | iter_count    |
    +---------------+
    | return_status |
    +---------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: nlp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NlpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NlpSolver, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.NlpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.NlpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.NlpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.NlpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def reportConstraints(self, *args):
        """
        reportConstraints(NlpSolver self, std::ostream & stream)



        Prints out a human readable report about possible constraint violations,
        after solving.


        """
        return _casadi_core.NlpSolver_reportConstraints(self, *args)


    def getReportConstraints(self, *args):
        """getReportConstraints(NlpSolver self) -> std::string"""
        return _casadi_core.NlpSolver_getReportConstraints(self, *args)


    def setQPOptions(self, *args):
        """
        setQPOptions(NlpSolver self)



        Set options that make the NLP solver more suitable for solving QPs.


        """
        return _casadi_core.NlpSolver_setQPOptions(self, *args)


    def nlp(self, *args):
        """
        nlp(NlpSolver self) -> Function



        Access the NLP.

        >Input scheme: casadi::NlpSolverInput (NLP_SOLVER_NUM_IN = 8) [nlpSolverIn]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | NLP_SOLVER_X0          | x0                     | Decision variables,    |
        |                        |                        | initial guess (nx x 1) |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_P           | p                      | Value of fixed         |
        |                        |                        | parameters (np x 1) .  |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LBX         | lbx                    | Decision variables     |
        |                        |                        | lower bound (nx x 1),  |
        |                        |                        | default -inf .         |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_UBX         | ubx                    | Decision variables     |
        |                        |                        | upper bound (nx x 1),  |
        |                        |                        | default +inf .         |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LBG         | lbg                    | Constraints lower      |
        |                        |                        | bound (ng x 1),        |
        |                        |                        | default -inf .         |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_UBG         | ubg                    | Constraints upper      |
        |                        |                        | bound (ng x 1),        |
        |                        |                        | default +inf .         |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LAM_X0      | lam_x0                 | Lagrange multipliers   |
        |                        |                        | for bounds on X,       |
        |                        |                        | initial guess (nx x 1) |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LAM_G0      | lam_g0                 | Lagrange multipliers   |
        |                        |                        | for bounds on G,       |
        |                        |                        | initial guess (ng x 1) |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+

        >Output scheme: casadi::NlpSolverOutput (NLP_SOLVER_NUM_OUT = 6) [nlpSolverOut]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | NLP_SOLVER_X           | x                      | Decision variables at  |
        |                        |                        | the optimal solution   |
        |                        |                        | (nx x 1) .             |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_F           | f                      | Cost function value at |
        |                        |                        | the optimal solution   |
        |                        |                        | (1 x 1) .              |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_G           | g                      | Constraints function   |
        |                        |                        | at the optimal         |
        |                        |                        | solution (ng x 1) .    |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LAM_X       | lam_x                  | Lagrange multipliers   |
        |                        |                        | for bounds on X at the |
        |                        |                        | solution (nx x 1) .    |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LAM_G       | lam_g                  | Lagrange multipliers   |
        |                        |                        | for bounds on G at the |
        |                        |                        | solution (ng x 1) .    |
        +------------------------+------------------------+------------------------+
        | NLP_SOLVER_LAM_P       | lam_p                  | Lagrange multipliers   |
        |                        |                        | for bounds on P at the |
        |                        |                        | solution (np x 1) .    |
        +------------------------+------------------------+------------------------+


        """
        return _casadi_core.NlpSolver_nlp(self, *args)


    def gradF(self, *args):
        """
        gradF(NlpSolver self) -> Function



        Access the objective gradient function>Input scheme: casadi::GradFInput
        (GRADF_NUM_IN = 2) [gradFIn]

        +-----------+-------+---------------------+
        | Full name | Short |     Description     |
        +===========+=======+=====================+
        | GRADF_X   | x     | Decision variable . |
        +-----------+-------+---------------------+
        | GRADF_P   | p     | Fixed parameter .   |
        +-----------+-------+---------------------+


        """
        return _casadi_core.NlpSolver_gradF(self, *args)


    def jacG(self, *args):
        """
        jacG(NlpSolver self) -> Function



        Access the Jacobian of the constraint function.

        >Input scheme: casadi::HessLagInput (HESSLAG_NUM_IN = 4) [hessLagIn]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | HESSLAG_X              | x                      | Decision variable .    |
        +------------------------+------------------------+------------------------+
        | HESSLAG_P              | p                      | Fixed parameter .      |
        +------------------------+------------------------+------------------------+
        | HESSLAG_LAM_F          | lam_f                  | Multiplier for f. Just |
        |                        |                        | a scalar factor for    |
        |                        |                        | the objective that the |
        |                        |                        | NLP solver might use   |
        |                        |                        | to scale the           |
        |                        |                        | objective.             |
        +------------------------+------------------------+------------------------+
        | HESSLAG_LAM_G          | lam_g                  | Multiplier for g .     |
        +------------------------+------------------------+------------------------+

        >Output scheme: casadi::HessLagOutput (HESSLAG_NUM_OUT = 5) [hessLagOut]

        +----------------+--------+------------------------------------------------+
        |   Full name    | Short  |                  Description                   |
        +================+========+================================================+
        | HESSLAG_HESS   | hess   | Hessian of the Lagrangian .                    |
        +----------------+--------+------------------------------------------------+
        | HESSLAG_F      | f      | Objective function .                           |
        +----------------+--------+------------------------------------------------+
        | HESSLAG_G      | g      | Constraint function .                          |
        +----------------+--------+------------------------------------------------+
        | HESSLAG_GRAD_X | grad_x | Gradient of the Lagrangian with respect to x . |
        +----------------+--------+------------------------------------------------+
        | HESSLAG_GRAD_P | grad_p | Gradient of the Lagrangian with respect to p . |
        +----------------+--------+------------------------------------------------+


        """
        return _casadi_core.NlpSolver_jacG(self, *args)


    def hessLag(self, *args):
        """
        hessLag(NlpSolver self) -> Function



        Access the Hessian of the Lagrangian function.

        >Input scheme: casadi::JacGInput (JACG_NUM_IN = 2) [jacGIn]

        +-----------+-------+---------------------+
        | Full name | Short |     Description     |
        +===========+=======+=====================+
        | JACG_X    | x     | Decision variable . |
        +-----------+-------+---------------------+
        | JACG_P    | p     | Fixed parameter .   |
        +-----------+-------+---------------------+

        >Output scheme: casadi::JacGOutput (JACG_NUM_OUT = 3) [jacGOut]

        +-----------+-------+-------------------------------+
        | Full name | Short |          Description          |
        +===========+=======+===============================+
        | JACG_JAC  | jac   | Jacobian of the constraints . |
        +-----------+-------+-------------------------------+
        | JACG_F    | f     | Objective function .          |
        +-----------+-------+-------------------------------+
        | JACG_G    | g     | Constraint function .         |
        +-----------+-------+-------------------------------+


        """
        return _casadi_core.NlpSolver_hessLag(self, *args)


    def joinFG(*args):
        """joinFG(Function F, Function G) -> Function"""
        return _casadi_core.NlpSolver_joinFG(*args)

    if _newclass:
        joinFG = staticmethod(joinFG)
    __swig_getmethods__["joinFG"] = lambda x: joinFG

    def getReducedHessian(self, *args):
        """
        getReducedHessian(NlpSolver self) -> DMatrix



        Get the reduced Hessian. Requires a patched sIPOPT installation, see CasADi
        documentation.


        """
        return _casadi_core.NlpSolver_getReducedHessian(self, *args)


    def setOptionsFromFile(self, *args):
        """
        setOptionsFromFile(NlpSolver self, std::string const & file)



        Read options from parameter xml.


        """
        return _casadi_core.NlpSolver_setOptionsFromFile(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::NlpSolver self) -> NlpSolver
        __init__(casadi::NlpSolver self, std::string const & name, Function nlp) -> NlpSolver
        __init__(casadi::NlpSolver self, NlpSolver other) -> NlpSolver



        >  casadi::NlpSolver::NlpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::NlpSolver::NlpSolver(const std::string &name, const Function &nlp)
        ------------------------------------------------------------------------

        NLP solver factory.


        """
        this = _casadi_core.new_NlpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_NlpSolver
NlpSolver_swigregister = _casadi_core.NlpSolver_swigregister
NlpSolver_swigregister(NlpSolver)

def NlpSolver_testCast(*args):
    """NlpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.NlpSolver_testCast(*args)

def NlpSolver_hasPlugin(*args):
    """NlpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.NlpSolver_hasPlugin(*args)

def NlpSolver_loadPlugin(*args):
    """NlpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.NlpSolver_loadPlugin(*args)

def NlpSolver_doc(*args):
    """NlpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.NlpSolver_doc(*args)

def NlpSolver_joinFG(*args):
    """NlpSolver_joinFG(Function F, Function G) -> Function"""
    return _casadi_core.NlpSolver_joinFG(*args)


_casadi_core.HNL_X_swigconstant(_casadi_core)
HNL_X = _casadi_core.HNL_X

_casadi_core.HNL_P_swigconstant(_casadi_core)
HNL_P = _casadi_core.HNL_P

_casadi_core.HNL_TAU_swigconstant(_casadi_core)
HNL_TAU = _casadi_core.HNL_TAU

_casadi_core.HNL_NUM_IN_swigconstant(_casadi_core)
HNL_NUM_IN = _casadi_core.HNL_NUM_IN
class HomotopyNlpSolver(Function):
    """


    Base class for Homotopy NLP Solvers.

    Solves the following parametric nonlinear program (NLP):

    ::

      min          F(x, p, tau)
       x

      subject to
                  LBX <=   x    <= UBX
                  LBG <= G(x, p) <= UBG
                             p  == P

          nx: number of decision variables
          ng: number of constraints
          np: number of parameters




    In a homotopy from tau = 0 to tau = 1.

    General information
    ===================



    >Input scheme: casadi::NlpSolverInput (NLP_SOLVER_NUM_IN = 8) [nlpSolverIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLP_SOLVER_X0          | x0                     | Decision variables,    |
    |                        |                        | initial guess (nx x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_P           | p                      | Value of fixed         |
    |                        |                        | parameters (np x 1) .  |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LBX         | lbx                    | Decision variables     |
    |                        |                        | lower bound (nx x 1),  |
    |                        |                        | default -inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_UBX         | ubx                    | Decision variables     |
    |                        |                        | upper bound (nx x 1),  |
    |                        |                        | default +inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LBG         | lbg                    | Constraints lower      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default -inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_UBG         | ubg                    | Constraints upper      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default +inf .         |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_X0      | lam_x0                 | Lagrange multipliers   |
    |                        |                        | for bounds on X,       |
    |                        |                        | initial guess (nx x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_G0      | lam_g0                 | Lagrange multipliers   |
    |                        |                        | for bounds on G,       |
    |                        |                        | initial guess (ng x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::NlpSolverOutput (NLP_SOLVER_NUM_OUT = 6) [nlpSolverOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLP_SOLVER_X           | x                      | Decision variables at  |
    |                        |                        | the optimal solution   |
    |                        |                        | (nx x 1) .             |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_F           | f                      | Cost function value at |
    |                        |                        | the optimal solution   |
    |                        |                        | (1 x 1) .              |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_G           | g                      | Constraints function   |
    |                        |                        | at the optimal         |
    |                        |                        | solution (ng x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_X       | lam_x                  | Lagrange multipliers   |
    |                        |                        | for bounds on X at the |
    |                        |                        | solution (nx x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_G       | lam_g                  | Lagrange multipliers   |
    |                        |                        | for bounds on G at the |
    |                        |                        | solution (ng x 1) .    |
    +------------------------+------------------------+------------------------+
    | NLP_SOLVER_LAM_P       | lam_p                  | Lagrange multipliers   |
    |                        |                        | for bounds on P at the |
    |                        |                        | solution (np x 1) .    |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | expand       | OT_BOOLEAN   | false        | Expand the   | casadi::Homo |
    |              |              |              | NLP function | topyNLPInter |
    |              |              |              | in terms of  | nal          |
    |              |              |              | scalar       |              |
    |              |              |              | operations,  |              |
    |              |              |              | i.e. MX->SX  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_HomotopyNlpSolver_simple'>simple</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    HomotopyNlpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    simple
    ------



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | nlp_solver      | OT_STRING       | GenericType()   | The NLP solver  |
    |                 |                 |                 | to be used by   |
    |                 |                 |                 | the Homotopy    |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+
    | nlp_solver_opti | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ons             |                 |                 | passed to the   |
    |                 |                 |                 | Homotopy solver |
    +-----------------+-----------------+-----------------+-----------------+
    | num_steps       | OT_INTEGER      | 10              | Take this many  |
    |                 |                 |                 | steps to go     |
    |                 |                 |                 | from tau=0 to   |
    |                 |                 |                 | tau=1.          |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: homotopy_nlp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HomotopyNlpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HomotopyNlpSolver, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.HomotopyNlpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.HomotopyNlpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.HomotopyNlpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.HomotopyNlpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::HomotopyNlpSolver self) -> HomotopyNlpSolver
        __init__(casadi::HomotopyNlpSolver self, HomotopyNlpSolver other) -> HomotopyNlpSolver



        Default constructor.


        """
        this = _casadi_core.new_HomotopyNlpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_HomotopyNlpSolver
HomotopyNlpSolver_swigregister = _casadi_core.HomotopyNlpSolver_swigregister
HomotopyNlpSolver_swigregister(HomotopyNlpSolver)

def HomotopyNlpSolver_testCast(*args):
    """HomotopyNlpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.HomotopyNlpSolver_testCast(*args)

def HomotopyNlpSolver_hasPlugin(*args):
    """HomotopyNlpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.HomotopyNlpSolver_hasPlugin(*args)

def HomotopyNlpSolver_loadPlugin(*args):
    """HomotopyNlpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.HomotopyNlpSolver_loadPlugin(*args)

def HomotopyNlpSolver_doc(*args):
    """HomotopyNlpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.HomotopyNlpSolver_doc(*args)


_casadi_core.QP_SOLVER_H_swigconstant(_casadi_core)
QP_SOLVER_H = _casadi_core.QP_SOLVER_H

_casadi_core.QP_SOLVER_G_swigconstant(_casadi_core)
QP_SOLVER_G = _casadi_core.QP_SOLVER_G

_casadi_core.QP_SOLVER_A_swigconstant(_casadi_core)
QP_SOLVER_A = _casadi_core.QP_SOLVER_A

_casadi_core.QP_SOLVER_LBA_swigconstant(_casadi_core)
QP_SOLVER_LBA = _casadi_core.QP_SOLVER_LBA

_casadi_core.QP_SOLVER_UBA_swigconstant(_casadi_core)
QP_SOLVER_UBA = _casadi_core.QP_SOLVER_UBA

_casadi_core.QP_SOLVER_LBX_swigconstant(_casadi_core)
QP_SOLVER_LBX = _casadi_core.QP_SOLVER_LBX

_casadi_core.QP_SOLVER_UBX_swigconstant(_casadi_core)
QP_SOLVER_UBX = _casadi_core.QP_SOLVER_UBX

_casadi_core.QP_SOLVER_X0_swigconstant(_casadi_core)
QP_SOLVER_X0 = _casadi_core.QP_SOLVER_X0

_casadi_core.QP_SOLVER_LAM_X0_swigconstant(_casadi_core)
QP_SOLVER_LAM_X0 = _casadi_core.QP_SOLVER_LAM_X0

_casadi_core.QP_SOLVER_NUM_IN_swigconstant(_casadi_core)
QP_SOLVER_NUM_IN = _casadi_core.QP_SOLVER_NUM_IN

_casadi_core.QP_SOLVER_X_swigconstant(_casadi_core)
QP_SOLVER_X = _casadi_core.QP_SOLVER_X

_casadi_core.QP_SOLVER_COST_swigconstant(_casadi_core)
QP_SOLVER_COST = _casadi_core.QP_SOLVER_COST

_casadi_core.QP_SOLVER_LAM_A_swigconstant(_casadi_core)
QP_SOLVER_LAM_A = _casadi_core.QP_SOLVER_LAM_A

_casadi_core.QP_SOLVER_LAM_X_swigconstant(_casadi_core)
QP_SOLVER_LAM_X = _casadi_core.QP_SOLVER_LAM_X

_casadi_core.QP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
QP_SOLVER_NUM_OUT = _casadi_core.QP_SOLVER_NUM_OUT

_casadi_core.QP_STRUCT_H_swigconstant(_casadi_core)
QP_STRUCT_H = _casadi_core.QP_STRUCT_H

_casadi_core.QP_STRUCT_A_swigconstant(_casadi_core)
QP_STRUCT_A = _casadi_core.QP_STRUCT_A

_casadi_core.QP_STRUCT_NUM_swigconstant(_casadi_core)
QP_STRUCT_NUM = _casadi_core.QP_STRUCT_NUM
class QpSolver(Function):
    """


    QpSolver.

    Solves the following strictly convex problem:



    ::

      min          1/2 x' H x + g' x
       x

      subject to
                  LBA <= A x <= UBA
                  LBX <= x   <= UBX

          with :
            H sparse (n x n) positive definite
            g dense  (n x 1)

          n: number of decision variables (x)
          nc: number of constraints (A)



    If H is not positive-definite, the solver should throw an error.

    General information
    ===================



    >Input scheme: casadi::QpSolverInput (QP_SOLVER_NUM_IN = 9) [qpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QP_SOLVER_H            | h                      | The square matrix H:   |
    |                        |                        | sparse, (n x n). Only  |
    |                        |                        | the lower triangular   |
    |                        |                        | part is actually used. |
    |                        |                        | The matrix is assumed  |
    |                        |                        | to be symmetrical.     |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_G            | g                      | The vector g: dense,   |
    |                        |                        | (n x 1) .              |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_A            | a                      | The matrix A: sparse,  |
    |                        |                        | (nc x n) - product     |
    |                        |                        | with x must be dense.  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LBA          | lba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_UBA          | uba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LBX          | lbx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_UBX          | ubx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_X0           | x0                     | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LAM_X0       | lam_x0                 | dense                  |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::QpSolverOutput (QP_SOLVER_NUM_OUT = 4) [qpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QP_SOLVER_X            | x                      | The primal solution .  |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_COST         | cost                   | The optimal cost .     |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LAM_A        | lam_a                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | linear bounds .        |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LAM_X        | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds .        |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_QpSolver_cplex'>cplex</a>

    - <a href='#plugin_QpSolver_ooqp'>ooqp</a>

    - <a href='#plugin_QpSolver_qpoases'>qpoases</a>

    - <a href='#plugin_QpSolver_sqic'>sqic</a>

    - <a href='#plugin_QpSolver_nlp'>nlp</a>

    - <a href='#plugin_QpSolver_qcqp'>qcqp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    QpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    cplex
    -----



    Interface to Cplex solver for sparse Quadratic Programs

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | barrier_maxiter | OT_INTEGER      | 2.100e+09       | Maximum number  |
    |                 |                 |                 | of barrier      |
    |                 |                 |                 | iterations.     |
    +-----------------+-----------------+-----------------+-----------------+
    | convex          | OT_BOOLEAN      | true            | Indicates if    |
    |                 |                 |                 | the QP is       |
    |                 |                 |                 | convex or not   |
    |                 |                 |                 | (affects only   |
    |                 |                 |                 | the barrier     |
    |                 |                 |                 | method).        |
    +-----------------+-----------------+-----------------+-----------------+
    | dep_check       | OT_STRING       | "off"           | Detect          |
    |                 |                 |                 | redundant       |
    |                 |                 |                 | constraints. (a |
    |                 |                 |                 | utomatic:-1|off |
    |                 |                 |                 | :0|begin:1|end: |
    |                 |                 |                 | 2|both:3)       |
    +-----------------+-----------------+-----------------+-----------------+
    | dump_filename   | OT_STRING       | "qp.dat"        | The filename to |
    |                 |                 |                 | dump to.        |
    +-----------------+-----------------+-----------------+-----------------+
    | dump_to_file    | OT_BOOLEAN      | false           | Dumps QP to     |
    |                 |                 |                 | file in CPLEX   |
    |                 |                 |                 | format.         |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_method       | OT_STRING       | "automatic"     | Determines      |
    |                 |                 |                 | which CPLEX     |
    |                 |                 |                 | algorithm to    |
    |                 |                 |                 | use. (automatic |
    |                 |                 |                 | |primal_simplex |
    |                 |                 |                 | |dual_simplex|n |
    |                 |                 |                 | etwork|barrier| |
    |                 |                 |                 | sifting|concurr |
    |                 |                 |                 | ent|crossover)  |
    +-----------------+-----------------+-----------------+-----------------+
    | simplex_maxiter | OT_INTEGER      | 2.100e+09       | Maximum number  |
    |                 |                 |                 | of simplex      |
    |                 |                 |                 | iterations.     |
    +-----------------+-----------------+-----------------+-----------------+
    | tol             | OT_REAL         | 0.000           | Tolerance of    |
    |                 |                 |                 | solver          |
    +-----------------+-----------------+-----------------+-----------------+
    | warm_start      | OT_BOOLEAN      | false           | Use warm start  |
    |                 |                 |                 | with simplex    |
    |                 |                 |                 | methods         |
    |                 |                 |                 | (affects only   |
    |                 |                 |                 | the simplex     |
    |                 |                 |                 | methods).       |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    ooqp
    ----



    Interface to the OOQP Solver for quadratic programming The current
    implementation assumes that OOQP is configured with the MA27 sparse linear
    solver.

    NOTE: when doing multiple calls to evaluate(), check if you need to
    reInit();

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | artol           | OT_REAL         | 0.000           | tolerance as    |
    |                 |                 |                 | provided with   |
    |                 |                 |                 | setArTol to     |
    |                 |                 |                 | OOQP            |
    +-----------------+-----------------+-----------------+-----------------+
    | mutol           | OT_REAL         | 0.000           | tolerance as    |
    |                 |                 |                 | provided with   |
    |                 |                 |                 | setMuTol to     |
    |                 |                 |                 | OOQP            |
    +-----------------+-----------------+-----------------+-----------------+
    | print_level     | OT_INTEGER      | 0               | Print level.    |
    |                 |                 |                 | OOQP listens to |
    |                 |                 |                 | print_level 0,  |
    |                 |                 |                 | 10 and 100      |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    qpoases
    -------



    Interface to QPOases Solver for quadratic programming

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | CPUtime         | OT_REAL         | None            | The maximum     |
    |                 |                 |                 | allowed CPU     |
    |                 |                 |                 | time in seconds |
    |                 |                 |                 | for the whole   |
    |                 |                 |                 | initialisation  |
    |                 |                 |                 | (and the        |
    |                 |                 |                 | actually        |
    |                 |                 |                 | required one on |
    |                 |                 |                 | output).        |
    |                 |                 |                 | Disabled if     |
    |                 |                 |                 | unset.          |
    +-----------------+-----------------+-----------------+-----------------+
    | boundRelaxation | OT_REAL         | 10000           | Initial         |
    |                 |                 |                 | relaxation of   |
    |                 |                 |                 | bounds to start |
    |                 |                 |                 | homotopy and    |
    |                 |                 |                 | initial value   |
    |                 |                 |                 | for far bounds. |
    +-----------------+-----------------+-----------------+-----------------+
    | boundTolerance  | OT_REAL         | 0.000           | If upper and    |
    |                 |                 |                 | lower bounds    |
    |                 |                 |                 | differ less     |
    |                 |                 |                 | than this       |
    |                 |                 |                 | tolerance, they |
    |                 |                 |                 | are regarded    |
    |                 |                 |                 | equal, i.e. as  |
    |                 |                 |                 | equality        |
    |                 |                 |                 | constraint.     |
    +-----------------+-----------------+-----------------+-----------------+
    | enableCholeskyR | OT_INTEGER      | 0               | Specifies the   |
    | efactorisation  |                 |                 | frequency of a  |
    |                 |                 |                 | full re-        |
    |                 |                 |                 | factorisation   |
    |                 |                 |                 | of projected    |
    |                 |                 |                 | Hessian matrix: |
    |                 |                 |                 | 0: turns them   |
    |                 |                 |                 | off, 1: uses    |
    |                 |                 |                 | them at each    |
    |                 |                 |                 | iteration etc.  |
    +-----------------+-----------------+-----------------+-----------------+
    | enableDriftCorr | OT_INTEGER      | 1               | Specifies the   |
    | ection          |                 |                 | frequency of    |
    |                 |                 |                 | drift           |
    |                 |                 |                 | corrections: 0: |
    |                 |                 |                 | turns them off. |
    +-----------------+-----------------+-----------------+-----------------+
    | enableEqualitie | OT_BOOLEAN      | False           | Specifies       |
    | s               |                 |                 | whether         |
    |                 |                 |                 | equalities      |
    |                 |                 |                 | should be       |
    |                 |                 |                 | treated as      |
    |                 |                 |                 | always active   |
    |                 |                 |                 | (True) or not   |
    |                 |                 |                 | (False)         |
    +-----------------+-----------------+-----------------+-----------------+
    | enableFarBounds | OT_BOOLEAN      | True            | Enables the use |
    |                 |                 |                 | of far bounds.  |
    +-----------------+-----------------+-----------------+-----------------+
    | enableFlippingB | OT_BOOLEAN      | True            | Enables the use |
    | ounds           |                 |                 | of flipping     |
    |                 |                 |                 | bounds.         |
    +-----------------+-----------------+-----------------+-----------------+
    | enableFullLITes | OT_BOOLEAN      | False           | Enables         |
    | ts              |                 |                 | condition-      |
    |                 |                 |                 | hardened (but   |
    |                 |                 |                 | more expensive) |
    |                 |                 |                 | LI test.        |
    +-----------------+-----------------+-----------------+-----------------+
    | enableNZCTests  | OT_BOOLEAN      | True            | Enables nonzero |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | tests.          |
    +-----------------+-----------------+-----------------+-----------------+
    | enableRamping   | OT_BOOLEAN      | True            | Enables         |
    |                 |                 |                 | ramping.        |
    +-----------------+-----------------+-----------------+-----------------+
    | enableRegularis | OT_BOOLEAN      | False           | Enables         |
    | ation           |                 |                 | automatic       |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | regularisation. |
    +-----------------+-----------------+-----------------+-----------------+
    | epsDen          | OT_REAL         | 0.000           | Denominator     |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | ratio tests.    |
    +-----------------+-----------------+-----------------+-----------------+
    | epsFlipping     | OT_REAL         | 0.000           | Tolerance of    |
    |                 |                 |                 | squared         |
    |                 |                 |                 | Cholesky        |
    |                 |                 |                 | diagonal factor |
    |                 |                 |                 | which triggers  |
    |                 |                 |                 | flipping bound. |
    +-----------------+-----------------+-----------------+-----------------+
    | epsIterRef      | OT_REAL         | 0.000           | Early           |
    |                 |                 |                 | termination     |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | iterative       |
    |                 |                 |                 | refinement.     |
    +-----------------+-----------------+-----------------+-----------------+
    | epsLITests      | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | linear          |
    |                 |                 |                 | independence    |
    |                 |                 |                 | tests.          |
    +-----------------+-----------------+-----------------+-----------------+
    | epsNZCTests     | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | nonzero         |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | tests.          |
    +-----------------+-----------------+-----------------+-----------------+
    | epsNum          | OT_REAL         | -0.000          | Numerator       |
    |                 |                 |                 | tolerance for   |
    |                 |                 |                 | ratio tests.    |
    +-----------------+-----------------+-----------------+-----------------+
    | epsRegularisati | OT_REAL         | 0.000           | Scaling factor  |
    | on              |                 |                 | of identity     |
    |                 |                 |                 | matrix used for |
    |                 |                 |                 | Hessian         |
    |                 |                 |                 | regularisation. |
    +-----------------+-----------------+-----------------+-----------------+
    | finalRamping    | OT_REAL         | 1               | Final value for |
    |                 |                 |                 | ramping         |
    |                 |                 |                 | strategy.       |
    +-----------------+-----------------+-----------------+-----------------+
    | growFarBounds   | OT_REAL         | 1000            | Factor to grow  |
    |                 |                 |                 | far bounds.     |
    +-----------------+-----------------+-----------------+-----------------+
    | initialFarBound | OT_REAL         | 1000000         | Initial size    |
    | s               |                 |                 | for far bounds. |
    +-----------------+-----------------+-----------------+-----------------+
    | initialRamping  | OT_REAL         | 0.500           | Start value for |
    |                 |                 |                 | ramping         |
    |                 |                 |                 | strategy.       |
    +-----------------+-----------------+-----------------+-----------------+
    | initialStatusBo | OT_STRING       | lower           | Initial status  |
    | unds            |                 |                 | of bounds at    |
    |                 |                 |                 | first           |
    |                 |                 |                 | iteration.      |
    +-----------------+-----------------+-----------------+-----------------+
    | maxDualJump     | OT_REAL         | 100000000       | Maximum allowed |
    |                 |                 |                 | jump in dual    |
    |                 |                 |                 | variables in    |
    |                 |                 |                 | linear          |
    |                 |                 |                 | independence    |
    |                 |                 |                 | tests.          |
    +-----------------+-----------------+-----------------+-----------------+
    | maxPrimalJump   | OT_REAL         | 100000000       | Maximum allowed |
    |                 |                 |                 | jump in primal  |
    |                 |                 |                 | variables in    |
    |                 |                 |                 | nonzero         |
    |                 |                 |                 | curvature       |
    |                 |                 |                 | tests.          |
    +-----------------+-----------------+-----------------+-----------------+
    | nWSR            | OT_INTEGER      | None            | The maximum     |
    |                 |                 |                 | number of       |
    |                 |                 |                 | working set     |
    |                 |                 |                 | recalculations  |
    |                 |                 |                 | to be performed |
    |                 |                 |                 | during the      |
    |                 |                 |                 | initial         |
    |                 |                 |                 | homotopy.       |
    |                 |                 |                 | Default is 5(nx |
    |                 |                 |                 | + nc)           |
    +-----------------+-----------------+-----------------+-----------------+
    | numRefinementSt | OT_INTEGER      | 1               | Maximum number  |
    | eps             |                 |                 | of iterative    |
    |                 |                 |                 | refinement      |
    |                 |                 |                 | steps.          |
    +-----------------+-----------------+-----------------+-----------------+
    | numRegularisati | OT_INTEGER      | 0               | Maximum number  |
    | onSteps         |                 |                 | of successive   |
    |                 |                 |                 | regularisation  |
    |                 |                 |                 | steps.          |
    +-----------------+-----------------+-----------------+-----------------+
    | printLevel      | OT_STRING       | medium          | Defines the     |
    |                 |                 |                 | amount of text  |
    |                 |                 |                 | output during   |
    |                 |                 |                 | QP solution,    |
    |                 |                 |                 | see Section 5.7 |
    +-----------------+-----------------+-----------------+-----------------+
    | terminationTole | OT_REAL         | 0.000           | Relative        |
    | rance           |                 |                 | termination     |
    |                 |                 |                 | tolerance to    |
    |                 |                 |                 | stop homotopy.  |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqic
    ----



    Interface to the SQIC solver for quadratic programming

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    nlp
    ---



    Solve QPs using an NlpSolver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +------------------+
    |        Id        |
    +==================+
    | nlp_solver_stats |
    +------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    qcqp
    ----



    Solve QP using a QcqpSolver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +-------------------+
    |        Id         |
    +===================+
    | qcqp_solver_stats |
    +-------------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: qp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QpSolver, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.QpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.QpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.QpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.QpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def setLPOptions(self, *args):
        """
        setLPOptions(QpSolver self)



        Set options that make the QP solver more suitable for solving LPs.


        """
        return _casadi_core.QpSolver_setLPOptions(self, *args)


    def generateNativeCode(self, *args):
        """
        generateNativeCode(QpSolver self, std::string const & filename)
        generateNativeCode(QpSolver self, std::ostream & file)



        Generate native code in the interfaced language for debugging


        """
        return _casadi_core.QpSolver_generateNativeCode(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::QpSolver self) -> QpSolver
        __init__(casadi::QpSolver self, std::string const & name, QPStructure st) -> QpSolver
        __init__(casadi::QpSolver self, QpSolver other) -> QpSolver



        >  casadi::QpSolver::QpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::QpSolver::QpSolver(const std::string &name, const QPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_QpSolver_cplex'>cplex</a>

        - <a href='#plugin_QpSolver_ooqp'>ooqp</a>

        - <a href='#plugin_QpSolver_qpoases'>qpoases</a>

        - <a href='#plugin_QpSolver_sqic'>sqic</a>

        - <a href='#plugin_QpSolver_nlp'>nlp</a>

        - <a href='#plugin_QpSolver_qcqp'>qcqp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        QpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::QPStruct ( = 2) [qpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | QP_STRUCT_H            | h                      | The square matrix H:   |
        |                        |                        | sparse, (n x n). Only  |
        |                        |                        | the lower triangular   |
        |                        |                        | part is actually used. |
        |                        |                        | The matrix is assumed  |
        |                        |                        | to be symmetrical.     |
        +------------------------+------------------------+------------------------+
        | QP_STRUCT_A            | a                      | The matrix A: sparse,  |
        |                        |                        | (nc x n) - product     |
        |                        |                        | with x must be dense.  |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_QpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_QpSolver
QpSolver_swigregister = _casadi_core.QpSolver_swigregister
QpSolver_swigregister(QpSolver)

def QpSolver_testCast(*args):
    """QpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.QpSolver_testCast(*args)

def QpSolver_hasPlugin(*args):
    """QpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.QpSolver_hasPlugin(*args)

def QpSolver_loadPlugin(*args):
    """QpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.QpSolver_loadPlugin(*args)

def QpSolver_doc(*args):
    """QpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.QpSolver_doc(*args)


_casadi_core.STABILIZED_QP_SOLVER_H_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_H = _casadi_core.STABILIZED_QP_SOLVER_H

_casadi_core.STABILIZED_QP_SOLVER_G_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_G = _casadi_core.STABILIZED_QP_SOLVER_G

_casadi_core.STABILIZED_QP_SOLVER_A_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_A = _casadi_core.STABILIZED_QP_SOLVER_A

_casadi_core.STABILIZED_QP_SOLVER_LBA_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_LBA = _casadi_core.STABILIZED_QP_SOLVER_LBA

_casadi_core.STABILIZED_QP_SOLVER_UBA_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_UBA = _casadi_core.STABILIZED_QP_SOLVER_UBA

_casadi_core.STABILIZED_QP_SOLVER_LBX_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_LBX = _casadi_core.STABILIZED_QP_SOLVER_LBX

_casadi_core.STABILIZED_QP_SOLVER_UBX_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_UBX = _casadi_core.STABILIZED_QP_SOLVER_UBX

_casadi_core.STABILIZED_QP_SOLVER_X0_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_X0 = _casadi_core.STABILIZED_QP_SOLVER_X0

_casadi_core.STABILIZED_QP_SOLVER_LAM_X0_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_LAM_X0 = _casadi_core.STABILIZED_QP_SOLVER_LAM_X0

_casadi_core.STABILIZED_QP_SOLVER_MUR_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_MUR = _casadi_core.STABILIZED_QP_SOLVER_MUR

_casadi_core.STABILIZED_QP_SOLVER_MUE_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_MUE = _casadi_core.STABILIZED_QP_SOLVER_MUE

_casadi_core.STABILIZED_QP_SOLVER_MU_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_MU = _casadi_core.STABILIZED_QP_SOLVER_MU

_casadi_core.STABILIZED_QP_SOLVER_NUM_IN_swigconstant(_casadi_core)
STABILIZED_QP_SOLVER_NUM_IN = _casadi_core.STABILIZED_QP_SOLVER_NUM_IN
class StabilizedQpSolver(Function):
    """


    StabilizedQpSolver.

    Solves the following strictly convex problem:



    ::

      min          1/2 x' H x + g' x
      x

      subject to
      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with :
      H sparse (n x n) positive definite
      g dense  (n x 1)

      n: number of decision variables (x)
      nc: number of constraints (A)



    If H is not positive-definite, the solver should throw an error.

    General information
    ===================



    >Input scheme: casadi::StabilizedQpSolverInput (STABILIZED_QP_SOLVER_NUM_IN = 12) [stabilizedQpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | STABILIZED_QP_SOLVER_H | h                      | The square matrix H:   |
    |                        |                        | sparse, (n x n). Only  |
    |                        |                        | the lower triangular   |
    |                        |                        | part is actually used. |
    |                        |                        | The matrix is assumed  |
    |                        |                        | to be symmetrical.     |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_G | g                      | The vector g: dense,   |
    |                        |                        | (n x 1) .              |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_A | a                      | The matrix A: sparse,  |
    |                        |                        | (nc x n) - product     |
    |                        |                        | with x must be dense.  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_L | lba                    | dense, (nc x 1)        |
    | BA                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_U | uba                    | dense, (nc x 1)        |
    | BA                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_L | lbx                    | dense, (n x 1)         |
    | BX                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_U | ubx                    | dense, (n x 1)         |
    | BX                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_X | x0                     | dense, (n x 1)         |
    | 0                      |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_L | lam_x0                 | dense                  |
    | AM_X0                  |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_M | muR                    | dense (1 x 1)          |
    | UR                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_M | muE                    | dense (nc x 1)         |
    | UE                     |                        |                        |
    +------------------------+------------------------+------------------------+
    | STABILIZED_QP_SOLVER_M | mu                     | dense (nc x 1)         |
    | U                      |                        |                        |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::QpSolverOutput (QP_SOLVER_NUM_OUT = 4) [qpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QP_SOLVER_X            | x                      | The primal solution .  |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_COST         | cost                   | The optimal cost .     |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LAM_A        | lam_a                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | linear bounds .        |
    +------------------------+------------------------+------------------------+
    | QP_SOLVER_LAM_X        | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds .        |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_StabilizedQpSolver_sqic'>sqic</a>

    - <a href='#plugin_StabilizedQpSolver_qp'>qp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    StabilizedQpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    sqic
    ----



    Interface to SQIC

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    qp --



    Solved a stabilized QP using a standard QP solver

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | qp_solver       | OT_STRING       | GenericType()   | The QP solver   |
    |                 |                 |                 | used to solve   |
    |                 |                 |                 | the stabilized  |
    |                 |                 |                 | QPs.            |
    +-----------------+-----------------+-----------------+-----------------+
    | qp_solver_optio | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ns              |                 |                 | passed to the   |
    |                 |                 |                 | QP solver       |
    |                 |                 |                 | instance        |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available stats

    +-----------------+
    |       Id        |
    +=================+
    | qp_solver_stats |
    +-----------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: stabilized_qp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StabilizedQpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StabilizedQpSolver, name)
    __repr__ = _swig_repr

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.StabilizedQpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.StabilizedQpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.StabilizedQpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def setLPOptions(self, *args):
        """
        setLPOptions(StabilizedQpSolver self)



        Set options that make the QP solver more suitable for solving LPs.


        """
        return _casadi_core.StabilizedQpSolver_setLPOptions(self, *args)


    def generateNativeCode(self, *args):
        """
        generateNativeCode(StabilizedQpSolver self, std::string const & filename)



        Generate native code in the interfaced language for debugging


        """
        return _casadi_core.StabilizedQpSolver_generateNativeCode(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.StabilizedQpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::StabilizedQpSolver self) -> StabilizedQpSolver
        __init__(casadi::StabilizedQpSolver self, std::string const & name, QPStructure st) -> StabilizedQpSolver
        __init__(casadi::StabilizedQpSolver self, StabilizedQpSolver other) -> StabilizedQpSolver



        >  casadi::StabilizedQpSolver::StabilizedQpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::StabilizedQpSolver::StabilizedQpSolver(const std::string &name, const QPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_StabilizedQpSolver_sqic'>sqic</a>

        - <a href='#plugin_StabilizedQpSolver_qp'>qp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        StabilizedQpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:  Problem structure

        >Struct scheme: casadi::QPStruct ( = 2) [qpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | QP_STRUCT_H            | h                      | The square matrix H:   |
        |                        |                        | sparse, (n x n). Only  |
        |                        |                        | the lower triangular   |
        |                        |                        | part is actually used. |
        |                        |                        | The matrix is assumed  |
        |                        |                        | to be symmetrical.     |
        +------------------------+------------------------+------------------------+
        | QP_STRUCT_A            | a                      | The matrix A: sparse,  |
        |                        |                        | (nc x n) - product     |
        |                        |                        | with x must be dense.  |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_StabilizedQpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_StabilizedQpSolver
StabilizedQpSolver_swigregister = _casadi_core.StabilizedQpSolver_swigregister
StabilizedQpSolver_swigregister(StabilizedQpSolver)

def StabilizedQpSolver_hasPlugin(*args):
    """StabilizedQpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.StabilizedQpSolver_hasPlugin(*args)

def StabilizedQpSolver_loadPlugin(*args):
    """StabilizedQpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.StabilizedQpSolver_loadPlugin(*args)

def StabilizedQpSolver_doc(*args):
    """StabilizedQpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.StabilizedQpSolver_doc(*args)

def StabilizedQpSolver_testCast(*args):
    """StabilizedQpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.StabilizedQpSolver_testCast(*args)


_casadi_core.LP_SOLVER_C_swigconstant(_casadi_core)
LP_SOLVER_C = _casadi_core.LP_SOLVER_C

_casadi_core.LP_SOLVER_A_swigconstant(_casadi_core)
LP_SOLVER_A = _casadi_core.LP_SOLVER_A

_casadi_core.LP_SOLVER_LBA_swigconstant(_casadi_core)
LP_SOLVER_LBA = _casadi_core.LP_SOLVER_LBA

_casadi_core.LP_SOLVER_UBA_swigconstant(_casadi_core)
LP_SOLVER_UBA = _casadi_core.LP_SOLVER_UBA

_casadi_core.LP_SOLVER_LBX_swigconstant(_casadi_core)
LP_SOLVER_LBX = _casadi_core.LP_SOLVER_LBX

_casadi_core.LP_SOLVER_UBX_swigconstant(_casadi_core)
LP_SOLVER_UBX = _casadi_core.LP_SOLVER_UBX

_casadi_core.LP_SOLVER_NUM_IN_swigconstant(_casadi_core)
LP_SOLVER_NUM_IN = _casadi_core.LP_SOLVER_NUM_IN

_casadi_core.LP_SOLVER_X_swigconstant(_casadi_core)
LP_SOLVER_X = _casadi_core.LP_SOLVER_X

_casadi_core.LP_SOLVER_COST_swigconstant(_casadi_core)
LP_SOLVER_COST = _casadi_core.LP_SOLVER_COST

_casadi_core.LP_SOLVER_LAM_A_swigconstant(_casadi_core)
LP_SOLVER_LAM_A = _casadi_core.LP_SOLVER_LAM_A

_casadi_core.LP_SOLVER_LAM_X_swigconstant(_casadi_core)
LP_SOLVER_LAM_X = _casadi_core.LP_SOLVER_LAM_X

_casadi_core.LP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
LP_SOLVER_NUM_OUT = _casadi_core.LP_SOLVER_NUM_OUT

_casadi_core.LP_STRUCT_A_swigconstant(_casadi_core)
LP_STRUCT_A = _casadi_core.LP_STRUCT_A

_casadi_core.LP_STRUCT_NUM_swigconstant(_casadi_core)
LP_STRUCT_NUM = _casadi_core.LP_STRUCT_NUM
class LpSolver(Function):
    """


    LpSolver.

    Solves the following linear problem:



    ::

      min          c' x
      x

      subject to
      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with x ( n x 1)
      c ( n x 1 )
      A sparse matrix ( nc x n)
      LBA, UBA dense vector (nc x 1)
      LBX, UBX dense vector (n x 1)

      n: number of decision variables (x)
      nc: number of constraints (A)



    General information
    ===================



    >Input scheme: casadi::LpSolverInput (LP_SOLVER_NUM_IN = 6) [lpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | LP_SOLVER_C            | c                      | The vector c: dense (n |
    |                        |                        | x 1) .                 |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_A            | a                      | The matrix A: sparse,  |
    |                        |                        | (nc x n) - product     |
    |                        |                        | with x must be dense.  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_LBA          | lba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_UBA          | uba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_LBX          | lbx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_UBX          | ubx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::LpSolverOutput (LP_SOLVER_NUM_OUT = 4) [lpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | LP_SOLVER_X            | x                      | The primal solution .  |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_COST         | cost                   | The optimal cost .     |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_LAM_A        | lam_a                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | linear bounds .        |
    +------------------------+------------------------+------------------------+
    | LP_SOLVER_LAM_X        | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds .        |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_LpSolver_qp'>qp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    LpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    qp --



    Solve LPs using a QpSolver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +-----------------+
    |       Id        |
    +=================+
    | qp_solver_stats |
    +-----------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: lp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LpSolver, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.LpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.LpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.LpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.LpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::LpSolver self) -> LpSolver
        __init__(casadi::LpSolver self, std::string const & name, LPStructure st) -> LpSolver
        __init__(casadi::LpSolver self, LpSolver other) -> LpSolver



        >  casadi::LpSolver::LpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::LpSolver::LpSolver(const std::string &name, const LPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_LpSolver_qp'>qp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        LpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::LPStruct ( = 1) [lpStruct]

        +-------------+-------+------------------------+
        |  Full name  | Short |      Description       |
        +=============+=======+========================+
        | LP_STRUCT_A | a     | The matrix A: sparse . |
        +-------------+-------+------------------------+


        """
        this = _casadi_core.new_LpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LpSolver
LpSolver_swigregister = _casadi_core.LpSolver_swigregister
LpSolver_swigregister(LpSolver)

def LpSolver_testCast(*args):
    """LpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.LpSolver_testCast(*args)

def LpSolver_hasPlugin(*args):
    """LpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.LpSolver_hasPlugin(*args)

def LpSolver_loadPlugin(*args):
    """LpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.LpSolver_loadPlugin(*args)

def LpSolver_doc(*args):
    """LpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.LpSolver_doc(*args)


_casadi_core.SDP_SOLVER_F_swigconstant(_casadi_core)
SDP_SOLVER_F = _casadi_core.SDP_SOLVER_F

_casadi_core.SDP_SOLVER_C_swigconstant(_casadi_core)
SDP_SOLVER_C = _casadi_core.SDP_SOLVER_C

_casadi_core.SDP_SOLVER_G_swigconstant(_casadi_core)
SDP_SOLVER_G = _casadi_core.SDP_SOLVER_G

_casadi_core.SDP_SOLVER_A_swigconstant(_casadi_core)
SDP_SOLVER_A = _casadi_core.SDP_SOLVER_A

_casadi_core.SDP_SOLVER_LBA_swigconstant(_casadi_core)
SDP_SOLVER_LBA = _casadi_core.SDP_SOLVER_LBA

_casadi_core.SDP_SOLVER_UBA_swigconstant(_casadi_core)
SDP_SOLVER_UBA = _casadi_core.SDP_SOLVER_UBA

_casadi_core.SDP_SOLVER_LBX_swigconstant(_casadi_core)
SDP_SOLVER_LBX = _casadi_core.SDP_SOLVER_LBX

_casadi_core.SDP_SOLVER_UBX_swigconstant(_casadi_core)
SDP_SOLVER_UBX = _casadi_core.SDP_SOLVER_UBX

_casadi_core.SDP_SOLVER_NUM_IN_swigconstant(_casadi_core)
SDP_SOLVER_NUM_IN = _casadi_core.SDP_SOLVER_NUM_IN

_casadi_core.SDP_SOLVER_X_swigconstant(_casadi_core)
SDP_SOLVER_X = _casadi_core.SDP_SOLVER_X

_casadi_core.SDP_SOLVER_P_swigconstant(_casadi_core)
SDP_SOLVER_P = _casadi_core.SDP_SOLVER_P

_casadi_core.SDP_SOLVER_DUAL_swigconstant(_casadi_core)
SDP_SOLVER_DUAL = _casadi_core.SDP_SOLVER_DUAL

_casadi_core.SDP_SOLVER_COST_swigconstant(_casadi_core)
SDP_SOLVER_COST = _casadi_core.SDP_SOLVER_COST

_casadi_core.SDP_SOLVER_DUAL_COST_swigconstant(_casadi_core)
SDP_SOLVER_DUAL_COST = _casadi_core.SDP_SOLVER_DUAL_COST

_casadi_core.SDP_SOLVER_LAM_A_swigconstant(_casadi_core)
SDP_SOLVER_LAM_A = _casadi_core.SDP_SOLVER_LAM_A

_casadi_core.SDP_SOLVER_LAM_X_swigconstant(_casadi_core)
SDP_SOLVER_LAM_X = _casadi_core.SDP_SOLVER_LAM_X

_casadi_core.SDP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
SDP_SOLVER_NUM_OUT = _casadi_core.SDP_SOLVER_NUM_OUT

_casadi_core.SDP_STRUCT_F_swigconstant(_casadi_core)
SDP_STRUCT_F = _casadi_core.SDP_STRUCT_F

_casadi_core.SDP_STRUCT_G_swigconstant(_casadi_core)
SDP_STRUCT_G = _casadi_core.SDP_STRUCT_G

_casadi_core.SDP_STRUCT_A_swigconstant(_casadi_core)
SDP_STRUCT_A = _casadi_core.SDP_STRUCT_A

_casadi_core.SDP_STRUCT_NUM_swigconstant(_casadi_core)
SDP_STRUCT_NUM = _casadi_core.SDP_STRUCT_NUM
class SdpSolver(Function):
    """


    SdpSolver.

    Solves an SDP problem in standard form.
    Seehttp://sdpa.indsys.chuo-u.ac.jp/sdpa/files/sdpa-c.6.2.0.manual.pdf

    Primal:



    ::

      min          c' x
      x
      subject to
      P = Sum_i^m F_i x_i - G
      P negative semidefinite

      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with x ( n x 1)
      c ( n x 1 )
      G, F_i  sparse symmetric (m x m)
      X dense symmetric ( m x m )
      A sparse matrix ( nc x n)
      LBA, UBA dense vector (nc x 1)
      LBX, UBX dense vector (n x 1)



    This formulation is chosen as primal, because it does not call for a large
    decision variable space.

    Dual:



    ::

      max          trace(G Y)
      Y

      subject to
      trace(F_i Y) = c_i
      Y positive semidefinite

      with Y dense symmetric ( m x m)



    On generality: you might have formulation with block partitioning:

    Primal:



    ::

      min          c' x
      x
      subject to
      Pj = Sum_i^m F_ij x_i - gj   for all j
      Pj negative semidefinite   for all j

      with x ( n x 1)
      c ( n x 1 )
      G, F_i  sparse symmetric (m x m)
      X dense symmetric ( m x m )



    Dual:

    ::

      max          Sum_j trace(Gj Yj)
      Yj

      subject to
      Sum_j trace(F_ij Yj) = c_i   for all j
      Yj positive semidefinite     for all j

      with Y dense symmetric ( m x m)



    You can cast this into the standard form with: G = blkdiag(Gj for all j) Fi
    = blkdiag(F_ij for all j)

    Implementations of SdpSolver are encouraged to exploit this block structure.

    General information
    ===================



    >Input scheme: casadi::SDPInput (SDP_SOLVER_NUM_IN = 8) [sdpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SDP_SOLVER_F           | f                      | The horizontal stack   |
    |                        |                        | of all matrices F_i: ( |
    |                        |                        | m x nm) .              |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_C           | c                      | The vector c: ( n x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_G           | g                      | The matrix G: ( m x m) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_A           | a                      | The matrix A: ( nc x   |
    |                        |                        | n) .                   |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_LBA         | lba                    | Lower bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_UBA         | uba                    | Upper bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_LBX         | lbx                    | Lower bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_UBX         | ubx                    | Upper bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::SDPOutput (SDP_SOLVER_NUM_OUT = 7) [sdpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SDP_SOLVER_X           | x                      | The primal solution (n |
    |                        |                        | x 1) - may be used as  |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_P           | p                      | The solution P (m x m) |
    |                        |                        | - may be used as       |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_DUAL        | dual                   | The dual solution (m x |
    |                        |                        | m) - may be used as    |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_COST        | cost                   | The primal optimal     |
    |                        |                        | cost (1 x 1) .         |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_DUAL_COST   | dual_cost              | The dual optimal cost  |
    |                        |                        | (1 x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_LAM_A       | lam_a                  | The dual solution      |
    |                        |                        | corresponding to the   |
    |                        |                        | linear constraints (nc |
    |                        |                        | x 1) .                 |
    +------------------------+------------------------+------------------------+
    | SDP_SOLVER_LAM_X       | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds (n x 1)  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | calc_dual    | OT_BOOLEAN   | true         | Indicate if  | casadi::SdpS |
    |              |              |              | dual should  | olverInterna |
    |              |              |              | be allocated | l            |
    |              |              |              | and          |              |
    |              |              |              | calculated.  |              |
    |              |              |              | You may want |              |
    |              |              |              | to avoid     |              |
    |              |              |              | calculating  |              |
    |              |              |              | this         |              |
    |              |              |              | variable for |              |
    |              |              |              | problems     |              |
    |              |              |              | with n       |              |
    |              |              |              | large, as is |              |
    |              |              |              | always dense |              |
    |              |              |              | (m x m).     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | calc_p       | OT_BOOLEAN   | true         | Indicate if  | casadi::SdpS |
    |              |              |              | the P-part   | olverInterna |
    |              |              |              | of primal    | l            |
    |              |              |              | solution     |              |
    |              |              |              | should be    |              |
    |              |              |              | allocated    |              |
    |              |              |              | and          |              |
    |              |              |              | calculated.  |              |
    |              |              |              | You may want |              |
    |              |              |              | to avoid     |              |
    |              |              |              | calculating  |              |
    |              |              |              | this         |              |
    |              |              |              | variable for |              |
    |              |              |              | problems     |              |
    |              |              |              | with n       |              |
    |              |              |              | large, as is |              |
    |              |              |              | always dense |              |
    |              |              |              | (m x m).     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | print_proble | OT_BOOLEAN   | false        | Print out    | casadi::SdpS |
    | m            |              |              | problem      | olverInterna |
    |              |              |              | statement    | l            |
    |              |              |              | for          |              |
    |              |              |              | debugging.   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_SdpSolver_dsdp'>dsdp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    SdpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    dsdp
    ----



    Interface to the SDP solver DSDP Warning: The solver DSDP is not good at
    handling linear equalities. There are several options if you notice
    difficulties: play around with the parameter "_penalty" leave a gap
    manually switch to another SDP Solver

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | _loglevel       | OT_INTEGER      | 0               | An integer that |
    |                 |                 |                 | specifies how   |
    |                 |                 |                 | much logging is |
    |                 |                 |                 | done on stdout. |
    +-----------------+-----------------+-----------------+-----------------+
    | _penalty        | OT_REAL         | 100000          | Penality        |
    |                 |                 |                 | parameter       |
    |                 |                 |                 | lambda. Must    |
    |                 |                 |                 | exceed the      |
    |                 |                 |                 | trace of Y.     |
    |                 |                 |                 | This parameter  |
    |                 |                 |                 | heavily         |
    |                 |                 |                 | influences the  |
    |                 |                 |                 | ability of DSDP |
    |                 |                 |                 | to treat linear |
    |                 |                 |                 | equalities. The |
    |                 |                 |                 | DSDP standard   |
    |                 |                 |                 | default (1e8)   |
    |                 |                 |                 | will make a     |
    |                 |                 |                 | problem with    |
    |                 |                 |                 | linear equality |
    |                 |                 |                 | return unusable |
    |                 |                 |                 | solutions.      |
    +-----------------+-----------------+-----------------+-----------------+
    | _printlevel     | OT_INTEGER      | 1               | A printlevel of |
    |                 |                 |                 | zero will       |
    |                 |                 |                 | disable all     |
    |                 |                 |                 | output. Another |
    |                 |                 |                 | number          |
    |                 |                 |                 | indicates how   |
    |                 |                 |                 | often a line is |
    |                 |                 |                 | printed.        |
    +-----------------+-----------------+-----------------+-----------------+
    | _reuse          | OT_INTEGER      | 4               | Maximum on the  |
    |                 |                 |                 | number of times |
    |                 |                 |                 | the Schur       |
    |                 |                 |                 | complement      |
    |                 |                 |                 | matrix is       |
    |                 |                 |                 | reused          |
    +-----------------+-----------------+-----------------+-----------------+
    | _rho            | OT_REAL         | 4               | Potential       |
    |                 |                 |                 | parameter. Must |
    |                 |                 |                 | be >=1          |
    +-----------------+-----------------+-----------------+-----------------+
    | _use_penalty    | OT_BOOLEAN      | true            | Modifies the    |
    |                 |                 |                 | algorithm to    |
    |                 |                 |                 | use a penality  |
    |                 |                 |                 | gamma on r.     |
    +-----------------+-----------------+-----------------+-----------------+
    | _zbar           | OT_REAL         | 1.000e+10       | Initial upper   |
    |                 |                 |                 | bound on the    |
    |                 |                 |                 | objective of    |
    |                 |                 |                 | the dual        |
    |                 |                 |                 | problem.        |
    +-----------------+-----------------+-----------------+-----------------+
    | dualTol         | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | dual            |
    |                 |                 |                 | infeasibility   |
    |                 |                 |                 | (translates to  |
    |                 |                 |                 | primal          |
    |                 |                 |                 | infeasibility   |
    |                 |                 |                 | in dsdp terms)  |
    +-----------------+-----------------+-----------------+-----------------+
    | gapTol          | OT_REAL         | 0.000           | Convergence     |
    |                 |                 |                 | criterion based |
    |                 |                 |                 | on distance     |
    |                 |                 |                 | between primal  |
    |                 |                 |                 | and dual        |
    |                 |                 |                 | objective       |
    +-----------------+-----------------+-----------------+-----------------+
    | inf             | OT_REAL         | 1.000e+30       | Treat numbers   |
    |                 |                 |                 | higher than     |
    |                 |                 |                 | this as         |
    |                 |                 |                 | infinity        |
    +-----------------+-----------------+-----------------+-----------------+
    | maxIter         | OT_INTEGER      | 500             | Maximum number  |
    |                 |                 |                 | of iterations   |
    +-----------------+-----------------+-----------------+-----------------+
    | primalTol       | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | primal          |
    |                 |                 |                 | infeasibility   |
    |                 |                 |                 | (translates to  |
    |                 |                 |                 | dual            |
    |                 |                 |                 | infeasibility   |
    |                 |                 |                 | in dsdp terms)  |
    +-----------------+-----------------+-----------------+-----------------+
    | stepTol         | OT_REAL         | 0.050           | Terminate the   |
    |                 |                 |                 | solver if the   |
    |                 |                 |                 | step length in  |
    |                 |                 |                 | the primal is   |
    |                 |                 |                 | below this      |
    |                 |                 |                 | tolerance.      |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available stats

    +--------------------+
    |         Id         |
    +====================+
    | solution_type      |
    +--------------------+
    | termination_reason |
    +--------------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: sdp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SdpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SdpSolver, name)
    __repr__ = _swig_repr

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.SdpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.SdpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.SdpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def setSOCPOptions(self, *args):
        """
        setSOCPOptions(SdpSolver self)



        Set options that make the SDP solver more suitable for solving SOCPs.


        """
        return _casadi_core.SdpSolver_setSOCPOptions(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.SdpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::SdpSolver self) -> SdpSolver
        __init__(casadi::SdpSolver self, std::string const & name, SDPStructure st) -> SdpSolver
        __init__(casadi::SdpSolver self, SdpSolver other) -> SdpSolver



        >  casadi::SdpSolver::SdpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::SdpSolver::SdpSolver(const std::string &name, const SDPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_SdpSolver_dsdp'>dsdp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        SdpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::SDPStruct ( = 3) [sdpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | SDP_STRUCT_F           | f                      | The horizontal stack   |
        |                        |                        | of all matrices F_i: ( |
        |                        |                        | m x nm) .              |
        +------------------------+------------------------+------------------------+
        | SDP_STRUCT_G           | g                      | The matrix G: ( m x m) |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+
        | SDP_STRUCT_A           | a                      | The matrix A: ( nc x   |
        |                        |                        | n) .                   |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_SdpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SdpSolver
SdpSolver_swigregister = _casadi_core.SdpSolver_swigregister
SdpSolver_swigregister(SdpSolver)

def SdpSolver_hasPlugin(*args):
    """SdpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.SdpSolver_hasPlugin(*args)

def SdpSolver_loadPlugin(*args):
    """SdpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.SdpSolver_loadPlugin(*args)

def SdpSolver_doc(*args):
    """SdpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.SdpSolver_doc(*args)

def SdpSolver_testCast(*args):
    """SdpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.SdpSolver_testCast(*args)


_casadi_core.SOCP_SOLVER_G_swigconstant(_casadi_core)
SOCP_SOLVER_G = _casadi_core.SOCP_SOLVER_G

_casadi_core.SOCP_SOLVER_H_swigconstant(_casadi_core)
SOCP_SOLVER_H = _casadi_core.SOCP_SOLVER_H

_casadi_core.SOCP_SOLVER_E_swigconstant(_casadi_core)
SOCP_SOLVER_E = _casadi_core.SOCP_SOLVER_E

_casadi_core.SOCP_SOLVER_F_swigconstant(_casadi_core)
SOCP_SOLVER_F = _casadi_core.SOCP_SOLVER_F

_casadi_core.SOCP_SOLVER_C_swigconstant(_casadi_core)
SOCP_SOLVER_C = _casadi_core.SOCP_SOLVER_C

_casadi_core.SOCP_SOLVER_A_swigconstant(_casadi_core)
SOCP_SOLVER_A = _casadi_core.SOCP_SOLVER_A

_casadi_core.SOCP_SOLVER_LBA_swigconstant(_casadi_core)
SOCP_SOLVER_LBA = _casadi_core.SOCP_SOLVER_LBA

_casadi_core.SOCP_SOLVER_UBA_swigconstant(_casadi_core)
SOCP_SOLVER_UBA = _casadi_core.SOCP_SOLVER_UBA

_casadi_core.SOCP_SOLVER_LBX_swigconstant(_casadi_core)
SOCP_SOLVER_LBX = _casadi_core.SOCP_SOLVER_LBX

_casadi_core.SOCP_SOLVER_UBX_swigconstant(_casadi_core)
SOCP_SOLVER_UBX = _casadi_core.SOCP_SOLVER_UBX

_casadi_core.SOCP_SOLVER_NUM_IN_swigconstant(_casadi_core)
SOCP_SOLVER_NUM_IN = _casadi_core.SOCP_SOLVER_NUM_IN

_casadi_core.SOCP_SOLVER_X_swigconstant(_casadi_core)
SOCP_SOLVER_X = _casadi_core.SOCP_SOLVER_X

_casadi_core.SOCP_SOLVER_COST_swigconstant(_casadi_core)
SOCP_SOLVER_COST = _casadi_core.SOCP_SOLVER_COST

_casadi_core.SOCP_SOLVER_LAM_A_swigconstant(_casadi_core)
SOCP_SOLVER_LAM_A = _casadi_core.SOCP_SOLVER_LAM_A

_casadi_core.SOCP_SOLVER_LAM_X_swigconstant(_casadi_core)
SOCP_SOLVER_LAM_X = _casadi_core.SOCP_SOLVER_LAM_X

_casadi_core.SOCP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
SOCP_SOLVER_NUM_OUT = _casadi_core.SOCP_SOLVER_NUM_OUT

_casadi_core.SOCP_STRUCT_G_swigconstant(_casadi_core)
SOCP_STRUCT_G = _casadi_core.SOCP_STRUCT_G

_casadi_core.SOCP_STRUCT_A_swigconstant(_casadi_core)
SOCP_STRUCT_A = _casadi_core.SOCP_STRUCT_A

_casadi_core.SOCP_STRUCT_NUM_swigconstant(_casadi_core)
SOCP_STRUCT_NUM = _casadi_core.SOCP_STRUCT_NUM
class SocpSolver(Function):
    """


    SocpSolver.

    Solves an Second Order Cone Programming (SOCP) problem in standard form.

    Primal:



    ::

      min          c' x
      x
      subject to
      || Gi' x + hi ||_2 <= ei' x + fi  i = 1..m

      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with x ( n x 1)
      c ( n x 1 )
      Gi  sparse (n x ni)
      hi  dense (ni x 1)
      ei  dense (n x 1)
      fi  dense (1 x 1)
      N = Sum_i^m ni
      A sparse (nc x n)
      LBA, UBA dense vector (nc x 1)
      LBX, UBX dense vector (n x 1)



    General information
    ===================



    >Input scheme: casadi::SOCPInput (SOCP_SOLVER_NUM_IN = 10) [socpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SOCP_SOLVER_G          | g                      | The horizontal stack   |
    |                        |                        | of all matrices Gi: (  |
    |                        |                        | n x N) .               |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_H          | h                      | The vertical stack of  |
    |                        |                        | all vectors hi: ( N x  |
    |                        |                        | 1) .                   |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_E          | e                      | The vertical stack of  |
    |                        |                        | all vectors ei: ( nm x |
    |                        |                        | 1) .                   |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_F          | f                      | The vertical stack of  |
    |                        |                        | all scalars fi: ( m x  |
    |                        |                        | 1) .                   |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_C          | c                      | The vector c: ( n x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_A          | a                      | The matrix A: ( nc x   |
    |                        |                        | n) .                   |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_LBA        | lba                    | Lower bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_UBA        | uba                    | Upper bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_LBX        | lbx                    | Lower bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_UBX        | ubx                    | Upper bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::SOCPOutput (SOCP_SOLVER_NUM_OUT = 4) [socpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SOCP_SOLVER_X          | x                      | The primal solution (n |
    |                        |                        | x 1) .                 |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_COST       | cost                   | The primal optimal     |
    |                        |                        | cost (1 x 1) .         |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_LAM_A      | lam_a                  | The dual solution      |
    |                        |                        | corresponding to the   |
    |                        |                        | linear constraints (nc |
    |                        |                        | x 1) .                 |
    +------------------------+------------------------+------------------------+
    | SOCP_SOLVER_LAM_X      | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds (n x 1)  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | ni           | OT_INTEGERVE | GenericType( | Provide the  | casadi::Socp |
    |              | CTOR         | )            | size of each | SolverIntern |
    |              |              |              | SOC          | al           |
    |              |              |              | constraint.  |              |
    |              |              |              | Must sum up  |              |
    |              |              |              | to N.        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | print_proble | OT_BOOLEAN   | false        | Print out    | casadi::Socp |
    | m            |              |              | problem      | SolverIntern |
    |              |              |              | statement    | al           |
    |              |              |              | for          |              |
    |              |              |              | debugging.   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_SocpSolver_sdp'>sdp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    SocpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    sdp
    ---



    Solve SOCPs using an SdpSolver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +------------------+
    |        Id        |
    +==================+
    | sdp_solver_stats |
    +------------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: socp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SocpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SocpSolver, name)
    __repr__ = _swig_repr

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.SocpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.SocpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.SocpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.SocpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::SocpSolver self) -> SocpSolver
        __init__(casadi::SocpSolver self, std::string const & name, SOCPStructure st) -> SocpSolver
        __init__(casadi::SocpSolver self, SocpSolver other) -> SocpSolver



        >  casadi::SocpSolver::SocpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::SocpSolver::SocpSolver(const std::string &name, const SOCPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_SocpSolver_sdp'>sdp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        SocpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::SOCPStruct ( = 2) [socpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | SOCP_STRUCT_G          | g                      | The horizontal stack   |
        |                        |                        | of all matrices Gi: (  |
        |                        |                        | n x N) .               |
        +------------------------+------------------------+------------------------+
        | SOCP_STRUCT_A          | a                      | The matrix A: ( nc x   |
        |                        |                        | n) .                   |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_SocpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SocpSolver
SocpSolver_swigregister = _casadi_core.SocpSolver_swigregister
SocpSolver_swigregister(SocpSolver)

def SocpSolver_hasPlugin(*args):
    """SocpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.SocpSolver_hasPlugin(*args)

def SocpSolver_loadPlugin(*args):
    """SocpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.SocpSolver_loadPlugin(*args)

def SocpSolver_doc(*args):
    """SocpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.SocpSolver_doc(*args)

def SocpSolver_testCast(*args):
    """SocpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.SocpSolver_testCast(*args)


_casadi_core.QCQP_SOLVER_H_swigconstant(_casadi_core)
QCQP_SOLVER_H = _casadi_core.QCQP_SOLVER_H

_casadi_core.QCQP_SOLVER_G_swigconstant(_casadi_core)
QCQP_SOLVER_G = _casadi_core.QCQP_SOLVER_G

_casadi_core.QCQP_SOLVER_P_swigconstant(_casadi_core)
QCQP_SOLVER_P = _casadi_core.QCQP_SOLVER_P

_casadi_core.QCQP_SOLVER_Q_swigconstant(_casadi_core)
QCQP_SOLVER_Q = _casadi_core.QCQP_SOLVER_Q

_casadi_core.QCQP_SOLVER_R_swigconstant(_casadi_core)
QCQP_SOLVER_R = _casadi_core.QCQP_SOLVER_R

_casadi_core.QCQP_SOLVER_A_swigconstant(_casadi_core)
QCQP_SOLVER_A = _casadi_core.QCQP_SOLVER_A

_casadi_core.QCQP_SOLVER_LBA_swigconstant(_casadi_core)
QCQP_SOLVER_LBA = _casadi_core.QCQP_SOLVER_LBA

_casadi_core.QCQP_SOLVER_UBA_swigconstant(_casadi_core)
QCQP_SOLVER_UBA = _casadi_core.QCQP_SOLVER_UBA

_casadi_core.QCQP_SOLVER_LBX_swigconstant(_casadi_core)
QCQP_SOLVER_LBX = _casadi_core.QCQP_SOLVER_LBX

_casadi_core.QCQP_SOLVER_UBX_swigconstant(_casadi_core)
QCQP_SOLVER_UBX = _casadi_core.QCQP_SOLVER_UBX

_casadi_core.QCQP_SOLVER_X0_swigconstant(_casadi_core)
QCQP_SOLVER_X0 = _casadi_core.QCQP_SOLVER_X0

_casadi_core.QCQP_SOLVER_LAM_X0_swigconstant(_casadi_core)
QCQP_SOLVER_LAM_X0 = _casadi_core.QCQP_SOLVER_LAM_X0

_casadi_core.QCQP_SOLVER_NUM_IN_swigconstant(_casadi_core)
QCQP_SOLVER_NUM_IN = _casadi_core.QCQP_SOLVER_NUM_IN

_casadi_core.QCQP_SOLVER_X_swigconstant(_casadi_core)
QCQP_SOLVER_X = _casadi_core.QCQP_SOLVER_X

_casadi_core.QCQP_SOLVER_COST_swigconstant(_casadi_core)
QCQP_SOLVER_COST = _casadi_core.QCQP_SOLVER_COST

_casadi_core.QCQP_SOLVER_LAM_A_swigconstant(_casadi_core)
QCQP_SOLVER_LAM_A = _casadi_core.QCQP_SOLVER_LAM_A

_casadi_core.QCQP_SOLVER_LAM_X_swigconstant(_casadi_core)
QCQP_SOLVER_LAM_X = _casadi_core.QCQP_SOLVER_LAM_X

_casadi_core.QCQP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
QCQP_SOLVER_NUM_OUT = _casadi_core.QCQP_SOLVER_NUM_OUT

_casadi_core.QCQP_STRUCT_H_swigconstant(_casadi_core)
QCQP_STRUCT_H = _casadi_core.QCQP_STRUCT_H

_casadi_core.QCQP_STRUCT_P_swigconstant(_casadi_core)
QCQP_STRUCT_P = _casadi_core.QCQP_STRUCT_P

_casadi_core.QCQP_STRUCT_A_swigconstant(_casadi_core)
QCQP_STRUCT_A = _casadi_core.QCQP_STRUCT_A

_casadi_core.QCQP_STRUCT_NUM_swigconstant(_casadi_core)
QCQP_STRUCT_NUM = _casadi_core.QCQP_STRUCT_NUM
class QcqpSolver(Function):
    """


    QcqpSolver.

    Solves the following strictly convex problem:



    ::

      min          1/2 x' H x + g' x
      x

      subject to
      1/2 x' Pi x  +  qi' x + ri  <= 0   for i=0..nq-1
      LBA <= A x <= UBA
      LBX <= x   <= UBX

      with :
      H, Pi sparse (n x n) positive definite
      g, qi dense  (n x 1)
      ri scalar

      n: number of decision variables (x)
      nc: number of linear constraints (A)
      nq: number of quadratic constraints



    If H, Pi is not positive-definite, the solver should throw an error.

    General information
    ===================



    >Input scheme: casadi::QcqpSolverInput (QCQP_SOLVER_NUM_IN = 12) [qcqpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QCQP_SOLVER_H          | h                      | The square matrix H:   |
    |                        |                        | sparse, (n x n). Only  |
    |                        |                        | the lower triangular   |
    |                        |                        | part is actually used. |
    |                        |                        | The matrix is assumed  |
    |                        |                        | to be symmetrical.     |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_G          | g                      | The vector g: dense,   |
    |                        |                        | (n x 1) .              |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_P          | p                      | The horizontal stack   |
    |                        |                        | of all Pi. Each Pi is  |
    |                        |                        | sparse (n x n). Only   |
    |                        |                        | the lower triangular   |
    |                        |                        | part is actually used. |
    |                        |                        | The matrix is assumed  |
    |                        |                        | to be symmetrical.     |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_Q          | q                      | The vertical stack of  |
    |                        |                        | all qi: dense, (nq n x |
    |                        |                        | 1) .                   |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_R          | r                      | The vertical stack of  |
    |                        |                        | all scalars ri (nq x   |
    |                        |                        | 1) .                   |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_A          | a                      | The matrix A: sparse,  |
    |                        |                        | (nc x n) - product     |
    |                        |                        | with x must be dense.  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_LBA        | lba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_UBA        | uba                    | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_LBX        | lbx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_UBX        | ubx                    | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_X0         | x0                     | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_LAM_X0     | lam_x0                 | dense                  |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::QcqpSolverOutput (QCQP_SOLVER_NUM_OUT = 4) [qcqpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QCQP_SOLVER_X          | x                      | The primal solution .  |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_COST       | cost                   | The optimal cost .     |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_LAM_A      | lam_a                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | linear bounds .        |
    +------------------------+------------------------+------------------------+
    | QCQP_SOLVER_LAM_X      | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds .        |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_QcqpSolver_socp'>socp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    QcqpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    socp
    ----



    Solve a QCQP with an SocpSolver

    Note: this implementation relies on Cholesky decomposition: Chol(H) = L -> H
    = LL' with L lower triangular This requires Pi, H to be positive definite.
    Positive semi-definite is not sufficient. Notably, H==0 will not work.

    A better implementation would rely on matrix square root, but we need
    singular value decomposition to implement that.

    This implementation makes use of the epigraph reformulation:

    ::

      *  min f(x)
      *    x
      *
      *   min  t
      *    x, t  f(x) <= t
      * 



    This implementation makes use of the following identity:

    ::

      *  || Gx+h||_2 <= e'x + f
      *
      *  x'(G'G - ee')x + (2 h'G - 2 f e') x + h'h - f <= 0
      * 

    where we put e = [0 0 ... 1] for the quadratic constraint arising from the
    epigraph reformulation and e==0 for all other quadratic constraints.

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +-------------------+
    |        Id         |
    +===================+
    | socp_solver_stats |
    +-------------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: qcqp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QcqpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QcqpSolver, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.QcqpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.QcqpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.QcqpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.QcqpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def setQPOptions(self, *args):
        """
        setQPOptions(QcqpSolver self)



        Set options that make the QP solver more suitable for solving LPs.


        """
        return _casadi_core.QcqpSolver_setQPOptions(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::QcqpSolver self) -> QcqpSolver
        __init__(casadi::QcqpSolver self, std::string const & name, QCQPStructure st) -> QcqpSolver
        __init__(casadi::QcqpSolver self, QcqpSolver other) -> QcqpSolver



        >  casadi::QcqpSolver::QcqpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::QcqpSolver::QcqpSolver(const std::string &name, const QCQPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_QcqpSolver_socp'>socp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        QcqpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::QCQPStruct ( = 3) [qcqpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | QCQP_STRUCT_H          | h                      | The square matrix H:   |
        |                        |                        | sparse, (n x n). Only  |
        |                        |                        | the lower triangular   |
        |                        |                        | part is actually used. |
        |                        |                        | The matrix is assumed  |
        |                        |                        | to be symmetrical.     |
        +------------------------+------------------------+------------------------+
        | QCQP_STRUCT_P          | p                      | The horizontal stack   |
        |                        |                        | of all Pi. Each Pi is  |
        |                        |                        | sparse (n x n). Only   |
        |                        |                        | the lower triangular   |
        |                        |                        | part is actually used. |
        |                        |                        | The matrix is assumed  |
        |                        |                        | to be symmetrical.     |
        +------------------------+------------------------+------------------------+
        | QCQP_STRUCT_A          | a                      | The matrix A: sparse,  |
        |                        |                        | (nc x n) - product     |
        |                        |                        | with x must be dense.  |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_QcqpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_QcqpSolver
QcqpSolver_swigregister = _casadi_core.QcqpSolver_swigregister
QcqpSolver_swigregister(QcqpSolver)

def QcqpSolver_testCast(*args):
    """QcqpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.QcqpSolver_testCast(*args)

def QcqpSolver_hasPlugin(*args):
    """QcqpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.QcqpSolver_hasPlugin(*args)

def QcqpSolver_loadPlugin(*args):
    """QcqpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.QcqpSolver_loadPlugin(*args)

def QcqpSolver_doc(*args):
    """QcqpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.QcqpSolver_doc(*args)


_casadi_core.SDQP_SOLVER_H_swigconstant(_casadi_core)
SDQP_SOLVER_H = _casadi_core.SDQP_SOLVER_H

_casadi_core.SDQP_SOLVER_C_swigconstant(_casadi_core)
SDQP_SOLVER_C = _casadi_core.SDQP_SOLVER_C

_casadi_core.SDQP_SOLVER_F_swigconstant(_casadi_core)
SDQP_SOLVER_F = _casadi_core.SDQP_SOLVER_F

_casadi_core.SDQP_SOLVER_G_swigconstant(_casadi_core)
SDQP_SOLVER_G = _casadi_core.SDQP_SOLVER_G

_casadi_core.SDQP_SOLVER_A_swigconstant(_casadi_core)
SDQP_SOLVER_A = _casadi_core.SDQP_SOLVER_A

_casadi_core.SDQP_SOLVER_LBA_swigconstant(_casadi_core)
SDQP_SOLVER_LBA = _casadi_core.SDQP_SOLVER_LBA

_casadi_core.SDQP_SOLVER_UBA_swigconstant(_casadi_core)
SDQP_SOLVER_UBA = _casadi_core.SDQP_SOLVER_UBA

_casadi_core.SDQP_SOLVER_LBX_swigconstant(_casadi_core)
SDQP_SOLVER_LBX = _casadi_core.SDQP_SOLVER_LBX

_casadi_core.SDQP_SOLVER_UBX_swigconstant(_casadi_core)
SDQP_SOLVER_UBX = _casadi_core.SDQP_SOLVER_UBX

_casadi_core.SDQP_SOLVER_NUM_IN_swigconstant(_casadi_core)
SDQP_SOLVER_NUM_IN = _casadi_core.SDQP_SOLVER_NUM_IN

_casadi_core.SDQP_SOLVER_X_swigconstant(_casadi_core)
SDQP_SOLVER_X = _casadi_core.SDQP_SOLVER_X

_casadi_core.SDQP_SOLVER_P_swigconstant(_casadi_core)
SDQP_SOLVER_P = _casadi_core.SDQP_SOLVER_P

_casadi_core.SDQP_SOLVER_DUAL_swigconstant(_casadi_core)
SDQP_SOLVER_DUAL = _casadi_core.SDQP_SOLVER_DUAL

_casadi_core.SDQP_SOLVER_COST_swigconstant(_casadi_core)
SDQP_SOLVER_COST = _casadi_core.SDQP_SOLVER_COST

_casadi_core.SDQP_SOLVER_DUAL_COST_swigconstant(_casadi_core)
SDQP_SOLVER_DUAL_COST = _casadi_core.SDQP_SOLVER_DUAL_COST

_casadi_core.SDQP_SOLVER_LAM_A_swigconstant(_casadi_core)
SDQP_SOLVER_LAM_A = _casadi_core.SDQP_SOLVER_LAM_A

_casadi_core.SDQP_SOLVER_LAM_X_swigconstant(_casadi_core)
SDQP_SOLVER_LAM_X = _casadi_core.SDQP_SOLVER_LAM_X

_casadi_core.SDQP_SOLVER_NUM_OUT_swigconstant(_casadi_core)
SDQP_SOLVER_NUM_OUT = _casadi_core.SDQP_SOLVER_NUM_OUT

_casadi_core.SDQP_STRUCT_H_swigconstant(_casadi_core)
SDQP_STRUCT_H = _casadi_core.SDQP_STRUCT_H

_casadi_core.SDQP_STRUCT_F_swigconstant(_casadi_core)
SDQP_STRUCT_F = _casadi_core.SDQP_STRUCT_F

_casadi_core.SDQP_STRUCT_G_swigconstant(_casadi_core)
SDQP_STRUCT_G = _casadi_core.SDQP_STRUCT_G

_casadi_core.SDQP_STRUCT_A_swigconstant(_casadi_core)
SDQP_STRUCT_A = _casadi_core.SDQP_STRUCT_A

_casadi_core.SDQP_STRUCT_NUM_swigconstant(_casadi_core)
SDQP_STRUCT_NUM = _casadi_core.SDQP_STRUCT_NUM
class SdqpSolver(Function):
    """


    SdqpSolver.

    Same as an SdpSolver, but with a quadratic objective 1/2 x' H x

    General information
    ===================



    >Input scheme: casadi::SDQPInput (SDQP_SOLVER_NUM_IN = 9) [sdqpIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SDQP_SOLVER_H          | h                      | The matrix H: sparse ( |
    |                        |                        | n x n) .               |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_C          | c                      | The vector c: ( n x 1) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_F          | f                      | The horizontal stack   |
    |                        |                        | of all matrices F_i: ( |
    |                        |                        | m x nm) .              |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_G          | g                      | The matrix G: ( m x m) |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_A          | a                      | The matrix A: ( nc x   |
    |                        |                        | n) .                   |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_LBA        | lba                    | Lower bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_UBA        | uba                    | Upper bounds on Ax (   |
    |                        |                        | nc x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_LBX        | lbx                    | Lower bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_UBX        | ubx                    | Upper bounds on x ( n  |
    |                        |                        | x 1 ) .                |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::SDQPOutput (SDQP_SOLVER_NUM_OUT = 7) [sdqpOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | SDQP_SOLVER_X          | x                      | The primal solution (n |
    |                        |                        | x 1) - may be used as  |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_P          | p                      | The solution P (m x m) |
    |                        |                        | - may be used as       |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_DUAL       | dual                   | The dual solution (m x |
    |                        |                        | m) - may be used as    |
    |                        |                        | initial guess .        |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_COST       | cost                   | The primal optimal     |
    |                        |                        | cost (1 x 1) .         |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_DUAL_COST  | dual_cost              | The dual optimal cost  |
    |                        |                        | (1 x 1) .              |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_LAM_A      | lam_a                  | The dual solution      |
    |                        |                        | corresponding to the   |
    |                        |                        | linear constraints (nc |
    |                        |                        | x 1) .                 |
    +------------------------+------------------------+------------------------+
    | SDQP_SOLVER_LAM_X      | lam_x                  | The dual solution      |
    |                        |                        | corresponding to       |
    |                        |                        | simple bounds (n x 1)  |
    |                        |                        | .                      |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | sdp_solver   | OT_STRING    | GenericType( | The          | casadi::Sdqp |
    |              |              | )            | SdqpSolver   | SolverIntern |
    |              |              |              | used to      | al           |
    |              |              |              | solve the    |              |
    |              |              |              | SDPs.        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | sdp_solver_o | OT_DICTIONAR | GenericType( | Options to   | casadi::Sdqp |
    | ptions       | Y            | )            | be passed to | SolverIntern |
    |              |              |              | the          | al           |
    |              |              |              | SDPSOlver    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_SdqpSolver_sdp'>sdp</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    SdqpSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    sdp
    ---



    Solve an SQDP using an SdpSolver Note: this implementation relies on
    Cholesky decomposition: Chol(H) = L -> H = LL' with L lower triangular This
    requires Pi, H to be positive definite. Positive semi-definite is not
    sufficient. Notably, H==0 will not work.

    A better implementation would rely on matrix square root, but we need
    singular value decomposition to implement that.

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    >List of available stats

    +------------------+
    |        Id        |
    +==================+
    | sdp_solver_stats |
    +------------------+

    --------------------------------------------------------------------------------



    Joel Andersson

    C++ includes: sdqp_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SdqpSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SdqpSolver, name)
    __repr__ = _swig_repr

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.SdqpSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.SdqpSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.SdqpSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def setSOCQPOptions(self, *args):
        """
        setSOCQPOptions(SdqpSolver self)



        Set options that make the SDQP solver more suitable for solving SOCPs.


        """
        return _casadi_core.SdqpSolver_setSOCQPOptions(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.SdqpSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::SdqpSolver self) -> SdqpSolver
        __init__(casadi::SdqpSolver self, std::string const & name, SDQPStructure st) -> SdqpSolver
        __init__(casadi::SdqpSolver self, SdqpSolver other) -> SdqpSolver



        >  casadi::SdqpSolver::SdqpSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::SdqpSolver::SdqpSolver(const std::string &name, const SDQPStructure &st)
        ------------------------------------------------------------------------

        Constructor.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_SdqpSolver_sdp'>sdp</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        SdqpSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::SDQPStruct ( = 4) [sdqpStruct]

        +------------------------+------------------------+------------------------+
        |       Full name        |         Short          |      Description       |
        +========================+========================+========================+
        | SDQP_STRUCT_H          | h                      | The matrix H: sparse ( |
        |                        |                        | n x n) .               |
        +------------------------+------------------------+------------------------+
        | SDQP_STRUCT_F          | f                      | The horizontal stack   |
        |                        |                        | of all matrices F_i: ( |
        |                        |                        | m x nm) .              |
        +------------------------+------------------------+------------------------+
        | SDQP_STRUCT_G          | g                      | The matrix G: ( m x m) |
        |                        |                        | .                      |
        +------------------------+------------------------+------------------------+
        | SDQP_STRUCT_A          | a                      | The matrix A: ( nc x   |
        |                        |                        | n) .                   |
        +------------------------+------------------------+------------------------+


        """
        this = _casadi_core.new_SdqpSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SdqpSolver
SdqpSolver_swigregister = _casadi_core.SdqpSolver_swigregister
SdqpSolver_swigregister(SdqpSolver)

def SdqpSolver_hasPlugin(*args):
    """SdqpSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.SdqpSolver_hasPlugin(*args)

def SdqpSolver_loadPlugin(*args):
    """SdqpSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.SdqpSolver_loadPlugin(*args)

def SdqpSolver_doc(*args):
    """SdqpSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.SdqpSolver_doc(*args)

def SdqpSolver_testCast(*args):
    """SdqpSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.SdqpSolver_testCast(*args)

class ExternalFunction(Function):
    """


    Interface for a function that is not implemented by CasADi symbolics.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: external_function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExternalFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExternalFunction, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.ExternalFunction_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::ExternalFunction self) -> ExternalFunction
        __init__(casadi::ExternalFunction self, std::string const & bin_name) -> ExternalFunction
        __init__(casadi::ExternalFunction self, ExternalFunction other) -> ExternalFunction



        >  casadi::ExternalFunction::ExternalFunction()
        ------------------------------------------------------------------------

        CONSTRUCTORS:

        default constructor

        >  casadi::ExternalFunction::ExternalFunction(const std::string &bin_name)
        ------------------------------------------------------------------------

        Create an empty function.


        """
        this = _casadi_core.new_ExternalFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_ExternalFunction
ExternalFunction_swigregister = _casadi_core.ExternalFunction_swigregister
ExternalFunction_swigregister(ExternalFunction)

def ExternalFunction_testCast(*args):
    """ExternalFunction_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.ExternalFunction_testCast(*args)

class Parallelizer(Function):
    """


    Parallelizer execution of functions.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | parallelizat | OT_STRING    | "serial"     | (serial|open | casadi::Para |
    | ion          |              |              | mp|mpi)      | llelizerInte |
    |              |              |              |              | rnal         |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    >List of available stats

    +-----------------+------------------------------+
    |       Id        |           Used in            |
    +=================+==============================+
    | max_threads     | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | num_threads     | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | task_allocation | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | task_cputime    | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | task_endtime    | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | task_order      | casadi::ParallelizerInternal |
    +-----------------+------------------------------+
    | task_starttime  | casadi::ParallelizerInternal |
    +-----------------+------------------------------+

    C++ includes: parallelizer.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallelizer, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parallelizer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::Parallelizer self) -> Parallelizer
        __init__(casadi::Parallelizer self, FunctionVector funcs) -> Parallelizer
        __init__(casadi::Parallelizer self, Parallelizer other) -> Parallelizer



        >  casadi::Parallelizer::Parallelizer()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::Parallelizer::Parallelizer(const std::vector< Function > &funcs)
        ------------------------------------------------------------------------

        Create a Parallelizer.


        """
        this = _casadi_core.new_Parallelizer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Parallelizer
Parallelizer_swigregister = _casadi_core.Parallelizer_swigregister
Parallelizer_swigregister(Parallelizer)

class CustomFunction(Function):
    """


    Interface to a custom function.

    Joel Andersson

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: custom_function.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomFunction, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.CustomFunction_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::CustomFunction self) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomEvaluate c_fcn, SparsityVector inputscheme, SparsityVector outputscheme) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomEvaluate c_fcn, IOSchemeVectorSparsity inputscheme, SparsityVector outputscheme) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomEvaluate c_fcn, SparsityVector inputscheme, IOSchemeVectorSparsity outputscheme) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomEvaluate c_fcn, IOSchemeVectorSparsity inputscheme, IOSchemeVectorSparsity outputscheme) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomEvaluate c_fcn) -> CustomFunction
        __init__(casadi::CustomFunction self, CustomFunction other) -> CustomFunction



        >  casadi::CustomFunction::CustomFunction(const CustomEvaluate &c_fcn, const std::vector< Sparsity > &inputscheme, const std::vector< Sparsity > &outputscheme)

        >  casadi::CustomFunction::CustomFunction(const CustomEvaluate &c_fcn, const IOSchemeVector< Sparsity > &inputscheme, const std::vector< Sparsity > &outputscheme)

        >  casadi::CustomFunction::CustomFunction(const CustomEvaluate &c_fcn, const std::vector< Sparsity > &inputscheme, const IOSchemeVector< Sparsity > &outputscheme)

        >  casadi::CustomFunction::CustomFunction(const CustomEvaluate &c_fcn, const IOSchemeVector< Sparsity > &inputscheme, const IOSchemeVector< Sparsity > &outputscheme)
        ------------------------------------------------------------------------

        Create a function with input/output schemes given.

        >  casadi::CustomFunction::CustomFunction()
        ------------------------------------------------------------------------

        default constructor

        >  casadi::CustomFunction::CustomFunction(const CustomEvaluate &c_fcn)
        ------------------------------------------------------------------------

        Create a function, user sets inputs outputs manually.


        """
        this = _casadi_core.new_CustomFunction(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CustomFunction
CustomFunction_swigregister = _casadi_core.CustomFunction_swigregister
CustomFunction_swigregister(CustomFunction)

def CustomFunction_testCast(*args):
    """CustomFunction_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.CustomFunction_testCast(*args)

class Functor(SharedObject):
    """


    Functor.

    Joris Gillis

    C++ includes: functor.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [SharedObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Functor, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Functor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::Functor self) -> Functor
        __init__(casadi::Functor self, Functor other) -> Functor
        """
        this = _casadi_core.new_Functor(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Functor
Functor_swigregister = _casadi_core.Functor_swigregister
Functor_swigregister(Functor)

class DerivativeGenerator(Functor):
    """


    Derivative Generator Functor.

    In C++, supply a DerivativeGeneratorCPtr function pointer

    In python, supply a callable, annotated with derivativegenerator decorator

    C++ includes: functor.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Functor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DerivativeGenerator, name, value)
    __swig_getmethods__ = {}
    for _s in [Functor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DerivativeGenerator, name)
    __repr__ = _swig_repr

    def __call__(self, *args):
        """__call__(DerivativeGenerator self, Function fcn, int nfwd, int nadj, void * user_data) -> Function"""
        return _casadi_core.DerivativeGenerator___call__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::DerivativeGenerator self) -> DerivativeGenerator
        __init__(casadi::DerivativeGenerator self, casadi::DerivativeGeneratorCPtr ptr) -> DerivativeGenerator
        __init__(casadi::DerivativeGenerator self, DerivativeGenerator other) -> DerivativeGenerator



        >  casadi::DerivativeGenerator::DerivativeGenerator()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::DerivativeGenerator::DerivativeGenerator(DerivativeGeneratorCPtr ptr)
        ------------------------------------------------------------------------

        Construct from C pointer.


        """
        this = _casadi_core.new_DerivativeGenerator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DerivativeGenerator
DerivativeGenerator_swigregister = _casadi_core.DerivativeGenerator_swigregister
DerivativeGenerator_swigregister(DerivativeGenerator)

class CustomEvaluate(Functor):
    """


    CustomEvaluate.

    In C++, supply a CustomEvaluateCPtr function pointer

    In python, supply a callable, annotated with pyevaluate decorator

    C++ includes: functor.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Functor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomEvaluate, name, value)
    __swig_getmethods__ = {}
    for _s in [Functor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomEvaluate, name)
    __repr__ = _swig_repr

    def __call__(self, *args):
        """__call__(CustomEvaluate self, CustomFunction fcn, void * user_data)"""
        return _casadi_core.CustomEvaluate___call__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::CustomEvaluate self) -> CustomEvaluate
        __init__(casadi::CustomEvaluate self, casadi::CustomEvaluateCPtr ptr) -> CustomEvaluate
        __init__(casadi::CustomEvaluate self, CustomEvaluate other) -> CustomEvaluate



        >  casadi::CustomEvaluate::CustomEvaluate()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::CustomEvaluate::CustomEvaluate(CustomEvaluateCPtr ptr)
        ------------------------------------------------------------------------

        Construct from C pointer.


        """
        this = _casadi_core.new_CustomEvaluate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CustomEvaluate
CustomEvaluate_swigregister = _casadi_core.CustomEvaluate_swigregister
CustomEvaluate_swigregister(CustomEvaluate)

class Callback(Functor):
    """


    Callback.

    In C++, supply a CallbackCPtr function pointer When the callback function
    returns a non-zero integer, the host is signalled of a problem. E.g. an
    NlpSolver may halt iterations if the Callback is something else than 0

    In python, supply a callable, annotated with pycallback decorator

    C++ includes: functor.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Functor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Callback, name, value)
    __swig_getmethods__ = {}
    for _s in [Functor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Callback, name)
    __repr__ = _swig_repr

    def __call__(self, *args):
        """__call__(Callback self, Function fcn, void * user_data) -> int"""
        return _casadi_core.Callback___call__(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::Callback self) -> Callback
        __init__(casadi::Callback self, casadi::CallbackCPtr ptr) -> Callback
        __init__(casadi::Callback self, Callback other) -> Callback



        >  casadi::Callback::Callback()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::Callback::Callback(CallbackCPtr ptr)
        ------------------------------------------------------------------------

        Construct from C pointer.


        """
        this = _casadi_core.new_Callback(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Callback
Callback_swigregister = _casadi_core.Callback_swigregister
Callback_swigregister(Callback)

class Nullspace(Function):
    """


    Base class for nullspace construction.

    Constructs a basis for the null-space of a fat matrix A. i.e. finds Z such
    that AZ = 0 holds.

    The nullspace is also known as the orthogonal complement of the rowspace of
    a matrix.

    It is assumed that the matrix A is of full rank.

    Implementations are not required to construct an orthogonal or orthonormal
    basis Joris Gillis

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | dense        | OT_BOOLEAN   | true         | Indicates    | casadi::Null |
    |              |              |              | that dense   | spaceInterna |
    |              |              |              | matrices can | l            |
    |              |              |              | be assumed   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    C++ includes: nullspace.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Nullspace, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Nullspace, name)
    __repr__ = _swig_repr

    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.Nullspace_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def __init__(self, *args):
        """
        __init__(casadi::Nullspace self) -> Nullspace
        __init__(casadi::Nullspace self, Nullspace other) -> Nullspace



        Default constructor.


        """
        this = _casadi_core.new_Nullspace(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Nullspace
Nullspace_swigregister = _casadi_core.Nullspace_swigregister
Nullspace_swigregister(Nullspace)

def Nullspace_testCast(*args):
    """Nullspace_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.Nullspace_testCast(*args)


_casadi_core.DPLE_A_swigconstant(_casadi_core)
DPLE_A = _casadi_core.DPLE_A

_casadi_core.DPLE_V_swigconstant(_casadi_core)
DPLE_V = _casadi_core.DPLE_V

_casadi_core.DPLE_NUM_IN_swigconstant(_casadi_core)
DPLE_NUM_IN = _casadi_core.DPLE_NUM_IN

_casadi_core.DPLE_P_swigconstant(_casadi_core)
DPLE_P = _casadi_core.DPLE_P

_casadi_core.DPLE_NUM_OUT_swigconstant(_casadi_core)
DPLE_NUM_OUT = _casadi_core.DPLE_NUM_OUT

_casadi_core.Dple_STRUCT_A_swigconstant(_casadi_core)
Dple_STRUCT_A = _casadi_core.Dple_STRUCT_A

_casadi_core.Dple_STRUCT_V_swigconstant(_casadi_core)
Dple_STRUCT_V = _casadi_core.Dple_STRUCT_V

_casadi_core.Dple_STRUCT_NUM_swigconstant(_casadi_core)
Dple_STRUCT_NUM = _casadi_core.Dple_STRUCT_NUM
class DpleSolver(Function):
    """


    Base class for Discrete Periodic Lyapunov Equation Solvers.

    Given matrices $A_k$ and symmetric $V_k, k = 0..K-1$



    ::

      A_k in R^(n x n)
      V_k in R^n




    provides all of $P_k$ that satisfy:



    ::

      P_0 = A_(K-1)*P_(K-1)*A_(K-1)' + V_k
      P_k+1 = A_k*P_k*A_k' + V_k  for k = 1..K-1




    General information
    ===================



    >Input scheme: casadi::DPLEInput (DPLE_NUM_IN = 2) [dpleIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | DPLE_A                 | a                      | A matrices (horzcat    |
    |                        |                        | when const_dim,        |
    |                        |                        | blkdiag otherwise) .   |
    +------------------------+------------------------+------------------------+
    | DPLE_V                 | v                      | V matrices (horzcat    |
    |                        |                        | when const_dim,        |
    |                        |                        | blkdiag otherwise) .   |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::DPLEOutput (DPLE_NUM_OUT = 1) [dpleOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | DPLE_P                 | p                      | Lyapunov matrix        |
    |                        |                        | (horzcat when          |
    |                        |                        | const_dim, blkdiag     |
    |                        |                        | otherwise) (Cholesky   |
    |                        |                        | of P if pos_def) .     |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | const_dim    | OT_BOOLEAN   | true         | Assume       | casadi::Dple |
    |              |              |              | constant     | Internal     |
    |              |              |              | dimension of |              |
    |              |              |              | P            |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eps_unstable | OT_REAL      | 0.000        | A margin for | casadi::Dple |
    |              |              |              | unstability  | Internal     |
    |              |              |              | detection    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | error_unstab | OT_BOOLEAN   | false        | Throw an     | casadi::Dple |
    | le           |              |              | exception    | Internal     |
    |              |              |              | when it is   |              |
    |              |              |              | detected     |              |
    |              |              |              | that         |              |
    |              |              |              | Product(A_i, |              |
    |              |              |              | i=N..1) has  |              |
    |              |              |              | eigenvalues  |              |
    |              |              |              | greater than |              |
    |              |              |              | 1-eps_unstab |              |
    |              |              |              | le           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | pos_def      | OT_BOOLEAN   | false        | Assume P     | casadi::Dple |
    |              |              |              | positive     | Internal     |
    |              |              |              | definite     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_DpleSolver_slicot'>slicot</a>

    - <a href='#plugin_DpleSolver_condensing'>condensing</a>

    - <a href='#plugin_DpleSolver_lifting'>lifting</a>

    - <a href='#plugin_DpleSolver_lrdple'>lrdple</a>

    - <a href='#plugin_DpleSolver_simple'>simple</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    DpleSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    slicot
    ------



    An efficient solver for Discrete Periodic Lyapunov Equations using SLICOT

    Uses Periodic Schur Decomposition ('psd') and does not assume positive
    definiteness. Based on Periodic Lyapunov equations: some applications and
    new algorithms. Int. J. Control, vol. 67, pp. 69-87, 1997.

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | linear_solver   | OT_STRING       | GenericType()   | User-defined    |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | class. Needed   |
    |                 |                 |                 | for             |
    |                 |                 |                 | sensitivities.  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+
    | psd_num_zero    | OT_REAL         | 0.000           | Numerical zero  |
    |                 |                 |                 | used in         |
    |                 |                 |                 | Periodic Schur  |
    |                 |                 |                 | decomposition   |
    |                 |                 |                 | with            |
    |                 |                 |                 | slicot.This     |
    |                 |                 |                 | option is       |
    |                 |                 |                 | needed when     |
    |                 |                 |                 | your systems    |
    |                 |                 |                 | has Floquet     |
    |                 |                 |                 | multiplierszero |
    |                 |                 |                 | or close to     |
    |                 |                 |                 | zero            |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available stats

    +----------------+
    |       Id       |
    +================+
    | t_linear_solve |
    +----------------+
    | t_psd          |
    +----------------+
    | t_total        |
    +----------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    condensing
    ----------



    Solving the Discrete Periodic Lyapunov Equations by condensing the entire
    period to a single Discrete Lyapunov Equation

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lifting
    -------



    Solving the Discrete Periodic Lyapunov Equations by lifting the entire
    period to a single Discrete Lyapunov Equation

    >List of available options

    +------+-----------+---------+-----------------------------------+
    |  Id  |   Type    | Default |            Description            |
    +======+===========+=========+===================================+
    | form | OT_STRING | "A"     | The form of the lifting (A:0|B:1) |
    +------+-----------+---------+-----------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lrdple
    ------



    Solving the Low-Rank Discrete Lyapunov Equations with a Low-Rank Discrete
    Lyapunov Equations Solver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    simple
    ------



    Solving the Discrete Periodic Lyapunov Equations with a regular LinearSolver

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | linear_solver   | OT_STRING       | GenericType()   | User-defined    |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | class. Needed   |
    |                 |                 |                 | for             |
    |                 |                 |                 | sensitivities.  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: dple_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DpleSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DpleSolver, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(DpleSolver self) -> DpleSolver



        Clone.


        """
        return _casadi_core.DpleSolver_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(DpleSolver self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.DpleSolver_printStats(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.DpleSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.DpleSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.DpleSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.DpleSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::DpleSolver self) -> DpleSolver
        __init__(casadi::DpleSolver self, std::string const & name, DpleVecStructure st) -> DpleSolver
        __init__(casadi::DpleSolver self, std::string const & name, SparsityVector A, SparsityVector V) -> DpleSolver
        __init__(casadi::DpleSolver self, DpleSolver other) -> DpleSolver



        >  casadi::DpleSolver::DpleSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::DpleSolver::DpleSolver(const std::string &name, const DpleStructure &st)
        ------------------------------------------------------------------------

        DpleSolver solver factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_DpleSolver_slicot'>slicot</a>

        - <a href='#plugin_DpleSolver_condensing'>condensing</a>

        - <a href='#plugin_DpleSolver_lifting'>lifting</a>

        - <a href='#plugin_DpleSolver_lrdple'>lrdple</a>

        - <a href='#plugin_DpleSolver_simple'>simple</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        DpleSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.

        >  casadi::DpleSolver::DpleSolver(const std::string &name, const std::vector< Sparsity > &A, const std::vector< Sparsity > &V)
        ------------------------------------------------------------------------

        Older constructor.


        """
        this = _casadi_core.new_DpleSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DpleSolver
DpleSolver_swigregister = _casadi_core.DpleSolver_swigregister
DpleSolver_swigregister(DpleSolver)

def DpleSolver_testCast(*args):
    """DpleSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.DpleSolver_testCast(*args)

def DpleSolver_hasPlugin(*args):
    """DpleSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.DpleSolver_hasPlugin(*args)

def DpleSolver_loadPlugin(*args):
    """DpleSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.DpleSolver_loadPlugin(*args)

def DpleSolver_doc(*args):
    """DpleSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.DpleSolver_doc(*args)


_casadi_core.DLE_A_swigconstant(_casadi_core)
DLE_A = _casadi_core.DLE_A

_casadi_core.DLE_V_swigconstant(_casadi_core)
DLE_V = _casadi_core.DLE_V

_casadi_core.DLE_NUM_IN_swigconstant(_casadi_core)
DLE_NUM_IN = _casadi_core.DLE_NUM_IN

_casadi_core.DLE_P_swigconstant(_casadi_core)
DLE_P = _casadi_core.DLE_P

_casadi_core.DLE_NUM_OUT_swigconstant(_casadi_core)
DLE_NUM_OUT = _casadi_core.DLE_NUM_OUT

_casadi_core.Dle_STRUCT_A_swigconstant(_casadi_core)
Dle_STRUCT_A = _casadi_core.Dle_STRUCT_A

_casadi_core.Dle_STRUCT_V_swigconstant(_casadi_core)
Dle_STRUCT_V = _casadi_core.Dle_STRUCT_V

_casadi_core.Dle_STRUCT_NUM_swigconstant(_casadi_core)
Dle_STRUCT_NUM = _casadi_core.Dle_STRUCT_NUM
class DleSolver(Function):
    """


    Base class for Discrete Lyapunov Equation Solvers.

    Given matrices $A$ and symmetric $V$



    ::

      A in R^(n x n)
      V in S^n




    finds $P$ that satisfies:



    ::

      P = A P A' + V




    General information
    ===================



    >Input scheme: casadi::DLEInput (DLE_NUM_IN = 2) [dleIn]

    +-----------+-------+-------------+
    | Full name | Short | Description |
    +===========+=======+=============+
    | DLE_A     | a     | A matrix .  |
    +-----------+-------+-------------+
    | DLE_V     | v     | V matrix .  |
    +-----------+-------+-------------+

    >Output scheme: casadi::DLEOutput (DLE_NUM_OUT = 1) [dleOut]

    +-----------+-------+-------------+
    | Full name | Short | Description |
    +===========+=======+=============+
    | DLE_P     | p     | P matrix .  |
    +-----------+-------+-------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eps_unstable | OT_REAL      | 0.000        | A margin for | casadi::DleI |
    |              |              |              | unstability  | nternal      |
    |              |              |              | detection    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | error_unstab | OT_BOOLEAN   | false        | Throw an     | casadi::DleI |
    | le           |              |              | exception    | nternal      |
    |              |              |              | when it is   |              |
    |              |              |              | detected     |              |
    |              |              |              | that         |              |
    |              |              |              | Product(A_i, |              |
    |              |              |              | i=N..1) has  |              |
    |              |              |              | eigenvalues  |              |
    |              |              |              | greater than |              |
    |              |              |              | 1-eps_unstab |              |
    |              |              |              | le           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | pos_def      | OT_BOOLEAN   | false        | Assume P     | casadi::DleI |
    |              |              |              | positive     | nternal      |
    |              |              |              | definite     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_DleSolver_dple'>dple</a>

    - <a href='#plugin_DleSolver_fixed_smith'>fixed_smith</a>

    - <a href='#plugin_DleSolver_lrdle'>lrdle</a>

    - <a href='#plugin_DleSolver_simple'>simple</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    DleSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    dple
    ----



    Solving the Discrete Lyapunov Equations with Periodic Solver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    fixed_smith
    -----------



    Solving the Discrete Lyapunov Equations with a fixed number of smith
    iterations.

    DleSolversmith

    >List of available options

    +---------------+------------+---------+----------------------------+
    |      Id       |    Type    | Default |        Description         |
    +===============+============+=========+============================+
    | freq_doubling | OT_BOOLEAN | false   | Use frequency doubling     |
    +---------------+------------+---------+----------------------------+
    | iter          | OT_INTEGER | 100     | Number of Smith iterations |
    +---------------+------------+---------+----------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lrdle
    -----



    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    simple
    ------



    Solving the Discrete Lyapunov Equations with a regular LinearSolver

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | compressed_solv | OT_BOOLEAN      | true            | When a system   |
    | e               |                 |                 | with sparse rhs |
    |                 |                 |                 | arises,         |
    |                 |                 |                 | compress toa    |
    |                 |                 |                 | smaller system  |
    |                 |                 |                 | with dense rhs. |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver   | OT_STRING       | GenericType()   | User-defined    |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | class. Needed   |
    |                 |                 |                 | for             |
    |                 |                 |                 | sensitivities.  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: dle_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DleSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DleSolver, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(DleSolver self) -> DleSolver



        Clone.


        """
        return _casadi_core.DleSolver_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(DleSolver self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.DleSolver_printStats(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.DleSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.DleSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.DleSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.DleSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def getSparsity(*args):
        """getSparsity(DleStructure st) -> Sparsity"""
        return _casadi_core.DleSolver_getSparsity(*args)

    if _newclass:
        getSparsity = staticmethod(getSparsity)
    __swig_getmethods__["getSparsity"] = lambda x: getSparsity

    def __init__(self, *args):
        """
        __init__(casadi::DleSolver self) -> DleSolver
        __init__(casadi::DleSolver self, std::string const & name, DleStructure st) -> DleSolver
        __init__(casadi::DleSolver self, DleSolver other) -> DleSolver



        >  casadi::DleSolver::DleSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::DleSolver::DleSolver(const std::string &name, const DleStructure &st)
        ------------------------------------------------------------------------

        DleSolver solver factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_DleSolver_dple'>dple</a>

        - <a href='#plugin_DleSolver_fixed_smith'>fixed_smith</a>

        - <a href='#plugin_DleSolver_lrdle'>lrdle</a>

        - <a href='#plugin_DleSolver_simple'>simple</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        DleSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::DleStruct ( = 2) [dleStruct]

        +--------------+-------+----------------+
        |  Full name   | Short |  Description   |
        +==============+=======+================+
        | Dle_STRUCT_A | a     | The matrix A . |
        +--------------+-------+----------------+
        | Dle_STRUCT_V | v     | The matrix V . |
        +--------------+-------+----------------+


        """
        this = _casadi_core.new_DleSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DleSolver
DleSolver_swigregister = _casadi_core.DleSolver_swigregister
DleSolver_swigregister(DleSolver)

def DleSolver_testCast(*args):
    """DleSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.DleSolver_testCast(*args)

def DleSolver_hasPlugin(*args):
    """DleSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.DleSolver_hasPlugin(*args)

def DleSolver_loadPlugin(*args):
    """DleSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.DleSolver_loadPlugin(*args)

def DleSolver_doc(*args):
    """DleSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.DleSolver_doc(*args)

def DleSolver_getSparsity(*args):
    """DleSolver_getSparsity(DleStructure st) -> Sparsity"""
    return _casadi_core.DleSolver_getSparsity(*args)


_casadi_core.LR_DPLE_A_swigconstant(_casadi_core)
LR_DPLE_A = _casadi_core.LR_DPLE_A

_casadi_core.LR_DPLE_V_swigconstant(_casadi_core)
LR_DPLE_V = _casadi_core.LR_DPLE_V

_casadi_core.LR_DPLE_C_swigconstant(_casadi_core)
LR_DPLE_C = _casadi_core.LR_DPLE_C

_casadi_core.LR_DPLE_H_swigconstant(_casadi_core)
LR_DPLE_H = _casadi_core.LR_DPLE_H

_casadi_core.LR_DPLE_NUM_IN_swigconstant(_casadi_core)
LR_DPLE_NUM_IN = _casadi_core.LR_DPLE_NUM_IN

_casadi_core.LR_DPLE_Y_swigconstant(_casadi_core)
LR_DPLE_Y = _casadi_core.LR_DPLE_Y

_casadi_core.LR_DPLE_NUM_OUT_swigconstant(_casadi_core)
LR_DPLE_NUM_OUT = _casadi_core.LR_DPLE_NUM_OUT

_casadi_core.LR_Dple_STRUCT_A_swigconstant(_casadi_core)
LR_Dple_STRUCT_A = _casadi_core.LR_Dple_STRUCT_A

_casadi_core.LR_Dple_STRUCT_V_swigconstant(_casadi_core)
LR_Dple_STRUCT_V = _casadi_core.LR_Dple_STRUCT_V

_casadi_core.LR_Dple_STRUCT_C_swigconstant(_casadi_core)
LR_Dple_STRUCT_C = _casadi_core.LR_Dple_STRUCT_C

_casadi_core.LR_Dple_STRUCT_H_swigconstant(_casadi_core)
LR_Dple_STRUCT_H = _casadi_core.LR_Dple_STRUCT_H

_casadi_core.LR_Dple_STRUCT_NUM_swigconstant(_casadi_core)
LR_Dple_STRUCT_NUM = _casadi_core.LR_Dple_STRUCT_NUM
class LrDpleSolver(Function):
    """


    Base class for Discrete Periodic Lyapunov Equation Solvers.

    Given matrices $A_k$ and symmetric $V_k, k = 0..K-1$



    ::

      A_k in R^(n x n)
      V_k in R^n




    provides all of $P_k$ that satisfy:



    ::

      P_0 = A_(K-1)*P_(K-1)*A_(K-1)' + V_k
      P_k+1 = A_k*P_k*A_k' + V_k  for k = 1..K-1




    General information
    ===================



    >Input scheme: casadi::LR_DPLEInput (LR_DPLE_NUM_IN = 4) [lrdpleIn]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | LR_DPLE_A              | a                      | A matrices (horzcat    |
    |                        |                        | when const_dim,        |
    |                        |                        | blkdiag otherwise) .   |
    +------------------------+------------------------+------------------------+
    | LR_DPLE_V              | v                      | V matrices (horzcat    |
    |                        |                        | when const_dim,        |
    |                        |                        | blkdiag otherwise) .   |
    +------------------------+------------------------+------------------------+
    | LR_DPLE_C              | c                      | C matrix .             |
    +------------------------+------------------------+------------------------+
    | LR_DPLE_H              | h                      | H matrix: horizontal   |
    |                        |                        | stack of all Hi .      |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::LR_DPLEOutput (LR_DPLE_NUM_OUT = 1) [lrdpleOut]

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | LR_DPLE_Y              | y                      | Lyapunov matrix        |
    |                        |                        | (horzcat when          |
    |                        |                        | const_dim, blkdiag     |
    |                        |                        | otherwise) (Cholesky   |
    |                        |                        | of P if pos_def) .     |
    +------------------------+------------------------+------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | const_dim    | OT_BOOLEAN   | true         | Assume       | casadi::LrDp |
    |              |              |              | constant     | leInternal   |
    |              |              |              | dimension of |              |
    |              |              |              | P            |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eps_unstable | OT_REAL      | 0.000        | A margin for | casadi::LrDp |
    |              |              |              | unstability  | leInternal   |
    |              |              |              | detection    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | error_unstab | OT_BOOLEAN   | false        | Throw an     | casadi::LrDp |
    | le           |              |              | exception    | leInternal   |
    |              |              |              | when it is   |              |
    |              |              |              | detected     |              |
    |              |              |              | that         |              |
    |              |              |              | Product(A_i, |              |
    |              |              |              | i=N..1) has  |              |
    |              |              |              | eigenvalues  |              |
    |              |              |              | greater than |              |
    |              |              |              | 1-eps_unstab |              |
    |              |              |              | le           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | pos_def      | OT_BOOLEAN   | false        | Assume P     | casadi::LrDp |
    |              |              |              | positive     | leInternal   |
    |              |              |              | definite     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_LrDpleSolver_dple'>dple</a>

    - <a href='#plugin_LrDpleSolver_lifting'>lifting</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    LrDpleSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    dple
    ----



    Solving the Low-Rank Discrete Lyapunov Equations with a Low-Rank Discrete
    Lyapunov Equations Solver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lifting
    -------



    Solving the Discrete Periodic Lyapunov Equations by lifting the entire
    period to a single Discrete Lyapunov Equation

    >List of available options

    +------+-----------+---------+-----------------------------------+
    |  Id  |   Type    | Default |            Description            |
    +======+===========+=========+===================================+
    | form | OT_STRING | "A"     | The form of the lifting (A:0|B:1) |
    +------+-----------+---------+-----------------------------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: lr_dple_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LrDpleSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LrDpleSolver, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(LrDpleSolver self) -> LrDpleSolver



        Clone.


        """
        return _casadi_core.LrDpleSolver_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(LrDpleSolver self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.LrDpleSolver_printStats(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.LrDpleSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.LrDpleSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.LrDpleSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.LrDpleSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::LrDpleSolver self) -> LrDpleSolver
        __init__(casadi::LrDpleSolver self, std::string const & name, LrDpleVecStructure st, IVectorVector Hs) -> LrDpleSolver
        __init__(casadi::LrDpleSolver self, LrDpleSolver other) -> LrDpleSolver



        >  casadi::LrDpleSolver::LrDpleSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::LrDpleSolver::LrDpleSolver(const std::string &name, const LrDpleStructure &st, const std::vector< std::vector< int > > &Hs=std::vector< std::vector< int > >())
        ------------------------------------------------------------------------

        LrDpleSolver solver factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_LrDpleSolver_dple'>dple</a>

        - <a href='#plugin_LrDpleSolver_lifting'>lifting</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        LrDpleSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.


        """
        this = _casadi_core.new_LrDpleSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LrDpleSolver
LrDpleSolver_swigregister = _casadi_core.LrDpleSolver_swigregister
LrDpleSolver_swigregister(LrDpleSolver)

def LrDpleSolver_testCast(*args):
    """LrDpleSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.LrDpleSolver_testCast(*args)

def LrDpleSolver_hasPlugin(*args):
    """LrDpleSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.LrDpleSolver_hasPlugin(*args)

def LrDpleSolver_loadPlugin(*args):
    """LrDpleSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.LrDpleSolver_loadPlugin(*args)

def LrDpleSolver_doc(*args):
    """LrDpleSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.LrDpleSolver_doc(*args)


_casadi_core.LR_DLE_A_swigconstant(_casadi_core)
LR_DLE_A = _casadi_core.LR_DLE_A

_casadi_core.LR_DLE_V_swigconstant(_casadi_core)
LR_DLE_V = _casadi_core.LR_DLE_V

_casadi_core.LR_DLE_C_swigconstant(_casadi_core)
LR_DLE_C = _casadi_core.LR_DLE_C

_casadi_core.LR_DLE_H_swigconstant(_casadi_core)
LR_DLE_H = _casadi_core.LR_DLE_H

_casadi_core.LR_DLE_NUM_IN_swigconstant(_casadi_core)
LR_DLE_NUM_IN = _casadi_core.LR_DLE_NUM_IN

_casadi_core.LR_DLE_Y_swigconstant(_casadi_core)
LR_DLE_Y = _casadi_core.LR_DLE_Y

_casadi_core.LR_DLE_NUM_OUT_swigconstant(_casadi_core)
LR_DLE_NUM_OUT = _casadi_core.LR_DLE_NUM_OUT

_casadi_core.LR_DLE_STRUCT_A_swigconstant(_casadi_core)
LR_DLE_STRUCT_A = _casadi_core.LR_DLE_STRUCT_A

_casadi_core.LR_DLE_STRUCT_V_swigconstant(_casadi_core)
LR_DLE_STRUCT_V = _casadi_core.LR_DLE_STRUCT_V

_casadi_core.LR_DLE_STRUCT_C_swigconstant(_casadi_core)
LR_DLE_STRUCT_C = _casadi_core.LR_DLE_STRUCT_C

_casadi_core.LR_DLE_STRUCT_H_swigconstant(_casadi_core)
LR_DLE_STRUCT_H = _casadi_core.LR_DLE_STRUCT_H

_casadi_core.LR_DLE_STRUCT_NUM_swigconstant(_casadi_core)
LR_DLE_STRUCT_NUM = _casadi_core.LR_DLE_STRUCT_NUM
class LrDleSolver(Function):
    """


    Base class for Low-rank Discrete Lyapunov Equation Solvers.



    ::

      A in R^(n x n)
      V in S^m
      C in R^(n x m)
      Hi in R^(n x Hsi)




    finds $P$ that satisfies:



    ::

      P = A P A' + C V C'




    and outputs

    Yi = Hi^T P Hi

    General information
    ===================



    >Input scheme: casadi::LR_DLEInput (LR_DLE_NUM_IN = 4) [lrdleIn]

    +-----------+-------+----------------------------------------+
    | Full name | Short |              Description               |
    +===========+=======+========================================+
    | LR_DLE_A  | a     | A matrix .                             |
    +-----------+-------+----------------------------------------+
    | LR_DLE_V  | v     | V matrix .                             |
    +-----------+-------+----------------------------------------+
    | LR_DLE_C  | c     | C matrix .                             |
    +-----------+-------+----------------------------------------+
    | LR_DLE_H  | h     | H matrix: horizontal stack of all Hi . |
    +-----------+-------+----------------------------------------+

    >Output scheme: casadi::LR_DLEOutput (LR_DLE_NUM_OUT = 1) [lrdleOut]

    +-----------+-------+--------------------------+
    | Full name | Short |       Description        |
    +===========+=======+==========================+
    | LR_DLE_Y  | y     | Y matrix, blkdiag form . |
    +-----------+-------+--------------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eps_unstable | OT_REAL      | 0.000        | A margin for | casadi::LrDl |
    |              |              |              | unstability  | eInternal    |
    |              |              |              | detection    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | error_unstab | OT_BOOLEAN   | false        | Throw an     | casadi::LrDl |
    | le           |              |              | exception    | eInternal    |
    |              |              |              | when it is   |              |
    |              |              |              | detected     |              |
    |              |              |              | that         |              |
    |              |              |              | Product(A_i, |              |
    |              |              |              | i=N..1) has  |              |
    |              |              |              | eigenvalues  |              |
    |              |              |              | greater than |              |
    |              |              |              | 1-eps_unstab |              |
    |              |              |              | le           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | pos_def      | OT_BOOLEAN   | false        | Assume P     | casadi::LrDl |
    |              |              |              | positive     | eInternal    |
    |              |              |              | definite     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_LrDleSolver_dle'>dle</a>

    - <a href='#plugin_LrDleSolver_fixed_smith'>fixed_smith</a>

    - <a href='#plugin_LrDleSolver_smith'>smith</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    LrDleSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    dle
    ---



    Solving the Low-Rank Discrete Lyapunov Equations with a regular Discrete
    Lyapunov Equations solver

    Solving the Discrete Lyapunov Equations with a Low-rank Discrete Lyapunov
    Equations solver

    >List of available options

    +----+------+---------+-------------+
    | Id | Type | Default | Description |
    +====+======+=========+=============+
    +----+------+---------+-------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    fixed_smith
    -----------



    Solving the Discrete Lyapunov Equations with a regular LinearSolver
    DleSolversmith  LrDleSolversmith

    >List of available options

    +------+------------+---------+----------------------------+
    |  Id  |    Type    | Default |        Description         |
    +======+============+=========+============================+
    | iter | OT_INTEGER | 100     | Number of Smith iterations |
    +------+------------+---------+----------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    smith
    -----



    Solving the Low-rank Discrete Lyapunov Equations with Smith iterations

    DleSolversmith  LrDleSolversmith

    Implementation details: We avoid ever holding P in memory as it might be
    large norm_inf_mul_tt was used to obtain a stopping criteria

    We avoid memory allocation in evaluate. All sparsity pattern calculations
    have been done at init

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | max_iter        | OT_INTEGER      | 100             | Maximum number  |
    |                 |                 |                 | of iterations   |
    |                 |                 |                 | for the         |
    |                 |                 |                 | algorithm       |
    +-----------------+-----------------+-----------------+-----------------+
    | print_iteration | OT_BOOLEAN      | false           | Print           |
    |                 |                 |                 | information     |
    |                 |                 |                 | about each      |
    |                 |                 |                 | iteration       |
    +-----------------+-----------------+-----------------+-----------------+
    | tol             | OT_REAL         | 0.000           | Tolerance for   |
    |                 |                 |                 | satisfying the  |
    |                 |                 |                 | Lyapunov        |
    |                 |                 |                 | equation.       |
    +-----------------+-----------------+-----------------+-----------------+

    >List of available stats

    +------------+
    |     Id     |
    +============+
    | iter_count |
    +------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: lr_dle_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LrDleSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LrDleSolver, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(LrDleSolver self) -> LrDleSolver



        Clone.


        """
        return _casadi_core.LrDleSolver_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(LrDleSolver self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.LrDleSolver_printStats(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.LrDleSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.LrDleSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.LrDleSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.LrDleSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def getSparsity(*args):
        """getSparsity(LrDleStructure st, IVector Hs) -> Sparsity"""
        return _casadi_core.LrDleSolver_getSparsity(*args)

    if _newclass:
        getSparsity = staticmethod(getSparsity)
    __swig_getmethods__["getSparsity"] = lambda x: getSparsity

    def __init__(self, *args):
        """
        __init__(casadi::LrDleSolver self) -> LrDleSolver
        __init__(casadi::LrDleSolver self, std::string const & name, LrDleStructure st, IVector Hs) -> LrDleSolver
        __init__(casadi::LrDleSolver self, LrDleSolver other) -> LrDleSolver



        >  casadi::LrDleSolver::LrDleSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::LrDleSolver::LrDleSolver(const std::string &name, const LrDleStructure &st, const std::vector< int > &Hs=std::vector< int >())
        ------------------------------------------------------------------------

        LrDleSolver solver factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_LrDleSolver_dle'>dle</a>

        - <a href='#plugin_LrDleSolver_fixed_smith'>fixed_smith</a>

        - <a href='#plugin_LrDleSolver_smith'>smith</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        LrDleSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::LrDleStruct ( = 4) [lrdleStruct]

        +-----------------+-------+----------------------------------------+
        |    Full name    | Short |              Description               |
        +=================+=======+========================================+
        | LR_DLE_STRUCT_A | a     | The matrix A .                         |
        +-----------------+-------+----------------------------------------+
        | LR_DLE_STRUCT_V | v     | The matrix V .                         |
        +-----------------+-------+----------------------------------------+
        | LR_DLE_STRUCT_C | c     | The matrix C (defaults to unity) .     |
        +-----------------+-------+----------------------------------------+
        | LR_DLE_STRUCT_H | h     | H matrix: horizontal stack of all Hi . |
        +-----------------+-------+----------------------------------------+

        Parameters:
        -----------

        Hs:  Column-sizes of H_i


        """
        this = _casadi_core.new_LrDleSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LrDleSolver
LrDleSolver_swigregister = _casadi_core.LrDleSolver_swigregister
LrDleSolver_swigregister(LrDleSolver)

def LrDleSolver_testCast(*args):
    """LrDleSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.LrDleSolver_testCast(*args)

def LrDleSolver_hasPlugin(*args):
    """LrDleSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.LrDleSolver_hasPlugin(*args)

def LrDleSolver_loadPlugin(*args):
    """LrDleSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.LrDleSolver_loadPlugin(*args)

def LrDleSolver_doc(*args):
    """LrDleSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.LrDleSolver_doc(*args)

def LrDleSolver_getSparsity(*args):
    """LrDleSolver_getSparsity(LrDleStructure st, IVector Hs) -> Sparsity"""
    return _casadi_core.LrDleSolver_getSparsity(*args)


_casadi_core.CLE_A_swigconstant(_casadi_core)
CLE_A = _casadi_core.CLE_A

_casadi_core.CLE_V_swigconstant(_casadi_core)
CLE_V = _casadi_core.CLE_V

_casadi_core.CLE_NUM_IN_swigconstant(_casadi_core)
CLE_NUM_IN = _casadi_core.CLE_NUM_IN

_casadi_core.CLE_P_swigconstant(_casadi_core)
CLE_P = _casadi_core.CLE_P

_casadi_core.CLE_NUM_OUT_swigconstant(_casadi_core)
CLE_NUM_OUT = _casadi_core.CLE_NUM_OUT

_casadi_core.Cle_STRUCT_A_swigconstant(_casadi_core)
Cle_STRUCT_A = _casadi_core.Cle_STRUCT_A

_casadi_core.Cle_STRUCT_V_swigconstant(_casadi_core)
Cle_STRUCT_V = _casadi_core.Cle_STRUCT_V

_casadi_core.Cle_STRUCT_C_swigconstant(_casadi_core)
Cle_STRUCT_C = _casadi_core.Cle_STRUCT_C

_casadi_core.Cle_STRUCT_NUM_swigconstant(_casadi_core)
Cle_STRUCT_NUM = _casadi_core.Cle_STRUCT_NUM
class CleSolver(Function):
    """


    Base class for Discrete Lyapunov Equation Solvers.

    Given matrices $A$ and symmetric $V$



    ::

      A in R^(n x n)
      V in S^n




    finds $P$ that satisfies:



    ::

      0 = A P  + P A' + V




    General information
    ===================



    >Input scheme: casadi::CLEInput (CLE_NUM_IN = 2) [cleIn]

    +-----------+-------+-------------+
    | Full name | Short | Description |
    +===========+=======+=============+
    | CLE_A     | a     | A matrix .  |
    +-----------+-------+-------------+
    | CLE_V     | v     | V matrix .  |
    +-----------+-------+-------------+

    >Output scheme: casadi::CLEOutput (CLE_NUM_OUT = 1) [cleOut]

    +-----------+-------+-------------------+
    | Full name | Short |    Description    |
    +===========+=======+===================+
    | CLE_P     | p     | Lyapunov matrix . |
    +-----------+-------+-------------------+

    >List of available options

    +--------------+--------------+--------------+--------------+--------------+
    |      Id      |     Type     |   Default    | Description  |   Used in    |
    +==============+==============+==============+==============+==============+
    | ad_mode      | OT_STRING    | "automatic"  | How to       | casadi::Func |
    |              |              |              | calculate    | tionInternal |
    |              |              |              | the          |              |
    |              |              |              | Jacobians.   |              |
    |              |              |              | (forward:    |              |
    |              |              |              | only forward |              |
    |              |              |              | mode|reverse |              |
    |              |              |              | : only       |              |
    |              |              |              | adjoint mode |              |
    |              |              |              | |automatic:  |              |
    |              |              |              | a heuristic  |              |
    |              |              |              | decides      |              |
    |              |              |              | which is     |              |
    |              |              |              | more         |              |
    |              |              |              | appropriate) |              |
    +--------------+--------------+--------------+--------------+--------------+
    | derivative_g | OT_DERIVATIV | GenericType( | Function     | casadi::Func |
    | enerator     | EGENERATOR   | )            | that returns | tionInternal |
    |              |              |              | a derivative |              |
    |              |              |              | function     |              |
    |              |              |              | given a      |              |
    |              |              |              | number of    |              |
    |              |              |              | forward and  |              |
    |              |              |              | reverse      |              |
    |              |              |              | directional  |              |
    |              |              |              | derivative,  |              |
    |              |              |              | overrides    |              |
    |              |              |              | internal     |              |
    |              |              |              | routines.    |              |
    |              |              |              | Check docume |              |
    |              |              |              | ntation of D |              |
    |              |              |              | erivativeGen |              |
    |              |              |              | erator .     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | eps_unstable | OT_REAL      | 0.000        | A margin for | casadi::CleI |
    |              |              |              | unstability  | nternal      |
    |              |              |              | detection    |              |
    +--------------+--------------+--------------+--------------+--------------+
    | error_unstab | OT_BOOLEAN   | false        | Throw an     | casadi::CleI |
    | le           |              |              | exception    | nternal      |
    |              |              |              | when it is   |              |
    |              |              |              | detected     |              |
    |              |              |              | that         |              |
    |              |              |              | Product(A_i, |              |
    |              |              |              | i=N..1) has  |              |
    |              |              |              | eigenvalues  |              |
    |              |              |              | greater than |              |
    |              |              |              | 1-eps_unstab |              |
    |              |              |              | le           |              |
    +--------------+--------------+--------------+--------------+--------------+
    | gather_stats | OT_BOOLEAN   | false        | Flag to      | casadi::Func |
    |              |              |              | indicate     | tionInternal |
    |              |              |              | whether      |              |
    |              |              |              | statistics   |              |
    |              |              |              | must be      |              |
    |              |              |              | gathered     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | inputs_check | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    |              |              |              | exceptions   | tionInternal |
    |              |              |              | when the     |              |
    |              |              |              | numerical    |              |
    |              |              |              | values of    |              |
    |              |              |              | the inputs   |              |
    |              |              |              | don't make   |              |
    |              |              |              | sense        |              |
    +--------------+--------------+--------------+--------------+--------------+
    | monitor      | OT_STRINGVEC | GenericType( | Monitors to  | casadi::Func |
    |              | TOR          | )            | be activated | tionInternal |
    |              |              |              | (inputs|outp |              |
    |              |              |              | uts)         |              |
    +--------------+--------------+--------------+--------------+--------------+
    | name         | OT_STRING    | "unnamed_sha | name of the  | casadi::Opti |
    |              |              | red_object"  | object       | onsFunctiona |
    |              |              |              |              | lityNode     |
    +--------------+--------------+--------------+--------------+--------------+
    | pos_def      | OT_BOOLEAN   | false        | Assume P     | casadi::CleI |
    |              |              |              | positive     | nternal      |
    |              |              |              | definite     |              |
    +--------------+--------------+--------------+--------------+--------------+
    | regularity_c | OT_BOOLEAN   | true         | Throw        | casadi::Func |
    | heck         |              |              | exceptions   | tionInternal |
    |              |              |              | when NaN or  |              |
    |              |              |              | Inf appears  |              |
    |              |              |              | during       |              |
    |              |              |              | evaluation   |              |
    +--------------+--------------+--------------+--------------+--------------+
    | user_data    | OT_VOIDPTR   | GenericType( | A user-      | casadi::Func |
    |              |              | )            | defined      | tionInternal |
    |              |              |              | field that   |              |
    |              |              |              | can be used  |              |
    |              |              |              | to identify  |              |
    |              |              |              | the function |              |
    |              |              |              | or pass      |              |
    |              |              |              | additional   |              |
    |              |              |              | information  |              |
    +--------------+--------------+--------------+--------------+--------------+
    | verbose      | OT_BOOLEAN   | false        | Verbose      | casadi::Func |
    |              |              |              | evaluation   | tionInternal |
    |              |              |              | for          |              |
    |              |              |              | debugging    |              |
    +--------------+--------------+--------------+--------------+--------------+

    List of plugins
    ===============



    - <a href='#plugin_CleSolver_simple'>simple</a>

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    CleSolver.doc("myextraplugin")



    --------------------------------------------------------------------------------

    simple
    ------



    Solving the Discrete Lyapunov Equations with a regular LinearSolver

    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |     Default     |   Description   |
    +=================+=================+=================+=================+
    | linear_solver   | OT_STRING       | GenericType()   | User-defined    |
    |                 |                 |                 | linear solver   |
    |                 |                 |                 | class. Needed   |
    |                 |                 |                 | for             |
    |                 |                 |                 | sensitivities.  |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICTIONARY   | GenericType()   | Options to be   |
    | ptions          |                 |                 | passed to the   |
    |                 |                 |                 | linear solver.  |
    +-----------------+-----------------+-----------------+-----------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: cle_solver.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CleSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CleSolver, name)
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(CleSolver self) -> CleSolver



        Clone.


        """
        return _casadi_core.CleSolver_clone(self, *args)


    def printStats(self, *args):
        """
        printStats(CleSolver self, std::ostream & stream)



        Print solver statistics.


        """
        return _casadi_core.CleSolver_printStats(self, *args)


    def testCast(*args):
        """testCast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi_core.CleSolver_testCast(*args)

    if _newclass:
        testCast = staticmethod(testCast)
    __swig_getmethods__["testCast"] = lambda x: testCast

    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi_core.CleSolver_hasPlugin(*args)

    if _newclass:
        hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.CleSolver_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.CleSolver_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::CleSolver self) -> CleSolver
        __init__(casadi::CleSolver self, std::string const & name, CleStructure st) -> CleSolver
        __init__(casadi::CleSolver self, CleSolver other) -> CleSolver



        >  casadi::CleSolver::CleSolver()
        ------------------------------------------------------------------------

        Default constructor.

        >  casadi::CleSolver::CleSolver(const std::string &name, const CleStructure &st)
        ------------------------------------------------------------------------

        CleSolver solver factory.

        Parameters:
        -----------

        name:

        Name of a solver. It might be one of:

        - <a href='#plugin_CleSolver_simple'>simple</a>

        Note: some of the plugins in this list might not be available on your
        system. Also, there might be extra plugins available to you that are not
        listed here. You can obtain their documentation with
        CleSolver.doc("myextraplugin")

        Parameters:
        -----------

        st:

        Problem structure.>Struct scheme: casadi::CleStruct ( = 3) [cleStruct]

        +--------------+-------+------------------------------------+
        |  Full name   | Short |            Description             |
        +==============+=======+====================================+
        | Cle_STRUCT_A | a     | The matrix A .                     |
        +--------------+-------+------------------------------------+
        | Cle_STRUCT_V | v     | The matrix V .                     |
        +--------------+-------+------------------------------------+
        | Cle_STRUCT_C | c     | The matrix C (defaults to unity) . |
        +--------------+-------+------------------------------------+


        """
        this = _casadi_core.new_CleSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CleSolver
CleSolver_swigregister = _casadi_core.CleSolver_swigregister
CleSolver_swigregister(CleSolver)

def CleSolver_testCast(*args):
    """CleSolver_testCast(casadi::SharedObjectNode const * ptr) -> bool"""
    return _casadi_core.CleSolver_testCast(*args)

def CleSolver_hasPlugin(*args):
    """CleSolver_hasPlugin(std::string const & name) -> bool"""
    return _casadi_core.CleSolver_hasPlugin(*args)

def CleSolver_loadPlugin(*args):
    """CleSolver_loadPlugin(std::string const & name)"""
    return _casadi_core.CleSolver_loadPlugin(*args)

def CleSolver_doc(*args):
    """CleSolver_doc(std::string const & name) -> std::string"""
    return _casadi_core.CleSolver_doc(*args)



def IOSchemeVector(arg,io_scheme):
  try:
    return IOSchemeVectorD(arg,io_scheme)
  except:
    pass
  try:
    return IOSchemeVectorSX(arg,io_scheme)
  except:
    pass
  try:
    return IOSchemeVectorMX(arg,io_scheme)
  except:
    pass
  try:
    arg = map(lambda x: sp_dense(0,0) if isinstance(x,list) and len(x)==0 else x,arg)
    return IOSchemeVectorSparsity(arg,io_scheme)
  except:
    pass
  raise TypeError("IOSchemeVector called with faulty arguments. Individual values must be SX, MX or Sparsity.")


def cleIn(*dummy,**kwargs):
  """
  Helper function for 'CLEInput'

  Two use cases:
     a) arg = cleIn(a=my_a, v=my_v)
          all arguments optional
     b) a, v = cleIn(arg,"a", "v")
          all arguments after the first optional
  Input arguments of a \e cle solver

  Keyword arguments::

    a -- A matrix [CLE_A]
    v -- V matrix [CLE_V]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of cleIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_CLEInput,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  for k in kwargs.keys():
    if not(k in ['a','v']):
      raise Exception("Keyword error in cleIn: '%s' is not recognized. Available keywords are: a, v" % k )
  return IOSchemeVector([a,v], IOScheme(SCHEME_CLEInput))


def cleOut(*dummy,**kwargs):
  """
  Helper function for 'CLEOutput'

  Two use cases:
     a) arg = cleOut(p=my_p)
          all arguments optional
     b) p = cleOut(arg,"p")
          all arguments after the first optional
  Output arguments of a \e cle solver

  Keyword arguments::

    p -- Lyapunov matrix [CLE_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of cleOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_CLEOutput,n)] for n in dummy[1:]]
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['p']):
      raise Exception("Keyword error in cleOut: '%s' is not recognized. Available keywords are: p" % k )
  return IOSchemeVector([p], IOScheme(SCHEME_CLEOutput))


def cleStruct(*dummy,**kwargs):
  """
  Helper function for 'CleStruct'

  Two use cases:
     a) arg = cleStruct(a=my_a, v=my_v, c=my_c)
          all arguments optional
     b) a, v, c = cleStruct(arg,"a", "v", "c")
          all arguments after the first optional
  Structure specification of a CLE

  Keyword arguments::

    a -- The matrix A [Cle_STRUCT_A]
    v -- The matrix V [Cle_STRUCT_V]
    c -- The matrix C (defaults to unity) [Cle_STRUCT_C]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of cleStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_CleStruct,n)] for n in dummy[1:]]
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  v = Sparsity()
  if 'v' in kwargs:
    v = kwargs['v']
  c = Sparsity()
  if 'c' in kwargs:
    c = kwargs['c']
  for k in kwargs.keys():
    if not(k in ['a','v','c']):
      raise Exception("Keyword error in cleStruct: '%s' is not recognized. Available keywords are: a, v, c" % k )
  return CleStructure([a,v,c])

class CleStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'CleStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CleStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CleStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::CleStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> CleStructure
        __init__(casadi::CleStructIOSchemeVector<(casadi::Sparsity)> self, CleStructure other) -> CleStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_CleStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CleStructure
CleStructure_swigregister = _casadi_core.CleStructure_swigregister
CleStructure_swigregister(CleStructure)


def controldaeIn(*dummy,**kwargs):
  """
  Helper function for 'ControlledDAEInput'

  Two use cases:
     a) arg = controldaeIn(t=my_t, x=my_x, z=my_z, p=my_p, u=my_u, u_interp=my_u_interp, x_major=my_x_major, t0=my_t0, tf=my_tf)
          all arguments optional
     b) t, x, z, p, u, u_interp, x_major, t0, tf = controldaeIn(arg,"t", "x", "z", "p", "u", "u_interp", "x_major", "t0", "tf")
          all arguments after the first optional
  Input arguments of an ODE/DAE function

  Keyword arguments::

    t        -- Global physical time. (1-by-1) [CONTROL_DAE_T]
    x        -- non-zeros as DAEOutput:DAE_RES [CONTROL_DAE_X]
    z        -- Algebraic state vector (dimension np-by-1). [CONTROL_DAE_Z]
    p        -- Parameter vector (dimension np-by-1). [CONTROL_DAE_P]
    u        -- Control vector (dimension nu-by-1). [CONTROL_DAE_U]
    u_interp -- Control vector, linearly interpolated (dimension nu-by-1). [CONTROL_DAE_U_INTERP]
    x_major  -- State vector (dimension nx-by-1) at the last major time-step [CONTROL_DAE_X_MAJOR]
    t0       -- Time at start of control interval (1-by-1) [CONTROL_DAE_T0]
    tf       -- Time at end of control interval (1-by-1) [CONTROL_DAE_TF]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of controldaeIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_ControlledDAEInput,n)] for n in dummy[1:]]
  t = []
  if 't' in kwargs:
    t = kwargs['t']
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  z = []
  if 'z' in kwargs:
    z = kwargs['z']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  u = []
  if 'u' in kwargs:
    u = kwargs['u']
  u_interp = []
  if 'u_interp' in kwargs:
    u_interp = kwargs['u_interp']
  x_major = []
  if 'x_major' in kwargs:
    x_major = kwargs['x_major']
  t0 = []
  if 't0' in kwargs:
    t0 = kwargs['t0']
  tf = []
  if 'tf' in kwargs:
    tf = kwargs['tf']
  for k in kwargs.keys():
    if not(k in ['t','x','z','p','u','u_interp','x_major','t0','tf']):
      raise Exception("Keyword error in controldaeIn: '%s' is not recognized. Available keywords are: t, x, z, p, u, u_interp, x_major, t0, tf" % k )
  return IOSchemeVector([t,x,z,p,u,u_interp,x_major,t0,tf], IOScheme(SCHEME_ControlledDAEInput))


def controlsimulatorIn(*dummy,**kwargs):
  """
  Helper function for 'ControlSimulatorInput'

  Two use cases:
     a) arg = controlsimulatorIn(x0=my_x0, p=my_p, u=my_u)
          all arguments optional
     b) x0, p, u = controlsimulatorIn(arg,"x0", "p", "u")
          all arguments after the first optional
  Input arguments of a control simulator

  Keyword arguments::

    x0 -- Differential or algebraic state at t0  (dimension nx-by-1) [CONTROLSIMULATOR_X0]
    p  -- Parameters that are fixed over the entire horizon  (dimension np-by-1) [CONTROLSIMULATOR_P]
    u  -- Parameters that change over the integration intervals (dimension nu-by-(ns-1)) [CONTROLSIMULATOR_U]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of controlsimulatorIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_ControlSimulatorInput,n)] for n in dummy[1:]]
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  u = []
  if 'u' in kwargs:
    u = kwargs['u']
  for k in kwargs.keys():
    if not(k in ['x0','p','u']):
      raise Exception("Keyword error in controlsimulatorIn: '%s' is not recognized. Available keywords are: x0, p, u" % k )
  return IOSchemeVector([x0,p,u], IOScheme(SCHEME_ControlSimulatorInput))


def dleIn(*dummy,**kwargs):
  """
  Helper function for 'DLEInput'

  Two use cases:
     a) arg = dleIn(a=my_a, v=my_v)
          all arguments optional
     b) a, v = dleIn(arg,"a", "v")
          all arguments after the first optional
  Input arguments of a \e dle solver

  Keyword arguments::

    a -- A matrix [DLE_A]
    v -- V matrix [DLE_V]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dleIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DLEInput,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  for k in kwargs.keys():
    if not(k in ['a','v']):
      raise Exception("Keyword error in dleIn: '%s' is not recognized. Available keywords are: a, v" % k )
  return IOSchemeVector([a,v], IOScheme(SCHEME_DLEInput))


def dleOut(*dummy,**kwargs):
  """
  Helper function for 'DLEOutput'

  Two use cases:
     a) arg = dleOut(p=my_p)
          all arguments optional
     b) p = dleOut(arg,"p")
          all arguments after the first optional
  Output arguments of a \e dle solver

  Keyword arguments::

    p -- P matrix [DLE_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dleOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DLEOutput,n)] for n in dummy[1:]]
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['p']):
      raise Exception("Keyword error in dleOut: '%s' is not recognized. Available keywords are: p" % k )
  return IOSchemeVector([p], IOScheme(SCHEME_DLEOutput))


def dleStruct(*dummy,**kwargs):
  """
  Helper function for 'DleStruct'

  Two use cases:
     a) arg = dleStruct(a=my_a, v=my_v)
          all arguments optional
     b) a, v = dleStruct(arg,"a", "v")
          all arguments after the first optional
  Structure specification of a DLE

  Keyword arguments::

    a -- The matrix A [Dle_STRUCT_A]
    v -- The matrix V [Dle_STRUCT_V]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dleStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DleStruct,n)] for n in dummy[1:]]
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  v = Sparsity()
  if 'v' in kwargs:
    v = kwargs['v']
  for k in kwargs.keys():
    if not(k in ['a','v']):
      raise Exception("Keyword error in dleStruct: '%s' is not recognized. Available keywords are: a, v" % k )
  return DleStructure([a,v])

class DleStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'DleStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DleStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DleStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::DleStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> DleStructure
        __init__(casadi::DleStructIOSchemeVector<(casadi::Sparsity)> self, DleStructure other) -> DleStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_DleStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DleStructure
DleStructure_swigregister = _casadi_core.DleStructure_swigregister
DleStructure_swigregister(DleStructure)


def dpleIn(*dummy,**kwargs):
  """
  Helper function for 'DPLEInput'

  Two use cases:
     a) arg = dpleIn(a=my_a, v=my_v)
          all arguments optional
     b) a, v = dpleIn(arg,"a", "v")
          all arguments after the first optional
  Input arguments of a \e dple solver

  Keyword arguments::

    a -- A matrices (horzcat when const_dim, blkdiag otherwise) [DPLE_A]
    v -- V matrices (horzcat when const_dim, blkdiag otherwise) [DPLE_V]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dpleIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DPLEInput,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  for k in kwargs.keys():
    if not(k in ['a','v']):
      raise Exception("Keyword error in dpleIn: '%s' is not recognized. Available keywords are: a, v" % k )
  return IOSchemeVector([a,v], IOScheme(SCHEME_DPLEInput))


def dpleOut(*dummy,**kwargs):
  """
  Helper function for 'DPLEOutput'

  Two use cases:
     a) arg = dpleOut(p=my_p)
          all arguments optional
     b) p = dpleOut(arg,"p")
          all arguments after the first optional
  Output arguments of a \e dple solver

  Keyword arguments::

    p -- Lyapunov matrix (horzcat when const_dim, blkdiag otherwise) (Cholesky of P if pos_def) [DPLE_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dpleOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DPLEOutput,n)] for n in dummy[1:]]
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['p']):
      raise Exception("Keyword error in dpleOut: '%s' is not recognized. Available keywords are: p" % k )
  return IOSchemeVector([p], IOScheme(SCHEME_DPLEOutput))


def dpleStruct(*dummy,**kwargs):
  """
  Helper function for 'DpleVecStruct'

  Two use cases:
     a) arg = dpleStruct(a=my_a, v=my_v)
          all arguments optional
     b) a, v = dpleStruct(arg,"a", "v")
          all arguments after the first optional
  Structure specification of a DPLE

  Keyword arguments::

    a -- Sparsities for A_i, blkdiag form [Dple_STRUCT_A]
    v -- Sparsities for V_i, blkdiag form [Dple_STRUCT_V]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of dpleStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DpleVecStruct,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  for k in kwargs.keys():
    if not(k in ['a','v']):
      raise Exception("Keyword error in dpleStruct: '%s' is not recognized. Available keywords are: a, v" % k )
  return DpleVecStructure([a,v])

class DpleVecStructure(IOSchemeVectorSparsityVector):
    """
    [INTERNAL]
    Helper function for 'DpleVecStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsityVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DpleVecStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsityVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DpleVecStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::DpleVecStructIOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, SparsityVectorVector t) -> DpleVecStructure
        __init__(casadi::DpleVecStructIOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, DpleVecStructure other) -> DpleVecStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_DpleVecStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_DpleVecStructure
DpleVecStructure_swigregister = _casadi_core.DpleVecStructure_swigregister
DpleVecStructure_swigregister(DpleVecStructure)


def hnlpIn(*dummy,**kwargs):
  """
  Helper function for 'HNLPInput'

  Two use cases:
     a) arg = hnlpIn(x=my_x, p=my_p, tau=my_tau)
          all arguments optional
     b) x, p, tau = hnlpIn(arg,"x", "p", "tau")
          all arguments after the first optional
  Input arguments of an Homotopy NLP function

  Keyword arguments::

    x   -- Decision variable [HNL_X]
    p   -- Fixed parameter [HNL_P]
    tau -- Homotopy parameter [HNL_TAU]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of hnlpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_HNLPInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  tau = []
  if 'tau' in kwargs:
    tau = kwargs['tau']
  for k in kwargs.keys():
    if not(k in ['x','p','tau']):
      raise Exception("Keyword error in hnlpIn: '%s' is not recognized. Available keywords are: x, p, tau" % k )
  return IOSchemeVector([x,p,tau], IOScheme(SCHEME_HNLPInput))


def daeIn(*dummy,**kwargs):
  """
  Helper function for 'DAEInput'

  Two use cases:
     a) arg = daeIn(x=my_x, z=my_z, p=my_p, t=my_t)
          all arguments optional
     b) x, z, p, t = daeIn(arg,"x", "z", "p", "t")
          all arguments after the first optional
  Input arguments of an ODE/DAE function

  Keyword arguments::

    x -- Differential state [DAE_X]
    z -- Algebraic state [DAE_Z]
    p -- Parameter [DAE_P]
    t -- Explicit time dependence [DAE_T]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of daeIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DAEInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  z = []
  if 'z' in kwargs:
    z = kwargs['z']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  t = []
  if 't' in kwargs:
    t = kwargs['t']
  for k in kwargs.keys():
    if not(k in ['x','z','p','t']):
      raise Exception("Keyword error in daeIn: '%s' is not recognized. Available keywords are: x, z, p, t" % k )
  return IOSchemeVector([x,z,p,t], IOScheme(SCHEME_DAEInput))


def daeOut(*dummy,**kwargs):
  """
  Helper function for 'DAEOutput'

  Two use cases:
     a) arg = daeOut(ode=my_ode, alg=my_alg, quad=my_quad)
          all arguments optional
     b) ode, alg, quad = daeOut(arg,"ode", "alg", "quad")
          all arguments after the first optional
  Output arguments of an DAE function

  Keyword arguments::

    ode  -- Right hand side of the implicit ODE [DAE_ODE]
    alg  -- Right hand side of algebraic equations [DAE_ALG]
    quad -- Right hand side of quadratures equations [DAE_QUAD]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of daeOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_DAEOutput,n)] for n in dummy[1:]]
  ode = []
  if 'ode' in kwargs:
    ode = kwargs['ode']
  alg = []
  if 'alg' in kwargs:
    alg = kwargs['alg']
  quad = []
  if 'quad' in kwargs:
    quad = kwargs['quad']
  for k in kwargs.keys():
    if not(k in ['ode','alg','quad']):
      raise Exception("Keyword error in daeOut: '%s' is not recognized. Available keywords are: ode, alg, quad" % k )
  return IOSchemeVector([ode,alg,quad], IOScheme(SCHEME_DAEOutput))


def rdaeIn(*dummy,**kwargs):
  """
  Helper function for 'RDAEInput'

  Two use cases:
     a) arg = rdaeIn(rx=my_rx, rz=my_rz, rp=my_rp, x=my_x, z=my_z, p=my_p, t=my_t)
          all arguments optional
     b) rx, rz, rp, x, z, p, t = rdaeIn(arg,"rx", "rz", "rp", "x", "z", "p", "t")
          all arguments after the first optional
  Input arguments of an ODE/DAE backward integration function

  Keyword arguments::

    rx -- Backward differential state [RDAE_RX]
    rz -- Backward algebraic state [RDAE_RZ]
    rp -- Backward  parameter vector [RDAE_RP]
    x  -- Forward differential state [RDAE_X]
    z  -- Forward algebraic state [RDAE_Z]
    p  -- Parameter vector [RDAE_P]
    t  -- Explicit time dependence [RDAE_T]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of rdaeIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_RDAEInput,n)] for n in dummy[1:]]
  rx = []
  if 'rx' in kwargs:
    rx = kwargs['rx']
  rz = []
  if 'rz' in kwargs:
    rz = kwargs['rz']
  rp = []
  if 'rp' in kwargs:
    rp = kwargs['rp']
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  z = []
  if 'z' in kwargs:
    z = kwargs['z']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  t = []
  if 't' in kwargs:
    t = kwargs['t']
  for k in kwargs.keys():
    if not(k in ['rx','rz','rp','x','z','p','t']):
      raise Exception("Keyword error in rdaeIn: '%s' is not recognized. Available keywords are: rx, rz, rp, x, z, p, t" % k )
  return IOSchemeVector([rx,rz,rp,x,z,p,t], IOScheme(SCHEME_RDAEInput))


def rdaeOut(*dummy,**kwargs):
  """
  Helper function for 'RDAEOutput'

  Two use cases:
     a) arg = rdaeOut(ode=my_ode, alg=my_alg, quad=my_quad)
          all arguments optional
     b) ode, alg, quad = rdaeOut(arg,"ode", "alg", "quad")
          all arguments after the first optional
  Output arguments of an ODE/DAE backward integration function

  Keyword arguments::

    ode  -- Right hand side of ODE. [RDAE_ODE]
    alg  -- Right hand side of algebraic equations. [RDAE_ALG]
    quad -- Right hand side of quadratures. [RDAE_QUAD]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of rdaeOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_RDAEOutput,n)] for n in dummy[1:]]
  ode = []
  if 'ode' in kwargs:
    ode = kwargs['ode']
  alg = []
  if 'alg' in kwargs:
    alg = kwargs['alg']
  quad = []
  if 'quad' in kwargs:
    quad = kwargs['quad']
  for k in kwargs.keys():
    if not(k in ['ode','alg','quad']):
      raise Exception("Keyword error in rdaeOut: '%s' is not recognized. Available keywords are: ode, alg, quad" % k )
  return IOSchemeVector([ode,alg,quad], IOScheme(SCHEME_RDAEOutput))


def integratorIn(*dummy,**kwargs):
  """
  Helper function for 'IntegratorInput'

  Two use cases:
     a) arg = integratorIn(x0=my_x0, p=my_p, z0=my_z0, rx0=my_rx0, rp=my_rp, rz0=my_rz0)
          all arguments optional
     b) x0, p, z0, rx0, rp, rz0 = integratorIn(arg,"x0", "p", "z0", "rx0", "rp", "rz0")
          all arguments after the first optional
  Input arguments of an integrator

  Keyword arguments::

    x0  -- Differential state at the initial time [INTEGRATOR_X0]
    p   -- Parameters [INTEGRATOR_P]
    z0  -- Initial guess for the algebraic variable [INTEGRATOR_Z0]
    rx0 -- Backward differential state at the final time [INTEGRATOR_RX0]
    rp  -- Backward parameter vector [INTEGRATOR_RP]
    rz0 -- Initial guess for the backwards algebraic variable [INTEGRATOR_RZ0]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of integratorIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_IntegratorInput,n)] for n in dummy[1:]]
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  z0 = []
  if 'z0' in kwargs:
    z0 = kwargs['z0']
  rx0 = []
  if 'rx0' in kwargs:
    rx0 = kwargs['rx0']
  rp = []
  if 'rp' in kwargs:
    rp = kwargs['rp']
  rz0 = []
  if 'rz0' in kwargs:
    rz0 = kwargs['rz0']
  for k in kwargs.keys():
    if not(k in ['x0','p','z0','rx0','rp','rz0']):
      raise Exception("Keyword error in integratorIn: '%s' is not recognized. Available keywords are: x0, p, z0, rx0, rp, rz0" % k )
  return IOSchemeVector([x0,p,z0,rx0,rp,rz0], IOScheme(SCHEME_IntegratorInput))


def integratorOut(*dummy,**kwargs):
  """
  Helper function for 'IntegratorOutput'

  Two use cases:
     a) arg = integratorOut(xf=my_xf, qf=my_qf, zf=my_zf, rxf=my_rxf, rqf=my_rqf, rzf=my_rzf)
          all arguments optional
     b) xf, qf, zf, rxf, rqf, rzf = integratorOut(arg,"xf", "qf", "zf", "rxf", "rqf", "rzf")
          all arguments after the first optional
  Output arguments of an integrator

  Keyword arguments::

    xf  -- Differential state at the final time [INTEGRATOR_XF]
    qf  -- Quadrature state at the final time [INTEGRATOR_QF]
    zf  -- Algebraic variable at the final time [INTEGRATOR_ZF]
    rxf -- Backward differential state at the initial time [INTEGRATOR_RXF]
    rqf -- Backward quadrature state at the initial time [INTEGRATOR_RQF]
    rzf -- Backward algebraic variable at the initial time [INTEGRATOR_RZF]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of integratorOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_IntegratorOutput,n)] for n in dummy[1:]]
  xf = []
  if 'xf' in kwargs:
    xf = kwargs['xf']
  qf = []
  if 'qf' in kwargs:
    qf = kwargs['qf']
  zf = []
  if 'zf' in kwargs:
    zf = kwargs['zf']
  rxf = []
  if 'rxf' in kwargs:
    rxf = kwargs['rxf']
  rqf = []
  if 'rqf' in kwargs:
    rqf = kwargs['rqf']
  rzf = []
  if 'rzf' in kwargs:
    rzf = kwargs['rzf']
  for k in kwargs.keys():
    if not(k in ['xf','qf','zf','rxf','rqf','rzf']):
      raise Exception("Keyword error in integratorOut: '%s' is not recognized. Available keywords are: xf, qf, zf, rxf, rqf, rzf" % k )
  return IOSchemeVector([xf,qf,zf,rxf,rqf,rzf], IOScheme(SCHEME_IntegratorOutput))


def linsolIn(*dummy,**kwargs):
  """
  Helper function for 'LinsolInput'

  Two use cases:
     a) arg = linsolIn(A=my_A, B=my_B)
          all arguments optional
     b) A, B = linsolIn(arg,"A", "B")
          all arguments after the first optional
  Input arguments of a linear solver

  Keyword arguments::

    A -- The square matrix A: sparse, (n x n). [LINSOL_A]
    B -- The right-hand-side matrix b: dense,  (n x m) [LINSOL_B]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of linsolIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LinsolInput,n)] for n in dummy[1:]]
  A = []
  if 'A' in kwargs:
    A = kwargs['A']
  B = []
  if 'B' in kwargs:
    B = kwargs['B']
  for k in kwargs.keys():
    if not(k in ['A','B']):
      raise Exception("Keyword error in linsolIn: '%s' is not recognized. Available keywords are: A, B" % k )
  return IOSchemeVector([A,B], IOScheme(SCHEME_LinsolInput))


def linsolOut(*dummy,**kwargs):
  """
  Helper function for 'LinsolOutput'

  Two use cases:
     a) arg = linsolOut(X=my_X)
          all arguments optional
     b) X = linsolOut(arg,"X")
          all arguments after the first optional
  Output arguments of a linear solver

  Keyword arguments::

    X -- Solution to the linear system of equations [LINSOL_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of linsolOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LinsolOutput,n)] for n in dummy[1:]]
  X = []
  if 'X' in kwargs:
    X = kwargs['X']
  for k in kwargs.keys():
    if not(k in ['X']):
      raise Exception("Keyword error in linsolOut: '%s' is not recognized. Available keywords are: X" % k )
  return IOSchemeVector([X], IOScheme(SCHEME_LinsolOutput))


def lpIn(*dummy,**kwargs):
  """
  Helper function for 'LpSolverInput'

  Two use cases:
     a) arg = lpIn(c=my_c, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
          all arguments optional
     b) c, a, lba, uba, lbx, ubx = lpIn(arg,"c", "a", "lba", "uba", "lbx", "ubx")
          all arguments after the first optional
  Input arguments of a LP problem

  Keyword arguments::

    c   -- The vector c: dense (n x 1) [LP_SOLVER_C]
    a   -- The matrix A: sparse, (nc x n) - product with x must be dense. [LP_SOLVER_A]
    lba -- dense, (nc x 1) [LP_SOLVER_LBA]
    uba -- dense, (nc x 1) [LP_SOLVER_UBA]
    lbx -- dense, (n x 1) [LP_SOLVER_LBX]
    ubx -- dense, (n x 1) [LP_SOLVER_UBX]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LpSolverInput,n)] for n in dummy[1:]]
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  for k in kwargs.keys():
    if not(k in ['c','a','lba','uba','lbx','ubx']):
      raise Exception("Keyword error in lpIn: '%s' is not recognized. Available keywords are: c, a, lba, uba, lbx, ubx" % k )
  return IOSchemeVector([c,a,lba,uba,lbx,ubx], IOScheme(SCHEME_LpSolverInput))


def lpOut(*dummy,**kwargs):
  """
  Helper function for 'LpSolverOutput'

  Two use cases:
     a) arg = lpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, cost, lam_a, lam_x = lpOut(arg,"x", "cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an LP Solver

  Keyword arguments::

    x     -- The primal solution [LP_SOLVER_X]
    cost  -- The optimal cost [LP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [LP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [LP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LpSolverOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','cost','lam_a','lam_x']):
      raise Exception("Keyword error in lpOut: '%s' is not recognized. Available keywords are: x, cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,cost,lam_a,lam_x], IOScheme(SCHEME_LpSolverOutput))


def lpStruct(*dummy,**kwargs):
  """
  Helper function for 'LPStruct'

  Two use cases:
     a) arg = lpStruct(a=my_a)
          all arguments optional
     b) a = lpStruct(arg,"a")
          all arguments after the first optional
  Structure specification of an LP

  Keyword arguments::

    a -- The matrix A: sparse [LP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LPStruct,n)] for n in dummy[1:]]
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['a']):
      raise Exception("Keyword error in lpStruct: '%s' is not recognized. Available keywords are: a" % k )
  return LPStructure([a])

class LPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'LPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::LPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> LPStructure
        __init__(casadi::LPStructIOSchemeVector<(casadi::Sparsity)> self, LPStructure other) -> LPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_LPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LPStructure
LPStructure_swigregister = _casadi_core.LPStructure_swigregister
LPStructure_swigregister(LPStructure)


def lrdleIn(*dummy,**kwargs):
  """
  Helper function for 'LR_DLEInput'

  Two use cases:
     a) arg = lrdleIn(a=my_a, v=my_v, c=my_c, h=my_h)
          all arguments optional
     b) a, v, c, h = lrdleIn(arg,"a", "v", "c", "h")
          all arguments after the first optional
  Input arguments of a \e dle solver

  Keyword arguments::

    a -- A matrix [LR_DLE_A]
    v -- V matrix [LR_DLE_V]
    c -- C matrix [LR_DLE_C]
    h -- H matrix: horizontal stack of all Hi [LR_DLE_H]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdleIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LR_DLEInput,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  for k in kwargs.keys():
    if not(k in ['a','v','c','h']):
      raise Exception("Keyword error in lrdleIn: '%s' is not recognized. Available keywords are: a, v, c, h" % k )
  return IOSchemeVector([a,v,c,h], IOScheme(SCHEME_LR_DLEInput))


def lrdleOut(*dummy,**kwargs):
  """
  Helper function for 'LR_DLEOutput'

  Two use cases:
     a) arg = lrdleOut(y=my_y)
          all arguments optional
     b) y = lrdleOut(arg,"y")
          all arguments after the first optional
  Output arguments of a \e dle solver

  Keyword arguments::

    y -- Y matrix, blkdiag form [LR_DLE_Y]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdleOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LR_DLEOutput,n)] for n in dummy[1:]]
  y = []
  if 'y' in kwargs:
    y = kwargs['y']
  for k in kwargs.keys():
    if not(k in ['y']):
      raise Exception("Keyword error in lrdleOut: '%s' is not recognized. Available keywords are: y" % k )
  return IOSchemeVector([y], IOScheme(SCHEME_LR_DLEOutput))


def lrdleStruct(*dummy,**kwargs):
  """
  Helper function for 'LrDleStruct'

  Two use cases:
     a) arg = lrdleStruct(a=my_a, v=my_v, c=my_c, h=my_h)
          all arguments optional
     b) a, v, c, h = lrdleStruct(arg,"a", "v", "c", "h")
          all arguments after the first optional
  Structure specification of a DLE

  Keyword arguments::

    a -- The matrix A [LR_DLE_STRUCT_A]
    v -- The matrix V [LR_DLE_STRUCT_V]
    c -- The matrix C (defaults to unity) [LR_DLE_STRUCT_C]
    h -- H matrix: horizontal stack of all Hi [LR_DLE_STRUCT_H]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdleStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LrDleStruct,n)] for n in dummy[1:]]
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  v = Sparsity()
  if 'v' in kwargs:
    v = kwargs['v']
  c = Sparsity()
  if 'c' in kwargs:
    c = kwargs['c']
  h = Sparsity()
  if 'h' in kwargs:
    h = kwargs['h']
  for k in kwargs.keys():
    if not(k in ['a','v','c','h']):
      raise Exception("Keyword error in lrdleStruct: '%s' is not recognized. Available keywords are: a, v, c, h" % k )
  return LrDleStructure([a,v,c,h])

class LrDleStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'LrDleStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LrDleStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LrDleStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::LrDleStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> LrDleStructure
        __init__(casadi::LrDleStructIOSchemeVector<(casadi::Sparsity)> self, LrDleStructure other) -> LrDleStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_LrDleStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LrDleStructure
LrDleStructure_swigregister = _casadi_core.LrDleStructure_swigregister
LrDleStructure_swigregister(LrDleStructure)


def lrdpleIn(*dummy,**kwargs):
  """
  Helper function for 'LR_DPLEInput'

  Two use cases:
     a) arg = lrdpleIn(a=my_a, v=my_v, c=my_c, h=my_h)
          all arguments optional
     b) a, v, c, h = lrdpleIn(arg,"a", "v", "c", "h")
          all arguments after the first optional
  Input arguments of a \e dple solver

  Keyword arguments::

    a -- A matrices (horzcat when const_dim, blkdiag otherwise) [LR_DPLE_A]
    v -- V matrices (horzcat when const_dim, blkdiag otherwise) [LR_DPLE_V]
    c -- C matrix [LR_DPLE_C]
    h -- H matrix: horizontal stack of all Hi [LR_DPLE_H]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdpleIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LR_DPLEInput,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  for k in kwargs.keys():
    if not(k in ['a','v','c','h']):
      raise Exception("Keyword error in lrdpleIn: '%s' is not recognized. Available keywords are: a, v, c, h" % k )
  return IOSchemeVector([a,v,c,h], IOScheme(SCHEME_LR_DPLEInput))


def lrdpleOut(*dummy,**kwargs):
  """
  Helper function for 'LR_DPLEOutput'

  Two use cases:
     a) arg = lrdpleOut(y=my_y)
          all arguments optional
     b) y = lrdpleOut(arg,"y")
          all arguments after the first optional
  Output arguments of a \e dple solver

  Keyword arguments::

    y -- Lyapunov matrix (horzcat when const_dim, blkdiag otherwise) (Cholesky of P if pos_def) [LR_DPLE_Y]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdpleOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LR_DPLEOutput,n)] for n in dummy[1:]]
  y = []
  if 'y' in kwargs:
    y = kwargs['y']
  for k in kwargs.keys():
    if not(k in ['y']):
      raise Exception("Keyword error in lrdpleOut: '%s' is not recognized. Available keywords are: y" % k )
  return IOSchemeVector([y], IOScheme(SCHEME_LR_DPLEOutput))


def lrdpleStruct(*dummy,**kwargs):
  """
  Helper function for 'LrDpleVecStruct'

  Two use cases:
     a) arg = lrdpleStruct(a=my_a, v=my_v, c=my_c, h=my_h)
          all arguments optional
     b) a, v, c, h = lrdpleStruct(arg,"a", "v", "c", "h")
          all arguments after the first optional
  Structure specification of a DPLE

  Keyword arguments::

    a -- Sparsities for A_i, blkdiag form [LR_Dple_STRUCT_A]
    v -- Sparsities for V_i, blkdiag form [LR_Dple_STRUCT_V]
    c -- Sparsities for C_i (defaults to unity), blkdiag form [LR_Dple_STRUCT_C]
    h -- Sparsities for H_i (defaults to unity), blkdiag form [LR_Dple_STRUCT_H]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of lrdpleStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_LrDpleVecStruct,n)] for n in dummy[1:]]
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  v = []
  if 'v' in kwargs:
    v = kwargs['v']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  for k in kwargs.keys():
    if not(k in ['a','v','c','h']):
      raise Exception("Keyword error in lrdpleStruct: '%s' is not recognized. Available keywords are: a, v, c, h" % k )
  return LrDpleVecStructure([a,v,c,h])

class LrDpleVecStructure(IOSchemeVectorSparsityVector):
    """
    [INTERNAL]
    Helper function for 'LrDpleVecStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsityVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LrDpleVecStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsityVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LrDpleVecStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::LrDpleVecStructIOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, SparsityVectorVector t) -> LrDpleVecStructure
        __init__(casadi::LrDpleVecStructIOSchemeVector<(std::vector<(casadi::Sparsity)>)> self, LrDpleVecStructure other) -> LrDpleVecStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_LrDpleVecStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_LrDpleVecStructure
LrDpleVecStructure_swigregister = _casadi_core.LrDpleVecStructure_swigregister
LrDpleVecStructure_swigregister(LrDpleVecStructure)


def nlpIn(*dummy,**kwargs):
  """
  Helper function for 'NLPInput'

  Two use cases:
     a) arg = nlpIn(x=my_x, p=my_p)
          all arguments optional
     b) x, p = nlpIn(arg,"x", "p")
          all arguments after the first optional
  Input arguments of an NLP function

  Keyword arguments::

    x -- Decision variable [NL_X]
    p -- Fixed parameter [NL_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of nlpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_NLPInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['x','p']):
      raise Exception("Keyword error in nlpIn: '%s' is not recognized. Available keywords are: x, p" % k )
  return IOSchemeVector([x,p], IOScheme(SCHEME_NLPInput))


def nlpOut(*dummy,**kwargs):
  """
  Helper function for 'NLPOutput'

  Two use cases:
     a) arg = nlpOut(f=my_f, g=my_g)
          all arguments optional
     b) f, g = nlpOut(arg,"f", "g")
          all arguments after the first optional
  Output arguments of an NLP function

  Keyword arguments::

    f -- Objective function [NL_F]
    g -- Constraint function [NL_G]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of nlpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_NLPOutput,n)] for n in dummy[1:]]
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  for k in kwargs.keys():
    if not(k in ['f','g']):
      raise Exception("Keyword error in nlpOut: '%s' is not recognized. Available keywords are: f, g" % k )
  return IOSchemeVector([f,g], IOScheme(SCHEME_NLPOutput))


def gradFIn(*dummy,**kwargs):
  """
  Helper function for 'GradFInput'

  Two use cases:
     a) arg = gradFIn(x=my_x, p=my_p)
          all arguments optional
     b) x, p = gradFIn(arg,"x", "p")
          all arguments after the first optional
  Input arguments of an NLP objective gradient function

  Keyword arguments::

    x -- Decision variable [GRADF_X]
    p -- Fixed parameter [GRADF_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of gradFIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_GradFInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['x','p']):
      raise Exception("Keyword error in gradFIn: '%s' is not recognized. Available keywords are: x, p" % k )
  return IOSchemeVector([x,p], IOScheme(SCHEME_GradFInput))


def gradFOut(*dummy,**kwargs):
  """
  Helper function for 'GradFOutput'

  Two use cases:
     a) arg = gradFOut(grad=my_grad, f=my_f, g=my_g)
          all arguments optional
     b) grad, f, g = gradFOut(arg,"grad", "f", "g")
          all arguments after the first optional
  Output arguments of an NLP objective gradient function

  Keyword arguments::

    grad -- Jacobian of the constraints [GRADF_GRAD]
    f    -- Objective function [GRADF_F]
    g    -- Constraint function [GRADF_G]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of gradFOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_GradFOutput,n)] for n in dummy[1:]]
  grad = []
  if 'grad' in kwargs:
    grad = kwargs['grad']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  for k in kwargs.keys():
    if not(k in ['grad','f','g']):
      raise Exception("Keyword error in gradFOut: '%s' is not recognized. Available keywords are: grad, f, g" % k )
  return IOSchemeVector([grad,f,g], IOScheme(SCHEME_GradFOutput))


def jacGIn(*dummy,**kwargs):
  """
  Helper function for 'JacGInput'

  Two use cases:
     a) arg = jacGIn(x=my_x, p=my_p)
          all arguments optional
     b) x, p = jacGIn(arg,"x", "p")
          all arguments after the first optional
  Input arguments of an NLP Jacobian function

  Keyword arguments::

    x -- Decision variable [JACG_X]
    p -- Fixed parameter [JACG_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of jacGIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_JacGInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  for k in kwargs.keys():
    if not(k in ['x','p']):
      raise Exception("Keyword error in jacGIn: '%s' is not recognized. Available keywords are: x, p" % k )
  return IOSchemeVector([x,p], IOScheme(SCHEME_JacGInput))


def jacGOut(*dummy,**kwargs):
  """
  Helper function for 'JacGOutput'

  Two use cases:
     a) arg = jacGOut(jac=my_jac, f=my_f, g=my_g)
          all arguments optional
     b) jac, f, g = jacGOut(arg,"jac", "f", "g")
          all arguments after the first optional
  Output arguments of an NLP Jacobian function

  Keyword arguments::

    jac -- Jacobian of the constraints [JACG_JAC]
    f   -- Objective function [JACG_F]
    g   -- Constraint function [JACG_G]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of jacGOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_JacGOutput,n)] for n in dummy[1:]]
  jac = []
  if 'jac' in kwargs:
    jac = kwargs['jac']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  for k in kwargs.keys():
    if not(k in ['jac','f','g']):
      raise Exception("Keyword error in jacGOut: '%s' is not recognized. Available keywords are: jac, f, g" % k )
  return IOSchemeVector([jac,f,g], IOScheme(SCHEME_JacGOutput))


def hessLagIn(*dummy,**kwargs):
  """
  Helper function for 'HessLagInput'

  Two use cases:
     a) arg = hessLagIn(x=my_x, p=my_p, lam_f=my_lam_f, lam_g=my_lam_g)
          all arguments optional
     b) x, p, lam_f, lam_g = hessLagIn(arg,"x", "p", "lam_f", "lam_g")
          all arguments after the first optional
  Input arguments of an NLP Hessian function

  Keyword arguments::

    x     -- Decision variable [HESSLAG_X]
    p     -- Fixed parameter [HESSLAG_P]
    lam_f -- NLP solver might use to scale the objective. [HESSLAG_LAM_F]
    lam_g -- Multiplier for g [HESSLAG_LAM_G]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of hessLagIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_HessLagInput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  lam_f = []
  if 'lam_f' in kwargs:
    lam_f = kwargs['lam_f']
  lam_g = []
  if 'lam_g' in kwargs:
    lam_g = kwargs['lam_g']
  for k in kwargs.keys():
    if not(k in ['x','p','lam_f','lam_g']):
      raise Exception("Keyword error in hessLagIn: '%s' is not recognized. Available keywords are: x, p, lam_f, lam_g" % k )
  return IOSchemeVector([x,p,lam_f,lam_g], IOScheme(SCHEME_HessLagInput))


def hessLagOut(*dummy,**kwargs):
  """
  Helper function for 'HessLagOutput'

  Two use cases:
     a) arg = hessLagOut(hess=my_hess, f=my_f, g=my_g, grad_x=my_grad_x, grad_p=my_grad_p)
          all arguments optional
     b) hess, f, g, grad_x, grad_p = hessLagOut(arg,"hess", "f", "g", "grad_x", "grad_p")
          all arguments after the first optional
  Output arguments of an NLP Hessian function

  Keyword arguments::

    hess   -- Hessian of the Lagrangian [HESSLAG_HESS]
    f      -- Objective function [HESSLAG_F]
    g      -- Constraint function [HESSLAG_G]
    grad_x -- Gradient of the Lagrangian with respect to x [HESSLAG_GRAD_X]
    grad_p -- Gradient of the Lagrangian with respect to p [HESSLAG_GRAD_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of hessLagOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_HessLagOutput,n)] for n in dummy[1:]]
  hess = []
  if 'hess' in kwargs:
    hess = kwargs['hess']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  grad_x = []
  if 'grad_x' in kwargs:
    grad_x = kwargs['grad_x']
  grad_p = []
  if 'grad_p' in kwargs:
    grad_p = kwargs['grad_p']
  for k in kwargs.keys():
    if not(k in ['hess','f','g','grad_x','grad_p']):
      raise Exception("Keyword error in hessLagOut: '%s' is not recognized. Available keywords are: hess, f, g, grad_x, grad_p" % k )
  return IOSchemeVector([hess,f,g,grad_x,grad_p], IOScheme(SCHEME_HessLagOutput))


def nlpSolverIn(*dummy,**kwargs):
  """
  Helper function for 'NlpSolverInput'

  Two use cases:
     a) arg = nlpSolverIn(x0=my_x0, p=my_p, lbx=my_lbx, ubx=my_ubx, lbg=my_lbg, ubg=my_ubg, lam_x0=my_lam_x0, lam_g0=my_lam_g0)
          all arguments optional
     b) x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0 = nlpSolverIn(arg,"x0", "p", "lbx", "ubx", "lbg", "ubg", "lam_x0", "lam_g0")
          all arguments after the first optional
  Input arguments of an NLP Solver

  Keyword arguments::

    x0     -- Decision variables, initial guess (nx x 1)  [NLP_SOLVER_X0]
    p      -- Value of fixed parameters (np x 1) [NLP_SOLVER_P]
    lbx    -- Decision variables lower bound (nx x 1), default -inf [NLP_SOLVER_LBX]
    ubx    -- Decision variables upper bound (nx x 1), default +inf [NLP_SOLVER_UBX]
    lbg    -- Constraints lower bound (ng x 1), default -inf [NLP_SOLVER_LBG]
    ubg    -- Constraints upper bound (ng x 1), default +inf [NLP_SOLVER_UBG]
    lam_x0 -- Lagrange multipliers for bounds on X, initial guess (nx x 1) [NLP_SOLVER_LAM_X0]
    lam_g0 -- Lagrange multipliers for bounds on G, initial guess (ng x 1) [NLP_SOLVER_LAM_G0]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of nlpSolverIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_NlpSolverInput,n)] for n in dummy[1:]]
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  lbg = []
  if 'lbg' in kwargs:
    lbg = kwargs['lbg']
  ubg = []
  if 'ubg' in kwargs:
    ubg = kwargs['ubg']
  lam_x0 = []
  if 'lam_x0' in kwargs:
    lam_x0 = kwargs['lam_x0']
  lam_g0 = []
  if 'lam_g0' in kwargs:
    lam_g0 = kwargs['lam_g0']
  for k in kwargs.keys():
    if not(k in ['x0','p','lbx','ubx','lbg','ubg','lam_x0','lam_g0']):
      raise Exception("Keyword error in nlpSolverIn: '%s' is not recognized. Available keywords are: x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0" % k )
  return IOSchemeVector([x0,p,lbx,ubx,lbg,ubg,lam_x0,lam_g0], IOScheme(SCHEME_NlpSolverInput))


def nlpSolverOut(*dummy,**kwargs):
  """
  Helper function for 'NlpSolverOutput'

  Two use cases:
     a) arg = nlpSolverOut(x=my_x, f=my_f, g=my_g, lam_x=my_lam_x, lam_g=my_lam_g, lam_p=my_lam_p)
          all arguments optional
     b) x, f, g, lam_x, lam_g, lam_p = nlpSolverOut(arg,"x", "f", "g", "lam_x", "lam_g", "lam_p")
          all arguments after the first optional
  Output arguments of an NLP Solver

  Keyword arguments::

    x     -- Decision variables at the optimal solution (nx x 1) [NLP_SOLVER_X]
    f     -- Cost function value at the optimal solution (1 x 1) [NLP_SOLVER_F]
    g     -- Constraints function at the optimal solution (ng x 1) [NLP_SOLVER_G]
    lam_x -- Lagrange multipliers for bounds on X at the solution (nx x 1) [NLP_SOLVER_LAM_X]
    lam_g -- Lagrange multipliers for bounds on G at the solution (ng x 1) [NLP_SOLVER_LAM_G]
    lam_p -- Lagrange multipliers for bounds on P at the solution (np x 1) [NLP_SOLVER_LAM_P]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of nlpSolverOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_NlpSolverOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  lam_g = []
  if 'lam_g' in kwargs:
    lam_g = kwargs['lam_g']
  lam_p = []
  if 'lam_p' in kwargs:
    lam_p = kwargs['lam_p']
  for k in kwargs.keys():
    if not(k in ['x','f','g','lam_x','lam_g','lam_p']):
      raise Exception("Keyword error in nlpSolverOut: '%s' is not recognized. Available keywords are: x, f, g, lam_x, lam_g, lam_p" % k )
  return IOSchemeVector([x,f,g,lam_x,lam_g,lam_p], IOScheme(SCHEME_NlpSolverOutput))


def qcqpIn(*dummy,**kwargs):
  """
  Helper function for 'QcqpSolverInput'

  Two use cases:
     a) arg = qcqpIn(h=my_h, g=my_g, p=my_p, q=my_q, r=my_r, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0)
          all arguments optional
     b) h, g, p, q, r, a, lba, uba, lbx, ubx, x0, lam_x0 = qcqpIn(arg,"h", "g", "p", "q", "r", "a", "lba", "uba", "lbx", "ubx", "x0", "lam_x0")
          all arguments after the first optional
  Input arguments of a QP problem

  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [QCQP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [QCQP_SOLVER_G]
    p      -- triangular part is actually used. The matrix is assumed to be symmetrical. [QCQP_SOLVER_P]
    q      -- The vertical stack of all qi: dense,  (nq n x 1) [QCQP_SOLVER_Q]
    r      -- The vertical stack of all scalars ri (nq x 1)  [QCQP_SOLVER_R]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [QCQP_SOLVER_A]
    lba    -- dense, (nc x 1) [QCQP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [QCQP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [QCQP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [QCQP_SOLVER_UBX]
    x0     -- dense, (n x 1) [QCQP_SOLVER_X0]
    lam_x0 -- dense [QCQP_SOLVER_LAM_X0]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qcqpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QcqpSolverInput,n)] for n in dummy[1:]]
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  q = []
  if 'q' in kwargs:
    q = kwargs['q']
  r = []
  if 'r' in kwargs:
    r = kwargs['r']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  lam_x0 = []
  if 'lam_x0' in kwargs:
    lam_x0 = kwargs['lam_x0']
  for k in kwargs.keys():
    if not(k in ['h','g','p','q','r','a','lba','uba','lbx','ubx','x0','lam_x0']):
      raise Exception("Keyword error in qcqpIn: '%s' is not recognized. Available keywords are: h, g, p, q, r, a, lba, uba, lbx, ubx, x0, lam_x0" % k )
  return IOSchemeVector([h,g,p,q,r,a,lba,uba,lbx,ubx,x0,lam_x0], IOScheme(SCHEME_QcqpSolverInput))


def qcqpOut(*dummy,**kwargs):
  """
  Helper function for 'QcqpSolverOutput'

  Two use cases:
     a) arg = qcqpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, cost, lam_a, lam_x = qcqpOut(arg,"x", "cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an QP Solver

  Keyword arguments::

    x     -- The primal solution [QCQP_SOLVER_X]
    cost  -- The optimal cost [QCQP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [QCQP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [QCQP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qcqpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QcqpSolverOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','cost','lam_a','lam_x']):
      raise Exception("Keyword error in qcqpOut: '%s' is not recognized. Available keywords are: x, cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,cost,lam_a,lam_x], IOScheme(SCHEME_QcqpSolverOutput))


def qcqpStruct(*dummy,**kwargs):
  """
  Helper function for 'QCQPStruct'

  Two use cases:
     a) arg = qcqpStruct(h=my_h, p=my_p, a=my_a)
          all arguments optional
     b) h, p, a = qcqpStruct(arg,"h", "p", "a")
          all arguments after the first optional
  Structure specification of a QP

  Keyword arguments::

    h -- The matrix is assumed to be symmetrical. [QCQP_STRUCT_H]
    p -- triangular part is actually used. The matrix is assumed to be symmetrical. [QCQP_STRUCT_P]
    a -- The matrix A: sparse, (nc x n) - product with x must be dense. [QCQP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qcqpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QCQPStruct,n)] for n in dummy[1:]]
  h = Sparsity()
  if 'h' in kwargs:
    h = kwargs['h']
  p = Sparsity()
  if 'p' in kwargs:
    p = kwargs['p']
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['h','p','a']):
      raise Exception("Keyword error in qcqpStruct: '%s' is not recognized. Available keywords are: h, p, a" % k )
  return QCQPStructure([h,p,a])

class QCQPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'QCQPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QCQPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QCQPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::QCQPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> QCQPStructure
        __init__(casadi::QCQPStructIOSchemeVector<(casadi::Sparsity)> self, QCQPStructure other) -> QCQPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_QCQPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_QCQPStructure
QCQPStructure_swigregister = _casadi_core.QCQPStructure_swigregister
QCQPStructure_swigregister(QCQPStructure)


def qpIn(*dummy,**kwargs):
  """
  Helper function for 'QpSolverInput'

  Two use cases:
     a) arg = qpIn(h=my_h, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0)
          all arguments optional
     b) h, g, a, lba, uba, lbx, ubx, x0, lam_x0 = qpIn(arg,"h", "g", "a", "lba", "uba", "lbx", "ubx", "x0", "lam_x0")
          all arguments after the first optional
  Input arguments of a QP problem

  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [QP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [QP_SOLVER_G]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [QP_SOLVER_A]
    lba    -- dense, (nc x 1) [QP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [QP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [QP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [QP_SOLVER_UBX]
    x0     -- dense, (n x 1) [QP_SOLVER_X0]
    lam_x0 -- dense [QP_SOLVER_LAM_X0]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QpSolverInput,n)] for n in dummy[1:]]
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  lam_x0 = []
  if 'lam_x0' in kwargs:
    lam_x0 = kwargs['lam_x0']
  for k in kwargs.keys():
    if not(k in ['h','g','a','lba','uba','lbx','ubx','x0','lam_x0']):
      raise Exception("Keyword error in qpIn: '%s' is not recognized. Available keywords are: h, g, a, lba, uba, lbx, ubx, x0, lam_x0" % k )
  return IOSchemeVector([h,g,a,lba,uba,lbx,ubx,x0,lam_x0], IOScheme(SCHEME_QpSolverInput))


def qpOut(*dummy,**kwargs):
  """
  Helper function for 'QpSolverOutput'

  Two use cases:
     a) arg = qpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, cost, lam_a, lam_x = qpOut(arg,"x", "cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an QP Solver

  Keyword arguments::

    x     -- The primal solution [QP_SOLVER_X]
    cost  -- The optimal cost [QP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [QP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [QP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QpSolverOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','cost','lam_a','lam_x']):
      raise Exception("Keyword error in qpOut: '%s' is not recognized. Available keywords are: x, cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,cost,lam_a,lam_x], IOScheme(SCHEME_QpSolverOutput))


def qpStruct(*dummy,**kwargs):
  """
  Helper function for 'QPStruct'

  Two use cases:
     a) arg = qpStruct(h=my_h, a=my_a)
          all arguments optional
     b) h, a = qpStruct(arg,"h", "a")
          all arguments after the first optional
  Structure specification of a QP

  Keyword arguments::

    h -- The matrix is assumed to be symmetrical. [QP_STRUCT_H]
    a -- The matrix A: sparse, (nc x n) - product with x must be dense. [QP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of qpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_QPStruct,n)] for n in dummy[1:]]
  h = Sparsity()
  if 'h' in kwargs:
    h = kwargs['h']
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['h','a']):
      raise Exception("Keyword error in qpStruct: '%s' is not recognized. Available keywords are: h, a" % k )
  return QPStructure([h,a])

class QPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'QPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::QPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> QPStructure
        __init__(casadi::QPStructIOSchemeVector<(casadi::Sparsity)> self, QPStructure other) -> QPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_QPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_QPStructure
QPStructure_swigregister = _casadi_core.QPStructure_swigregister
QPStructure_swigregister(QPStructure)


def sdpIn(*dummy,**kwargs):
  """
  Helper function for 'SDPInput'

  Two use cases:
     a) arg = sdpIn(f=my_f, c=my_c, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
          all arguments optional
     b) f, c, g, a, lba, uba, lbx, ubx = sdpIn(arg,"f", "c", "g", "a", "lba", "uba", "lbx", "ubx")
          all arguments after the first optional
  Input arguments of a SDP problem

  Keyword arguments::

    f   -- The horizontal stack of all matrices F_i: ( m x nm) [SDP_SOLVER_F]
    c   -- The vector c: ( n x 1) [SDP_SOLVER_C]
    g   -- The matrix G: ( m x m) [SDP_SOLVER_G]
    a   -- The matrix A: ( nc x n) [SDP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SDP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SDP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SDP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SDP_SOLVER_UBX]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDPInput,n)] for n in dummy[1:]]
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  for k in kwargs.keys():
    if not(k in ['f','c','g','a','lba','uba','lbx','ubx']):
      raise Exception("Keyword error in sdpIn: '%s' is not recognized. Available keywords are: f, c, g, a, lba, uba, lbx, ubx" % k )
  return IOSchemeVector([f,c,g,a,lba,uba,lbx,ubx], IOScheme(SCHEME_SDPInput))


def sdpOut(*dummy,**kwargs):
  """
  Helper function for 'SDPOutput'

  Two use cases:
     a) arg = sdpOut(x=my_x, p=my_p, dual=my_dual, cost=my_cost, dual_cost=my_dual_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, p, dual, cost, dual_cost, lam_a, lam_x = sdpOut(arg,"x", "p", "dual", "cost", "dual_cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an SDP Solver

  Keyword arguments::

    x         -- The primal solution (n x 1) - may be used as initial guess [SDP_SOLVER_X]
    p         -- The solution P (m x m) - may be used as initial guess [SDP_SOLVER_P]
    dual      -- The dual solution (m x m) - may be used as initial guess [SDP_SOLVER_DUAL]
    cost      -- The primal optimal cost (1 x 1) [SDP_SOLVER_COST]
    dual_cost -- The dual optimal cost (1 x 1) [SDP_SOLVER_DUAL_COST]
    lam_a     -- The dual solution corresponding to the linear constraints  (nc x 1) [SDP_SOLVER_LAM_A]
    lam_x     -- The dual solution corresponding to simple bounds  (n x 1) [SDP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDPOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  dual = []
  if 'dual' in kwargs:
    dual = kwargs['dual']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  dual_cost = []
  if 'dual_cost' in kwargs:
    dual_cost = kwargs['dual_cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','p','dual','cost','dual_cost','lam_a','lam_x']):
      raise Exception("Keyword error in sdpOut: '%s' is not recognized. Available keywords are: x, p, dual, cost, dual_cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,p,dual,cost,dual_cost,lam_a,lam_x], IOScheme(SCHEME_SDPOutput))


def sdpStruct(*dummy,**kwargs):
  """
  Helper function for 'SDPStruct'

  Two use cases:
     a) arg = sdpStruct(f=my_f, g=my_g, a=my_a)
          all arguments optional
     b) f, g, a = sdpStruct(arg,"f", "g", "a")
          all arguments after the first optional
  Structure specification of an SDP

  Keyword arguments::

    f -- The horizontal stack of all matrices F_i: ( m x nm) [SDP_STRUCT_F]
    g -- The matrix G: ( m x m) [SDP_STRUCT_G]
    a -- The matrix A: ( nc x n) [SDP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDPStruct,n)] for n in dummy[1:]]
  f = Sparsity()
  if 'f' in kwargs:
    f = kwargs['f']
  g = Sparsity()
  if 'g' in kwargs:
    g = kwargs['g']
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['f','g','a']):
      raise Exception("Keyword error in sdpStruct: '%s' is not recognized. Available keywords are: f, g, a" % k )
  return SDPStructure([f,g,a])

class SDPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'SDPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SDPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SDPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::SDPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> SDPStructure
        __init__(casadi::SDPStructIOSchemeVector<(casadi::Sparsity)> self, SDPStructure other) -> SDPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_SDPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SDPStructure
SDPStructure_swigregister = _casadi_core.SDPStructure_swigregister
SDPStructure_swigregister(SDPStructure)


def sdqpIn(*dummy,**kwargs):
  """
  Helper function for 'SDQPInput'

  Two use cases:
     a) arg = sdqpIn(h=my_h, c=my_c, f=my_f, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
          all arguments optional
     b) h, c, f, g, a, lba, uba, lbx, ubx = sdqpIn(arg,"h", "c", "f", "g", "a", "lba", "uba", "lbx", "ubx")
          all arguments after the first optional
  Input arguments of a SDQP problem

  Keyword arguments::

    h   -- The matrix H: sparse ( n x n) [SDQP_SOLVER_H]
    c   -- The vector c: ( n x 1) [SDQP_SOLVER_C]
    f   -- The horizontal stack of all matrices F_i: ( m x nm) [SDQP_SOLVER_F]
    g   -- The matrix G: ( m x m) [SDQP_SOLVER_G]
    a   -- The matrix A: ( nc x n) [SDQP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SDQP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SDQP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SDQP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SDQP_SOLVER_UBX]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdqpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDQPInput,n)] for n in dummy[1:]]
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  for k in kwargs.keys():
    if not(k in ['h','c','f','g','a','lba','uba','lbx','ubx']):
      raise Exception("Keyword error in sdqpIn: '%s' is not recognized. Available keywords are: h, c, f, g, a, lba, uba, lbx, ubx" % k )
  return IOSchemeVector([h,c,f,g,a,lba,uba,lbx,ubx], IOScheme(SCHEME_SDQPInput))


def sdqpOut(*dummy,**kwargs):
  """
  Helper function for 'SDQPOutput'

  Two use cases:
     a) arg = sdqpOut(x=my_x, p=my_p, dual=my_dual, cost=my_cost, dual_cost=my_dual_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, p, dual, cost, dual_cost, lam_a, lam_x = sdqpOut(arg,"x", "p", "dual", "cost", "dual_cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an SDQP Solver

  Keyword arguments::

    x         -- The primal solution (n x 1) - may be used as initial guess [SDQP_SOLVER_X]
    p         -- The solution P (m x m) - may be used as initial guess [SDQP_SOLVER_P]
    dual      -- The dual solution (m x m) - may be used as initial guess [SDQP_SOLVER_DUAL]
    cost      -- The primal optimal cost (1 x 1) [SDQP_SOLVER_COST]
    dual_cost -- The dual optimal cost (1 x 1) [SDQP_SOLVER_DUAL_COST]
    lam_a     -- The dual solution corresponding to the linear constraints  (nc x 1) [SDQP_SOLVER_LAM_A]
    lam_x     -- The dual solution corresponding to simple bounds  (n x 1) [SDQP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdqpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDQPOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  p = []
  if 'p' in kwargs:
    p = kwargs['p']
  dual = []
  if 'dual' in kwargs:
    dual = kwargs['dual']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  dual_cost = []
  if 'dual_cost' in kwargs:
    dual_cost = kwargs['dual_cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','p','dual','cost','dual_cost','lam_a','lam_x']):
      raise Exception("Keyword error in sdqpOut: '%s' is not recognized. Available keywords are: x, p, dual, cost, dual_cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,p,dual,cost,dual_cost,lam_a,lam_x], IOScheme(SCHEME_SDQPOutput))


def sdqpStruct(*dummy,**kwargs):
  """
  Helper function for 'SDQPStruct'

  Two use cases:
     a) arg = sdqpStruct(h=my_h, f=my_f, g=my_g, a=my_a)
          all arguments optional
     b) h, f, g, a = sdqpStruct(arg,"h", "f", "g", "a")
          all arguments after the first optional
  Structure specification of an SDQP

  Keyword arguments::

    h -- The matrix H: sparse ( n x n) [SDQP_STRUCT_H]
    f -- The horizontal stack of all matrices F_i: ( m x nm) [SDQP_STRUCT_F]
    g -- The matrix G: ( m x m) [SDQP_STRUCT_G]
    a -- The matrix A: ( nc x n) [SDQP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of sdqpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SDQPStruct,n)] for n in dummy[1:]]
  h = Sparsity()
  if 'h' in kwargs:
    h = kwargs['h']
  f = Sparsity()
  if 'f' in kwargs:
    f = kwargs['f']
  g = Sparsity()
  if 'g' in kwargs:
    g = kwargs['g']
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['h','f','g','a']):
      raise Exception("Keyword error in sdqpStruct: '%s' is not recognized. Available keywords are: h, f, g, a" % k )
  return SDQPStructure([h,f,g,a])

class SDQPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'SDQPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SDQPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SDQPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::SDQPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> SDQPStructure
        __init__(casadi::SDQPStructIOSchemeVector<(casadi::Sparsity)> self, SDQPStructure other) -> SDQPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_SDQPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SDQPStructure
SDQPStructure_swigregister = _casadi_core.SDQPStructure_swigregister
SDQPStructure_swigregister(SDQPStructure)


def socpIn(*dummy,**kwargs):
  """
  Helper function for 'SOCPInput'

  Two use cases:
     a) arg = socpIn(g=my_g, h=my_h, e=my_e, f=my_f, c=my_c, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
          all arguments optional
     b) g, h, e, f, c, a, lba, uba, lbx, ubx = socpIn(arg,"g", "h", "e", "f", "c", "a", "lba", "uba", "lbx", "ubx")
          all arguments after the first optional
  Input arguments of a SOCP problem

  Keyword arguments::

    g   -- The horizontal stack of all matrices Gi: ( n x N) [SOCP_SOLVER_G]
    h   -- The vertical stack of all vectors hi: ( N x 1) [SOCP_SOLVER_H]
    e   -- The vertical stack of all vectors ei: ( nm x 1) [SOCP_SOLVER_E]
    f   -- The vertical stack of all scalars fi: ( m x 1) [SOCP_SOLVER_F]
    c   -- The vector c: ( n x 1) [SOCP_SOLVER_C]
    a   -- The matrix A: ( nc x n) [SOCP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SOCP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SOCP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SOCP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SOCP_SOLVER_UBX]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of socpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SOCPInput,n)] for n in dummy[1:]]
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  e = []
  if 'e' in kwargs:
    e = kwargs['e']
  f = []
  if 'f' in kwargs:
    f = kwargs['f']
  c = []
  if 'c' in kwargs:
    c = kwargs['c']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  for k in kwargs.keys():
    if not(k in ['g','h','e','f','c','a','lba','uba','lbx','ubx']):
      raise Exception("Keyword error in socpIn: '%s' is not recognized. Available keywords are: g, h, e, f, c, a, lba, uba, lbx, ubx" % k )
  return IOSchemeVector([g,h,e,f,c,a,lba,uba,lbx,ubx], IOScheme(SCHEME_SOCPInput))


def socpOut(*dummy,**kwargs):
  """
  Helper function for 'SOCPOutput'

  Two use cases:
     a) arg = socpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
          all arguments optional
     b) x, cost, lam_a, lam_x = socpOut(arg,"x", "cost", "lam_a", "lam_x")
          all arguments after the first optional
  Output arguments of an SOCP Solver

  Keyword arguments::

    x     -- The primal solution (n x 1) [SOCP_SOLVER_X]
    cost  -- The primal optimal cost (1 x 1) [SOCP_SOLVER_COST]
    lam_a -- The dual solution corresponding to the linear constraints  (nc x 1) [SOCP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds  (n x 1) [SOCP_SOLVER_LAM_X]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of socpOut. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SOCPOutput,n)] for n in dummy[1:]]
  x = []
  if 'x' in kwargs:
    x = kwargs['x']
  cost = []
  if 'cost' in kwargs:
    cost = kwargs['cost']
  lam_a = []
  if 'lam_a' in kwargs:
    lam_a = kwargs['lam_a']
  lam_x = []
  if 'lam_x' in kwargs:
    lam_x = kwargs['lam_x']
  for k in kwargs.keys():
    if not(k in ['x','cost','lam_a','lam_x']):
      raise Exception("Keyword error in socpOut: '%s' is not recognized. Available keywords are: x, cost, lam_a, lam_x" % k )
  return IOSchemeVector([x,cost,lam_a,lam_x], IOScheme(SCHEME_SOCPOutput))


def socpStruct(*dummy,**kwargs):
  """
  Helper function for 'SOCPStruct'

  Two use cases:
     a) arg = socpStruct(g=my_g, a=my_a)
          all arguments optional
     b) g, a = socpStruct(arg,"g", "a")
          all arguments after the first optional
  Structure specification of an SOCP

  Keyword arguments::

    g -- The horizontal stack of all matrices Gi: ( n x N) [SOCP_STRUCT_G]
    a -- The matrix A: ( nc x n) [SOCP_STRUCT_A]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of socpStruct. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_SOCPStruct,n)] for n in dummy[1:]]
  g = Sparsity()
  if 'g' in kwargs:
    g = kwargs['g']
  a = Sparsity()
  if 'a' in kwargs:
    a = kwargs['a']
  for k in kwargs.keys():
    if not(k in ['g','a']):
      raise Exception("Keyword error in socpStruct: '%s' is not recognized. Available keywords are: g, a" % k )
  return SOCPStructure([g,a])

class SOCPStructure(IOSchemeVectorSparsity):
    """
    [INTERNAL]  Helper
    function for 'SOCPStruct'

    C++ includes: casadi_types.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SOCPStructure, name, value)
    __swig_getmethods__ = {}
    for _s in [IOSchemeVectorSparsity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SOCPStructure, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(casadi::SOCPStructIOSchemeVector<(casadi::Sparsity)> self, SparsityVector t) -> SOCPStructure
        __init__(casadi::SOCPStructIOSchemeVector<(casadi::Sparsity)> self, SOCPStructure other) -> SOCPStructure

        [INTERNAL] 
        """
        this = _casadi_core.new_SOCPStructure(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SOCPStructure
SOCPStructure_swigregister = _casadi_core.SOCPStructure_swigregister
SOCPStructure_swigregister(SOCPStructure)


def stabilizedQpIn(*dummy,**kwargs):
  """
  Helper function for 'StabilizedQpSolverInput'

  Two use cases:
     a) arg = stabilizedQpIn(h=my_h, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0, muR=my_muR, muE=my_muE, mu=my_mu)
          all arguments optional
     b) h, g, a, lba, uba, lbx, ubx, x0, lam_x0, muR, muE, mu = stabilizedQpIn(arg,"h", "g", "a", "lba", "uba", "lbx", "ubx", "x0", "lam_x0", "muR", "muE", "mu")
          all arguments after the first optional
  Input arguments of a QP problem

  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [STABILIZED_QP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [STABILIZED_QP_SOLVER_G]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [STABILIZED_QP_SOLVER_A]
    lba    -- dense, (nc x 1) [STABILIZED_QP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [STABILIZED_QP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [STABILIZED_QP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [STABILIZED_QP_SOLVER_UBX]
    x0     -- dense, (n x 1) [STABILIZED_QP_SOLVER_X0]
    lam_x0 -- dense [STABILIZED_QP_SOLVER_LAM_X0]
    muR    -- dense (1 x 1) [STABILIZED_QP_SOLVER_MUR]
    muE    -- dense (nc x 1) [STABILIZED_QP_SOLVER_MUE]
    mu     -- dense (nc x 1) [STABILIZED_QP_SOLVER_MU]
  """
  if (len(dummy)>0 and len(kwargs)>0): raise Exception("Cannot mix two use cases of stabilizedQpIn. Either use keywords or non-keywords ")
  if len(dummy)>0: return [ dummy[0][getSchemeEntryEnum(SCHEME_StabilizedQpSolverInput,n)] for n in dummy[1:]]
  h = []
  if 'h' in kwargs:
    h = kwargs['h']
  g = []
  if 'g' in kwargs:
    g = kwargs['g']
  a = []
  if 'a' in kwargs:
    a = kwargs['a']
  lba = []
  if 'lba' in kwargs:
    lba = kwargs['lba']
  uba = []
  if 'uba' in kwargs:
    uba = kwargs['uba']
  lbx = []
  if 'lbx' in kwargs:
    lbx = kwargs['lbx']
  ubx = []
  if 'ubx' in kwargs:
    ubx = kwargs['ubx']
  x0 = []
  if 'x0' in kwargs:
    x0 = kwargs['x0']
  lam_x0 = []
  if 'lam_x0' in kwargs:
    lam_x0 = kwargs['lam_x0']
  muR = []
  if 'muR' in kwargs:
    muR = kwargs['muR']
  muE = []
  if 'muE' in kwargs:
    muE = kwargs['muE']
  mu = []
  if 'mu' in kwargs:
    mu = kwargs['mu']
  for k in kwargs.keys():
    if not(k in ['h','g','a','lba','uba','lbx','ubx','x0','lam_x0','muR','muE','mu']):
      raise Exception("Keyword error in stabilizedQpIn: '%s' is not recognized. Available keywords are: h, g, a, lba, uba, lbx, ubx, x0, lam_x0, muR, muE, mu" % k )
  return IOSchemeVector([h,g,a,lba,uba,lbx,ubx,x0,lam_x0,muR,muE,mu], IOScheme(SCHEME_StabilizedQpSolverInput))

class CasadiOptions(_object):
    """


    Collects global CasADi options.

    Note to developers: use sparingly. Global options are - in general - a
    rather bad idea

    this class must never be instantiated. Access its static members directly
    Joris Gillis

    C++ includes: casadi_options.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CasadiOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CasadiOptions, name)
    __repr__ = _swig_repr

    def setCatchErrorsSwig(*args):
        """setCatchErrorsSwig(bool flag)"""
        return _casadi_core.CasadiOptions_setCatchErrorsSwig(*args)

    if _newclass:
        setCatchErrorsSwig = staticmethod(setCatchErrorsSwig)
    __swig_getmethods__["setCatchErrorsSwig"] = lambda x: setCatchErrorsSwig

    def getCatchErrorsSwig(*args):
        """getCatchErrorsSwig() -> bool"""
        return _casadi_core.CasadiOptions_getCatchErrorsSwig(*args)

    if _newclass:
        getCatchErrorsSwig = staticmethod(getCatchErrorsSwig)
    __swig_getmethods__["getCatchErrorsSwig"] = lambda x: getCatchErrorsSwig

    def setSimplificationOnTheFly(*args):
        """setSimplificationOnTheFly(bool flag)"""
        return _casadi_core.CasadiOptions_setSimplificationOnTheFly(*args)

    if _newclass:
        setSimplificationOnTheFly = staticmethod(setSimplificationOnTheFly)
    __swig_getmethods__["setSimplificationOnTheFly"] = lambda x: setSimplificationOnTheFly

    def getSimplificationOnTheFly(*args):
        """getSimplificationOnTheFly() -> bool"""
        return _casadi_core.CasadiOptions_getSimplificationOnTheFly(*args)

    if _newclass:
        getSimplificationOnTheFly = staticmethod(getSimplificationOnTheFly)
    __swig_getmethods__["getSimplificationOnTheFly"] = lambda x: getSimplificationOnTheFly

    def startProfiling(*args):
        """startProfiling(std::string const & filename)"""
        return _casadi_core.CasadiOptions_startProfiling(*args)

    if _newclass:
        startProfiling = staticmethod(startProfiling)
    __swig_getmethods__["startProfiling"] = lambda x: startProfiling

    def stopProfiling(*args):
        """stopProfiling()"""
        return _casadi_core.CasadiOptions_stopProfiling(*args)

    if _newclass:
        stopProfiling = staticmethod(stopProfiling)
    __swig_getmethods__["stopProfiling"] = lambda x: stopProfiling

    def setProfilingBinary(*args):
        """setProfilingBinary(bool flag)"""
        return _casadi_core.CasadiOptions_setProfilingBinary(*args)

    if _newclass:
        setProfilingBinary = staticmethod(setProfilingBinary)
    __swig_getmethods__["setProfilingBinary"] = lambda x: setProfilingBinary

    def getProfilingBinary(*args):
        """getProfilingBinary() -> bool"""
        return _casadi_core.CasadiOptions_getProfilingBinary(*args)

    if _newclass:
        getProfilingBinary = staticmethod(getProfilingBinary)
    __swig_getmethods__["getProfilingBinary"] = lambda x: getProfilingBinary

    def setPurgeSeeds(*args):
        """
        setPurgeSeeds(bool flag)
        setPurgeSeeds() -> bool
        """
        return _casadi_core.CasadiOptions_setPurgeSeeds(*args)

    if _newclass:
        setPurgeSeeds = staticmethod(setPurgeSeeds)
    __swig_getmethods__["setPurgeSeeds"] = lambda x: setPurgeSeeds

    def setAllowedInternalAPI(*args):
        """setAllowedInternalAPI(bool flag)"""
        return _casadi_core.CasadiOptions_setAllowedInternalAPI(*args)

    if _newclass:
        setAllowedInternalAPI = staticmethod(setAllowedInternalAPI)
    __swig_getmethods__["setAllowedInternalAPI"] = lambda x: setAllowedInternalAPI

    def getAllowedInternalAPI(*args):
        """getAllowedInternalAPI() -> bool"""
        return _casadi_core.CasadiOptions_getAllowedInternalAPI(*args)

    if _newclass:
        getAllowedInternalAPI = staticmethod(getAllowedInternalAPI)
    __swig_getmethods__["getAllowedInternalAPI"] = lambda x: getAllowedInternalAPI

    def __init__(self, *args):
        """__init__(casadi::CasadiOptions self, CasadiOptions other) -> CasadiOptions"""
        this = _casadi_core.new_CasadiOptions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CasadiOptions
CasadiOptions_swigregister = _casadi_core.CasadiOptions_swigregister
CasadiOptions_swigregister(CasadiOptions)

def CasadiOptions_setCatchErrorsSwig(*args):
    """CasadiOptions_setCatchErrorsSwig(bool flag)"""
    return _casadi_core.CasadiOptions_setCatchErrorsSwig(*args)

def CasadiOptions_getCatchErrorsSwig(*args):
    """CasadiOptions_getCatchErrorsSwig() -> bool"""
    return _casadi_core.CasadiOptions_getCatchErrorsSwig(*args)

def CasadiOptions_setSimplificationOnTheFly(*args):
    """CasadiOptions_setSimplificationOnTheFly(bool flag)"""
    return _casadi_core.CasadiOptions_setSimplificationOnTheFly(*args)

def CasadiOptions_getSimplificationOnTheFly(*args):
    """CasadiOptions_getSimplificationOnTheFly() -> bool"""
    return _casadi_core.CasadiOptions_getSimplificationOnTheFly(*args)

def CasadiOptions_startProfiling(*args):
    """CasadiOptions_startProfiling(std::string const & filename)"""
    return _casadi_core.CasadiOptions_startProfiling(*args)

def CasadiOptions_stopProfiling(*args):
    """CasadiOptions_stopProfiling()"""
    return _casadi_core.CasadiOptions_stopProfiling(*args)

def CasadiOptions_setProfilingBinary(*args):
    """CasadiOptions_setProfilingBinary(bool flag)"""
    return _casadi_core.CasadiOptions_setProfilingBinary(*args)

def CasadiOptions_getProfilingBinary(*args):
    """CasadiOptions_getProfilingBinary() -> bool"""
    return _casadi_core.CasadiOptions_getProfilingBinary(*args)

def CasadiOptions_setPurgeSeeds(*args):
    """
    setPurgeSeeds(bool flag)
    CasadiOptions_setPurgeSeeds() -> bool
    """
    return _casadi_core.CasadiOptions_setPurgeSeeds(*args)

def CasadiOptions_setAllowedInternalAPI(*args):
    """CasadiOptions_setAllowedInternalAPI(bool flag)"""
    return _casadi_core.CasadiOptions_setAllowedInternalAPI(*args)

def CasadiOptions_getAllowedInternalAPI(*args):
    """CasadiOptions_getAllowedInternalAPI() -> bool"""
    return _casadi_core.CasadiOptions_getAllowedInternalAPI(*args)

class CasadiMeta(_object):
    """


    Collects global CasADi meta information.

    Joris Gillis

    C++ includes: casadi_meta.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CasadiMeta, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CasadiMeta, name)
    __repr__ = _swig_repr

    def getVersion(*args):
        """getVersion() -> std::string"""
        return _casadi_core.CasadiMeta_getVersion(*args)

    if _newclass:
        getVersion = staticmethod(getVersion)
    __swig_getmethods__["getVersion"] = lambda x: getVersion

    def getGitRevision(*args):
        """getGitRevision() -> std::string"""
        return _casadi_core.CasadiMeta_getGitRevision(*args)

    if _newclass:
        getGitRevision = staticmethod(getGitRevision)
    __swig_getmethods__["getGitRevision"] = lambda x: getGitRevision

    def getGitDescribe(*args):
        """getGitDescribe() -> std::string"""
        return _casadi_core.CasadiMeta_getGitDescribe(*args)

    if _newclass:
        getGitDescribe = staticmethod(getGitDescribe)
    __swig_getmethods__["getGitDescribe"] = lambda x: getGitDescribe

    def getFeatureList(*args):
        """getFeatureList() -> std::string"""
        return _casadi_core.CasadiMeta_getFeatureList(*args)

    if _newclass:
        getFeatureList = staticmethod(getFeatureList)
    __swig_getmethods__["getFeatureList"] = lambda x: getFeatureList

    def getBuildType(*args):
        """getBuildType() -> std::string"""
        return _casadi_core.CasadiMeta_getBuildType(*args)

    if _newclass:
        getBuildType = staticmethod(getBuildType)
    __swig_getmethods__["getBuildType"] = lambda x: getBuildType

    def getCompilerId(*args):
        """getCompilerId() -> std::string"""
        return _casadi_core.CasadiMeta_getCompilerId(*args)

    if _newclass:
        getCompilerId = staticmethod(getCompilerId)
    __swig_getmethods__["getCompilerId"] = lambda x: getCompilerId

    def getCompiler(*args):
        """getCompiler() -> std::string"""
        return _casadi_core.CasadiMeta_getCompiler(*args)

    if _newclass:
        getCompiler = staticmethod(getCompiler)
    __swig_getmethods__["getCompiler"] = lambda x: getCompiler

    def getCompilerFlags(*args):
        """getCompilerFlags() -> std::string"""
        return _casadi_core.CasadiMeta_getCompilerFlags(*args)

    if _newclass:
        getCompilerFlags = staticmethod(getCompilerFlags)
    __swig_getmethods__["getCompilerFlags"] = lambda x: getCompilerFlags

    def getModules(*args):
        """getModules() -> std::string"""
        return _casadi_core.CasadiMeta_getModules(*args)

    if _newclass:
        getModules = staticmethod(getModules)
    __swig_getmethods__["getModules"] = lambda x: getModules

    def getPlugins(*args):
        """getPlugins() -> std::string"""
        return _casadi_core.CasadiMeta_getPlugins(*args)

    if _newclass:
        getPlugins = staticmethod(getPlugins)
    __swig_getmethods__["getPlugins"] = lambda x: getPlugins

    def __init__(self, *args):
        """__init__(casadi::CasadiMeta self, CasadiMeta other) -> CasadiMeta"""
        this = _casadi_core.new_CasadiMeta(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_CasadiMeta
CasadiMeta_swigregister = _casadi_core.CasadiMeta_swigregister
CasadiMeta_swigregister(CasadiMeta)

def CasadiMeta_getVersion(*args):
    """CasadiMeta_getVersion() -> std::string"""
    return _casadi_core.CasadiMeta_getVersion(*args)

def CasadiMeta_getGitRevision(*args):
    """CasadiMeta_getGitRevision() -> std::string"""
    return _casadi_core.CasadiMeta_getGitRevision(*args)

def CasadiMeta_getGitDescribe(*args):
    """CasadiMeta_getGitDescribe() -> std::string"""
    return _casadi_core.CasadiMeta_getGitDescribe(*args)

def CasadiMeta_getFeatureList(*args):
    """CasadiMeta_getFeatureList() -> std::string"""
    return _casadi_core.CasadiMeta_getFeatureList(*args)

def CasadiMeta_getBuildType(*args):
    """CasadiMeta_getBuildType() -> std::string"""
    return _casadi_core.CasadiMeta_getBuildType(*args)

def CasadiMeta_getCompilerId(*args):
    """CasadiMeta_getCompilerId() -> std::string"""
    return _casadi_core.CasadiMeta_getCompilerId(*args)

def CasadiMeta_getCompiler(*args):
    """CasadiMeta_getCompiler() -> std::string"""
    return _casadi_core.CasadiMeta_getCompiler(*args)

def CasadiMeta_getCompilerFlags(*args):
    """CasadiMeta_getCompilerFlags() -> std::string"""
    return _casadi_core.CasadiMeta_getCompilerFlags(*args)

def CasadiMeta_getModules(*args):
    """CasadiMeta_getModules() -> std::string"""
    return _casadi_core.CasadiMeta_getModules(*args)

def CasadiMeta_getPlugins(*args):
    """CasadiMeta_getPlugins() -> std::string"""
    return _casadi_core.CasadiMeta_getPlugins(*args)


def collocationPoints(*args):
    """
    collocationPoints(int order, std::string const & scheme) -> DVector



    Obtain collocation points of specific order and scheme.

    Parameters:
    -----------

    scheme:  'radau' or 'legendre'


    """
    return _casadi_core.collocationPoints(*args)

def collocationInterpolators(*args):
    """
    collocationInterpolators(DVector tau_root)

    [INTERNAL]  Obtain
    collocation interpolating matrices.

    Parameters:
    -----------

    tau_root:  location of collocation points, as obtained from
    collocationPoints

    C:  interpolating coefficients to obtain derivatives Length: order+1, order
    + 1

    dX/dt (j) ~ Sum_i C[j][i]*X(i)

    Parameters:
    -----------

    D:  interpolating coefficients to obtain end state Length: order+1


    """
    return _casadi_core.collocationInterpolators(*args)

_casadi_core.LEGENDRE_swigconstant(_casadi_core)
LEGENDRE = _casadi_core.LEGENDRE

_casadi_core.RADAU_swigconstant(_casadi_core)
RADAU = _casadi_core.RADAU

def explicitRK(*args):
    """
    explicitRK(Function f, MX tf=1, int order=4, int ne=1) -> Function



    Construct an explicit Runge-Kutta integrator.

    Parameters:
    -----------

    f:  dynamical system

    >Input scheme: casadi::DAEInput (DAE_NUM_IN = 4) [daeIn]

    +-----------+-------+----------------------------+
    | Full name | Short |        Description         |
    +===========+=======+============================+
    | DAE_X     | x     | Differential state .       |
    +-----------+-------+----------------------------+
    | DAE_Z     | z     | Algebraic state .          |
    +-----------+-------+----------------------------+
    | DAE_P     | p     | Parameter .                |
    +-----------+-------+----------------------------+
    | DAE_T     | t     | Explicit time dependence . |
    +-----------+-------+----------------------------+

    >Output scheme: casadi::DAEOutput (DAE_NUM_OUT = 3) [daeOut]

    +-----------+-------+--------------------------------------------+
    | Full name | Short |                Description                 |
    +===========+=======+============================================+
    | DAE_ODE   | ode   | Right hand side of the implicit ODE .      |
    +-----------+-------+--------------------------------------------+
    | DAE_ALG   | alg   | Right hand side of algebraic equations .   |
    +-----------+-------+--------------------------------------------+
    | DAE_QUAD  | quad  | Right hand side of quadratures equations . |
    +-----------+-------+--------------------------------------------+

    Parameters:
    -----------

    tf:  Integration end time

    order:  Order of integration

    ne:  Number of times the RK primitive is repeated over the integration
    interval


    """
    return _casadi_core.explicitRK(*args)

def implicitRK(*args):
    """
    implicitRK(Function f, std::string const & impl, Dictionary dict, MX tf=1, int order=4, std::string const & scheme, int ne=1) -> Function



    Construct an implicit Runge-Kutta integrator.

    Parameters:
    -----------

    f:  dynamical system

    >Input scheme: casadi::DAEInput (DAE_NUM_IN = 4) [daeIn]

    +-----------+-------+----------------------------+
    | Full name | Short |        Description         |
    +===========+=======+============================+
    | DAE_X     | x     | Differential state .       |
    +-----------+-------+----------------------------+
    | DAE_Z     | z     | Algebraic state .          |
    +-----------+-------+----------------------------+
    | DAE_P     | p     | Parameter .                |
    +-----------+-------+----------------------------+
    | DAE_T     | t     | Explicit time dependence . |
    +-----------+-------+----------------------------+

    >Output scheme: casadi::DAEOutput (DAE_NUM_OUT = 3) [daeOut]

    +-----------+-------+--------------------------------------------+
    | Full name | Short |                Description                 |
    +===========+=======+============================================+
    | DAE_ODE   | ode   | Right hand side of the implicit ODE .      |
    +-----------+-------+--------------------------------------------+
    | DAE_ALG   | alg   | Right hand side of algebraic equations .   |
    +-----------+-------+--------------------------------------------+
    | DAE_QUAD  | quad  | Right hand side of quadratures equations . |
    +-----------+-------+--------------------------------------------+

    Parameters:
    -----------

    tf:  Integration end time

    order:  Order of integration

    scheme:  Collocation scheme, as excepted by collocationPoints function.

    ne:  Number of times the RK primitive is repeated over the integration
    interval


    """
    return _casadi_core.implicitRK(*args)
class SymbolicNLP(PrintSymbolicNLP):
    """


    A symbolic NLP representation.

    Joel Andersson

    C++ includes: symbolic_nlp.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintSymbolicNLP]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolicNLP, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSymbolicNLP]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolicNLP, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _casadi_core.SymbolicNLP_x_set
    __swig_getmethods__["x"] = _casadi_core.SymbolicNLP_x_get
    if _newclass:
        x = _swig_property(_casadi_core.SymbolicNLP_x_get, _casadi_core.SymbolicNLP_x_set)
    __swig_setmethods__["f"] = _casadi_core.SymbolicNLP_f_set
    __swig_getmethods__["f"] = _casadi_core.SymbolicNLP_f_get
    if _newclass:
        f = _swig_property(_casadi_core.SymbolicNLP_f_get, _casadi_core.SymbolicNLP_f_set)
    __swig_setmethods__["g"] = _casadi_core.SymbolicNLP_g_set
    __swig_getmethods__["g"] = _casadi_core.SymbolicNLP_g_get
    if _newclass:
        g = _swig_property(_casadi_core.SymbolicNLP_g_get, _casadi_core.SymbolicNLP_g_set)
    __swig_setmethods__["x_lb"] = _casadi_core.SymbolicNLP_x_lb_set
    __swig_getmethods__["x_lb"] = _casadi_core.SymbolicNLP_x_lb_get
    if _newclass:
        x_lb = _swig_property(_casadi_core.SymbolicNLP_x_lb_get, _casadi_core.SymbolicNLP_x_lb_set)
    __swig_setmethods__["x_ub"] = _casadi_core.SymbolicNLP_x_ub_set
    __swig_getmethods__["x_ub"] = _casadi_core.SymbolicNLP_x_ub_get
    if _newclass:
        x_ub = _swig_property(_casadi_core.SymbolicNLP_x_ub_get, _casadi_core.SymbolicNLP_x_ub_set)
    __swig_setmethods__["g_lb"] = _casadi_core.SymbolicNLP_g_lb_set
    __swig_getmethods__["g_lb"] = _casadi_core.SymbolicNLP_g_lb_get
    if _newclass:
        g_lb = _swig_property(_casadi_core.SymbolicNLP_g_lb_get, _casadi_core.SymbolicNLP_g_lb_set)
    __swig_setmethods__["g_ub"] = _casadi_core.SymbolicNLP_g_ub_set
    __swig_getmethods__["g_ub"] = _casadi_core.SymbolicNLP_g_ub_get
    if _newclass:
        g_ub = _swig_property(_casadi_core.SymbolicNLP_g_ub_get, _casadi_core.SymbolicNLP_g_ub_set)
    __swig_setmethods__["x_init"] = _casadi_core.SymbolicNLP_x_init_set
    __swig_getmethods__["x_init"] = _casadi_core.SymbolicNLP_x_init_get
    if _newclass:
        x_init = _swig_property(_casadi_core.SymbolicNLP_x_init_get, _casadi_core.SymbolicNLP_x_init_set)
    __swig_setmethods__["lambda_init"] = _casadi_core.SymbolicNLP_lambda_init_set
    __swig_getmethods__["lambda_init"] = _casadi_core.SymbolicNLP_lambda_init_get
    if _newclass:
        lambda_init = _swig_property(_casadi_core.SymbolicNLP_lambda_init_get, _casadi_core.SymbolicNLP_lambda_init_set)

    def parseNL(self, *args):
        """
        parseNL(SymbolicNLP self, std::string const & filename, Dictionary options)



        Parse an AMPL och PyOmo NL-file.


        """
        return _casadi_core.SymbolicNLP_parseNL(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::SymbolicNLP self) -> SymbolicNLP
        __init__(casadi::SymbolicNLP self, SymbolicNLP other) -> SymbolicNLP
        """
        this = _casadi_core.new_SymbolicNLP(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SymbolicNLP
SymbolicNLP_swigregister = _casadi_core.SymbolicNLP_swigregister
SymbolicNLP_swigregister(SymbolicNLP)


_casadi_core.CONSTANT_swigconstant(_casadi_core)
CONSTANT = _casadi_core.CONSTANT

_casadi_core.PARAMETER_swigconstant(_casadi_core)
PARAMETER = _casadi_core.PARAMETER

_casadi_core.DISCRETE_swigconstant(_casadi_core)
DISCRETE = _casadi_core.DISCRETE

_casadi_core.CONTINUOUS_swigconstant(_casadi_core)
CONTINUOUS = _casadi_core.CONTINUOUS

_casadi_core.INPUT_swigconstant(_casadi_core)
INPUT = _casadi_core.INPUT

_casadi_core.OUTPUT_swigconstant(_casadi_core)
OUTPUT = _casadi_core.OUTPUT

_casadi_core.INTERNAL_swigconstant(_casadi_core)
INTERNAL = _casadi_core.INTERNAL

_casadi_core.ALGEBRAIC_swigconstant(_casadi_core)
ALGEBRAIC = _casadi_core.ALGEBRAIC

_casadi_core.DIFFERENTIAL_swigconstant(_casadi_core)
DIFFERENTIAL = _casadi_core.DIFFERENTIAL

_casadi_core.NO_ALIAS_swigconstant(_casadi_core)
NO_ALIAS = _casadi_core.NO_ALIAS

_casadi_core.ALIAS_swigconstant(_casadi_core)
ALIAS = _casadi_core.ALIAS

_casadi_core.NEGATED_ALIAS_swigconstant(_casadi_core)
NEGATED_ALIAS = _casadi_core.NEGATED_ALIAS

_casadi_core.CAT_UNKNOWN_swigconstant(_casadi_core)
CAT_UNKNOWN = _casadi_core.CAT_UNKNOWN

_casadi_core.CAT_DERIVATIVE_swigconstant(_casadi_core)
CAT_DERIVATIVE = _casadi_core.CAT_DERIVATIVE

_casadi_core.CAT_STATE_swigconstant(_casadi_core)
CAT_STATE = _casadi_core.CAT_STATE

_casadi_core.CAT_DEPENDENT_CONSTANT_swigconstant(_casadi_core)
CAT_DEPENDENT_CONSTANT = _casadi_core.CAT_DEPENDENT_CONSTANT

_casadi_core.CAT_INDEPENDENT_CONSTANT_swigconstant(_casadi_core)
CAT_INDEPENDENT_CONSTANT = _casadi_core.CAT_INDEPENDENT_CONSTANT

_casadi_core.CAT_DEPENDENT_PARAMETER_swigconstant(_casadi_core)
CAT_DEPENDENT_PARAMETER = _casadi_core.CAT_DEPENDENT_PARAMETER

_casadi_core.CAT_INDEPENDENT_PARAMETER_swigconstant(_casadi_core)
CAT_INDEPENDENT_PARAMETER = _casadi_core.CAT_INDEPENDENT_PARAMETER

_casadi_core.CAT_ALGEBRAIC_swigconstant(_casadi_core)
CAT_ALGEBRAIC = _casadi_core.CAT_ALGEBRAIC
class Variable(PrintVariable):
    """


    Holds expressions and meta-data corresponding to a physical quantity
    evolving in time.

    Joel Andersson

    C++ includes: variable.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintVariable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintVariable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    __repr__ = _swig_repr

    def name(self, *args):
        """
        name(Variable self) -> std::string



        Variable name.


        """
        return _casadi_core.Variable_name(self, *args)


    def setName(self, *args):
        """
        setName(Variable self, std::string const & name)



        Set the variable name (and corresponding expressions)


        """
        return _casadi_core.Variable_setName(self, *args)

    __swig_setmethods__["v"] = _casadi_core.Variable_v_set
    __swig_getmethods__["v"] = _casadi_core.Variable_v_get
    if _newclass:
        v = _swig_property(_casadi_core.Variable_v_get, _casadi_core.Variable_v_set)
    __swig_setmethods__["d"] = _casadi_core.Variable_d_set
    __swig_getmethods__["d"] = _casadi_core.Variable_d_get
    if _newclass:
        d = _swig_property(_casadi_core.Variable_d_get, _casadi_core.Variable_d_set)
    __swig_setmethods__["beq"] = _casadi_core.Variable_beq_set
    __swig_getmethods__["beq"] = _casadi_core.Variable_beq_get
    if _newclass:
        beq = _swig_property(_casadi_core.Variable_beq_get, _casadi_core.Variable_beq_set)
    __swig_setmethods__["ode"] = _casadi_core.Variable_ode_set
    __swig_getmethods__["ode"] = _casadi_core.Variable_ode_get
    if _newclass:
        ode = _swig_property(_casadi_core.Variable_ode_get, _casadi_core.Variable_ode_set)
    __swig_setmethods__["nominal"] = _casadi_core.Variable_nominal_set
    __swig_getmethods__["nominal"] = _casadi_core.Variable_nominal_get
    if _newclass:
        nominal = _swig_property(_casadi_core.Variable_nominal_get, _casadi_core.Variable_nominal_set)
    __swig_setmethods__["start"] = _casadi_core.Variable_start_set
    __swig_getmethods__["start"] = _casadi_core.Variable_start_get
    if _newclass:
        start = _swig_property(_casadi_core.Variable_start_get, _casadi_core.Variable_start_set)
    __swig_setmethods__["min"] = _casadi_core.Variable_min_set
    __swig_getmethods__["min"] = _casadi_core.Variable_min_get
    if _newclass:
        min = _swig_property(_casadi_core.Variable_min_get, _casadi_core.Variable_min_set)
    __swig_setmethods__["max"] = _casadi_core.Variable_max_set
    __swig_getmethods__["max"] = _casadi_core.Variable_max_get
    if _newclass:
        max = _swig_property(_casadi_core.Variable_max_get, _casadi_core.Variable_max_set)
    __swig_setmethods__["initialGuess"] = _casadi_core.Variable_initialGuess_set
    __swig_getmethods__["initialGuess"] = _casadi_core.Variable_initialGuess_get
    if _newclass:
        initialGuess = _swig_property(_casadi_core.Variable_initialGuess_get, _casadi_core.Variable_initialGuess_set)
    __swig_setmethods__["derivativeStart"] = _casadi_core.Variable_derivativeStart_set
    __swig_getmethods__["derivativeStart"] = _casadi_core.Variable_derivativeStart_get
    if _newclass:
        derivativeStart = _swig_property(_casadi_core.Variable_derivativeStart_get, _casadi_core.Variable_derivativeStart_set)
    __swig_setmethods__["variability"] = _casadi_core.Variable_variability_set
    __swig_getmethods__["variability"] = _casadi_core.Variable_variability_get
    if _newclass:
        variability = _swig_property(_casadi_core.Variable_variability_get, _casadi_core.Variable_variability_set)
    __swig_setmethods__["causality"] = _casadi_core.Variable_causality_set
    __swig_getmethods__["causality"] = _casadi_core.Variable_causality_get
    if _newclass:
        causality = _swig_property(_casadi_core.Variable_causality_get, _casadi_core.Variable_causality_set)
    __swig_setmethods__["category"] = _casadi_core.Variable_category_set
    __swig_getmethods__["category"] = _casadi_core.Variable_category_get
    if _newclass:
        category = _swig_property(_casadi_core.Variable_category_get, _casadi_core.Variable_category_set)
    __swig_setmethods__["alias"] = _casadi_core.Variable_alias_set
    __swig_getmethods__["alias"] = _casadi_core.Variable_alias_get
    if _newclass:
        alias = _swig_property(_casadi_core.Variable_alias_get, _casadi_core.Variable_alias_set)
    __swig_setmethods__["description"] = _casadi_core.Variable_description_set
    __swig_getmethods__["description"] = _casadi_core.Variable_description_get
    if _newclass:
        description = _swig_property(_casadi_core.Variable_description_get, _casadi_core.Variable_description_set)
    __swig_setmethods__["valueReference"] = _casadi_core.Variable_valueReference_set
    __swig_getmethods__["valueReference"] = _casadi_core.Variable_valueReference_get
    if _newclass:
        valueReference = _swig_property(_casadi_core.Variable_valueReference_get, _casadi_core.Variable_valueReference_set)
    __swig_setmethods__["unit"] = _casadi_core.Variable_unit_set
    __swig_getmethods__["unit"] = _casadi_core.Variable_unit_get
    if _newclass:
        unit = _swig_property(_casadi_core.Variable_unit_get, _casadi_core.Variable_unit_set)
    __swig_setmethods__["displayUnit"] = _casadi_core.Variable_displayUnit_set
    __swig_getmethods__["displayUnit"] = _casadi_core.Variable_displayUnit_get
    if _newclass:
        displayUnit = _swig_property(_casadi_core.Variable_displayUnit_get, _casadi_core.Variable_displayUnit_set)
    __swig_setmethods__["index"] = _casadi_core.Variable_index_set
    __swig_getmethods__["index"] = _casadi_core.Variable_index_get
    if _newclass:
        index = _swig_property(_casadi_core.Variable_index_get, _casadi_core.Variable_index_set)
    __swig_setmethods__["free"] = _casadi_core.Variable_free_set
    __swig_getmethods__["free"] = _casadi_core.Variable_free_get
    if _newclass:
        free = _swig_property(_casadi_core.Variable_free_get, _casadi_core.Variable_free_set)

    def atTime(self, *args):
        """
        atTime(Variable self, double t, bool allocate=False) -> SXElement
        atTime(Variable self, double t, bool allocate=False) -> SXElement



        >  SXElement casadi::Variable::atTime(double t, bool allocate=false) const 
        ------------------------------------------------------------------------

        Timed variable (never allocate)

        >  SXElement casadi::Variable::atTime(double t, bool allocate=false)
        ------------------------------------------------------------------------

        Timed variable (allocate if necessary)


        """
        return _casadi_core.Variable_atTime(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::Variable self) -> Variable
        __init__(casadi::Variable self, Variable other) -> Variable



        Default constructor.


        """
        this = _casadi_core.new_Variable(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_Variable
Variable_swigregister = _casadi_core.Variable_swigregister
Variable_swigregister(Variable)

class SymbolicOCP(PrintSymbolicOCP):
    """


    A flat OCP representation coupled to an XML file.

    Variables:
    ==========





    ::

      x:      differential states
      z:      algebraic states
      p :     independent parameters
      t :     time
      u :     control signals
      q :     quadrature states
      y :     dependent variables




    Equations:
    ==========





    ::

      explicit or implicit ODE: \\dot {x} = ode(t, x, z, u, p_free, pi, pd)
      or                           0 = ode(t, x, z,\\dot {x}, u, p_free, pi, pd)
      algebraic equations:            0 = alg(t, x, z, u, p_free, pi, pd)
      quadratures:              \\dot {q} = quad(t, x, z, u, p_free, pi, pd)
      dependent equations:            y = dep(t, x, z, u, p_free, pi, pd)
      initial equations:              0 = initial(t, x, z, u, p_free, pi, pd)




    Objective function terms:
    =========================





    ::

      Mayer terms:          \\sum {mterm_k}
      Lagrange terms:       \\sum {\\integral{mterm}}




    Note that when parsed, all dynamic equations end up in the implicit category
    "dae". At a later state, the DAE can be reformulated, for example in semi-
    explicit form, possibly in addition to a set of quadrature states.

    Usage skeleton:
    ===============



    Call default constructor  SymbolicOCP ocp;

    Parse an FMI conformant XML file ocp.parseFMI(xml_file_name)

    Modify/add variables, equations, optimization ...

    When the optimal control problem is in a suitable form, it is possible to
    either generate functions for numeric/symbolic evaluation or exporting the
    OCP formulation into a new FMI conformant XML file. The latter functionality
    is not yet available.

    Joel Andersson

    C++ includes: symbolic_ocp.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [PrintSymbolicOCP]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolicOCP, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSymbolicOCP]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolicOCP, name)
    __repr__ = _swig_repr
    __swig_setmethods__["t"] = _casadi_core.SymbolicOCP_t_set
    __swig_getmethods__["t"] = _casadi_core.SymbolicOCP_t_get
    if _newclass:
        t = _swig_property(_casadi_core.SymbolicOCP_t_get, _casadi_core.SymbolicOCP_t_set)
    __swig_setmethods__["s"] = _casadi_core.SymbolicOCP_s_set
    __swig_getmethods__["s"] = _casadi_core.SymbolicOCP_s_get
    if _newclass:
        s = _swig_property(_casadi_core.SymbolicOCP_s_get, _casadi_core.SymbolicOCP_s_set)
    __swig_setmethods__["dae"] = _casadi_core.SymbolicOCP_dae_set
    __swig_getmethods__["dae"] = _casadi_core.SymbolicOCP_dae_get
    if _newclass:
        dae = _swig_property(_casadi_core.SymbolicOCP_dae_get, _casadi_core.SymbolicOCP_dae_set)
    __swig_setmethods__["initial"] = _casadi_core.SymbolicOCP_initial_set
    __swig_getmethods__["initial"] = _casadi_core.SymbolicOCP_initial_get
    if _newclass:
        initial = _swig_property(_casadi_core.SymbolicOCP_initial_get, _casadi_core.SymbolicOCP_initial_set)
    __swig_setmethods__["x"] = _casadi_core.SymbolicOCP_x_set
    __swig_getmethods__["x"] = _casadi_core.SymbolicOCP_x_get
    if _newclass:
        x = _swig_property(_casadi_core.SymbolicOCP_x_get, _casadi_core.SymbolicOCP_x_set)
    __swig_setmethods__["z"] = _casadi_core.SymbolicOCP_z_set
    __swig_getmethods__["z"] = _casadi_core.SymbolicOCP_z_get
    if _newclass:
        z = _swig_property(_casadi_core.SymbolicOCP_z_get, _casadi_core.SymbolicOCP_z_set)
    __swig_setmethods__["alg"] = _casadi_core.SymbolicOCP_alg_set
    __swig_getmethods__["alg"] = _casadi_core.SymbolicOCP_alg_get
    if _newclass:
        alg = _swig_property(_casadi_core.SymbolicOCP_alg_get, _casadi_core.SymbolicOCP_alg_set)
    __swig_setmethods__["q"] = _casadi_core.SymbolicOCP_q_set
    __swig_getmethods__["q"] = _casadi_core.SymbolicOCP_q_get
    if _newclass:
        q = _swig_property(_casadi_core.SymbolicOCP_q_get, _casadi_core.SymbolicOCP_q_set)
    __swig_setmethods__["y"] = _casadi_core.SymbolicOCP_y_set
    __swig_getmethods__["y"] = _casadi_core.SymbolicOCP_y_get
    if _newclass:
        y = _swig_property(_casadi_core.SymbolicOCP_y_get, _casadi_core.SymbolicOCP_y_set)
    __swig_setmethods__["u"] = _casadi_core.SymbolicOCP_u_set
    __swig_getmethods__["u"] = _casadi_core.SymbolicOCP_u_get
    if _newclass:
        u = _swig_property(_casadi_core.SymbolicOCP_u_get, _casadi_core.SymbolicOCP_u_set)
    __swig_setmethods__["p"] = _casadi_core.SymbolicOCP_p_set
    __swig_getmethods__["p"] = _casadi_core.SymbolicOCP_p_get
    if _newclass:
        p = _swig_property(_casadi_core.SymbolicOCP_p_get, _casadi_core.SymbolicOCP_p_set)
    __swig_setmethods__["pi"] = _casadi_core.SymbolicOCP_pi_set
    __swig_getmethods__["pi"] = _casadi_core.SymbolicOCP_pi_get
    if _newclass:
        pi = _swig_property(_casadi_core.SymbolicOCP_pi_get, _casadi_core.SymbolicOCP_pi_set)
    __swig_setmethods__["pd"] = _casadi_core.SymbolicOCP_pd_set
    __swig_getmethods__["pd"] = _casadi_core.SymbolicOCP_pd_get
    if _newclass:
        pd = _swig_property(_casadi_core.SymbolicOCP_pd_get, _casadi_core.SymbolicOCP_pd_set)
    __swig_setmethods__["ci"] = _casadi_core.SymbolicOCP_ci_set
    __swig_getmethods__["ci"] = _casadi_core.SymbolicOCP_ci_get
    if _newclass:
        ci = _swig_property(_casadi_core.SymbolicOCP_ci_get, _casadi_core.SymbolicOCP_ci_set)
    __swig_setmethods__["cd"] = _casadi_core.SymbolicOCP_cd_set
    __swig_getmethods__["cd"] = _casadi_core.SymbolicOCP_cd_get
    if _newclass:
        cd = _swig_property(_casadi_core.SymbolicOCP_cd_get, _casadi_core.SymbolicOCP_cd_set)
    __swig_setmethods__["t0"] = _casadi_core.SymbolicOCP_t0_set
    __swig_getmethods__["t0"] = _casadi_core.SymbolicOCP_t0_get
    if _newclass:
        t0 = _swig_property(_casadi_core.SymbolicOCP_t0_get, _casadi_core.SymbolicOCP_t0_set)
    __swig_setmethods__["tf"] = _casadi_core.SymbolicOCP_tf_set
    __swig_getmethods__["tf"] = _casadi_core.SymbolicOCP_tf_get
    if _newclass:
        tf = _swig_property(_casadi_core.SymbolicOCP_tf_get, _casadi_core.SymbolicOCP_tf_set)
    __swig_setmethods__["t0_free"] = _casadi_core.SymbolicOCP_t0_free_set
    __swig_getmethods__["t0_free"] = _casadi_core.SymbolicOCP_t0_free_get
    if _newclass:
        t0_free = _swig_property(_casadi_core.SymbolicOCP_t0_free_get, _casadi_core.SymbolicOCP_t0_free_set)
    __swig_setmethods__["tf_free"] = _casadi_core.SymbolicOCP_tf_free_set
    __swig_getmethods__["tf_free"] = _casadi_core.SymbolicOCP_tf_free_get
    if _newclass:
        tf_free = _swig_property(_casadi_core.SymbolicOCP_tf_free_get, _casadi_core.SymbolicOCP_tf_free_set)
    __swig_setmethods__["t0_guess"] = _casadi_core.SymbolicOCP_t0_guess_set
    __swig_getmethods__["t0_guess"] = _casadi_core.SymbolicOCP_t0_guess_get
    if _newclass:
        t0_guess = _swig_property(_casadi_core.SymbolicOCP_t0_guess_get, _casadi_core.SymbolicOCP_t0_guess_set)
    __swig_setmethods__["tf_guess"] = _casadi_core.SymbolicOCP_tf_guess_set
    __swig_getmethods__["tf_guess"] = _casadi_core.SymbolicOCP_tf_guess_get
    if _newclass:
        tf_guess = _swig_property(_casadi_core.SymbolicOCP_tf_guess_get, _casadi_core.SymbolicOCP_tf_guess_set)
    __swig_setmethods__["tp"] = _casadi_core.SymbolicOCP_tp_set
    __swig_getmethods__["tp"] = _casadi_core.SymbolicOCP_tp_get
    if _newclass:
        tp = _swig_property(_casadi_core.SymbolicOCP_tp_get, _casadi_core.SymbolicOCP_tp_set)
    __swig_setmethods__["mterm"] = _casadi_core.SymbolicOCP_mterm_set
    __swig_getmethods__["mterm"] = _casadi_core.SymbolicOCP_mterm_get
    if _newclass:
        mterm = _swig_property(_casadi_core.SymbolicOCP_mterm_get, _casadi_core.SymbolicOCP_mterm_set)
    __swig_setmethods__["lterm"] = _casadi_core.SymbolicOCP_lterm_set
    __swig_getmethods__["lterm"] = _casadi_core.SymbolicOCP_lterm_get
    if _newclass:
        lterm = _swig_property(_casadi_core.SymbolicOCP_lterm_get, _casadi_core.SymbolicOCP_lterm_set)
    __swig_setmethods__["path"] = _casadi_core.SymbolicOCP_path_set
    __swig_getmethods__["path"] = _casadi_core.SymbolicOCP_path_get
    if _newclass:
        path = _swig_property(_casadi_core.SymbolicOCP_path_get, _casadi_core.SymbolicOCP_path_set)
    __swig_setmethods__["point"] = _casadi_core.SymbolicOCP_point_set
    __swig_getmethods__["point"] = _casadi_core.SymbolicOCP_point_get
    if _newclass:
        point = _swig_property(_casadi_core.SymbolicOCP_point_get, _casadi_core.SymbolicOCP_point_set)

    def parseFMI(self, *args):
        """
        parseFMI(SymbolicOCP self, std::string const & filename)



        Parse from XML to C++ format.


        """
        return _casadi_core.SymbolicOCP_parseFMI(self, *args)


    def addVariable(self, *args):
        """
        addVariable(SymbolicOCP self, std::string const & name, Variable var)



        Add a variable.


        """
        return _casadi_core.SymbolicOCP_addVariable(self, *args)


    def variable(self, *args):
        """
        variable(SymbolicOCP self, std::string const & name) -> Variable
        variable(SymbolicOCP self, std::string const & name) -> Variable



        Access a variable by name


        """
        return _casadi_core.SymbolicOCP_variable(self, *args)


    def separateAlgebraic(self, *args):
        """
        separateAlgebraic(SymbolicOCP self)



        Identify and separate the algebraic variables and equations in the DAE.


        """
        return _casadi_core.SymbolicOCP_separateAlgebraic(self, *args)


    def eliminateAlgebraic(self, *args):
        """
        eliminateAlgebraic(SymbolicOCP self)



        Eliminate algebraic variables, transforming them into outputs.


        """
        return _casadi_core.SymbolicOCP_eliminateAlgebraic(self, *args)


    def makeSemiExplicit(self, *args):
        """
        makeSemiExplicit(SymbolicOCP self)



        Transform the implicit DAE to a semi-explicit DAE.


        """
        return _casadi_core.SymbolicOCP_makeSemiExplicit(self, *args)


    def makeExplicit(self, *args):
        """
        makeExplicit(SymbolicOCP self)



        Transform the implicit DAE or semi-explicit DAE into an explicit ODE.


        """
        return _casadi_core.SymbolicOCP_makeExplicit(self, *args)


    def eliminateIndependentParameters(self, *args):
        """
        eliminateIndependentParameters(SymbolicOCP self)



        Eliminate independent parameters.


        """
        return _casadi_core.SymbolicOCP_eliminateIndependentParameters(self, *args)


    def sortDependentParameters(self, *args):
        """
        sortDependentParameters(SymbolicOCP self)



        Sort the dependent parameters.


        """
        return _casadi_core.SymbolicOCP_sortDependentParameters(self, *args)


    def eliminateDependentParameterInterdependencies(self, *args):
        """
        eliminateDependentParameterInterdependencies(SymbolicOCP self)



        Eliminate interdependencies amongst the dependent parameters.


        """
        return _casadi_core.SymbolicOCP_eliminateDependentParameterInterdependencies(self, *args)


    def eliminateDependentParameters(self, *args):
        """
        eliminateDependentParameters(SymbolicOCP self)



        Eliminate dependent parameters.


        """
        return _casadi_core.SymbolicOCP_eliminateDependentParameters(self, *args)


    def sortOutputs(self, *args):
        """
        sortOutputs(SymbolicOCP self)



        Sort the outputs.


        """
        return _casadi_core.SymbolicOCP_sortOutputs(self, *args)


    def eliminateOutputInterdependencies(self, *args):
        """
        eliminateOutputInterdependencies(SymbolicOCP self)



        Eliminate interdependencies amongst the outputs.


        """
        return _casadi_core.SymbolicOCP_eliminateOutputInterdependencies(self, *args)


    def eliminateOutputs(self, *args):
        """
        eliminateOutputs(SymbolicOCP self)



        Eliminate outputs.


        """
        return _casadi_core.SymbolicOCP_eliminateOutputs(self, *args)


    def eliminateLagrangeTerms(self, *args):
        """
        eliminateLagrangeTerms(SymbolicOCP self)



        Eliminate Lagrange terms from the objective function and make them
        quadrature states.


        """
        return _casadi_core.SymbolicOCP_eliminateLagrangeTerms(self, *args)


    def eliminateQuadratureStates(self, *args):
        """
        eliminateQuadratureStates(SymbolicOCP self)



        Eliminate quadrature states and turn them into ODE states.


        """
        return _casadi_core.SymbolicOCP_eliminateQuadratureStates(self, *args)


    def sortDAE(self, *args):
        """
        sortDAE(SymbolicOCP self)



        Sort the DAE and implicitly defined states.


        """
        return _casadi_core.SymbolicOCP_sortDAE(self, *args)


    def sortALG(self, *args):
        """
        sortALG(SymbolicOCP self)



        Sort the algebraic equations and algebraic states.


        """
        return _casadi_core.SymbolicOCP_sortALG(self, *args)


    def generateMuscodDatFile(self, *args):
        """
        generateMuscodDatFile(SymbolicOCP self, std::string const & filename, Dictionary mc2_ops)



        Generate a MUSCOD-II compatible DAT file.


        """
        return _casadi_core.SymbolicOCP_generateMuscodDatFile(self, *args)


    def scaleVariables(self, *args):
        """
        scaleVariables(SymbolicOCP self)



        Scale the variables.


        """
        return _casadi_core.SymbolicOCP_scaleVariables(self, *args)


    def scaleEquations(self, *args):
        """
        scaleEquations(SymbolicOCP self)



        Scale the implicit equations.


        """
        return _casadi_core.SymbolicOCP_scaleEquations(self, *args)


    def __call__(self, *args):
        """__call__(SymbolicOCP self, std::string const & name) -> SX"""
        return _casadi_core.SymbolicOCP___call__(self, *args)


    def der(self, *args):
        """
        der(SymbolicOCP self, std::string const & name) -> SX
        der(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::der(const std::string &name) const 
        ------------------------------------------------------------------------

        Get a derivative expression by name.

        >  SX casadi::SymbolicOCP::der(const SX &var) const 
        ------------------------------------------------------------------------

        Get a derivative expression by non-differentiated expression.


        """
        return _casadi_core.SymbolicOCP_der(self, *args)


    def beq(self, *args):
        """
        beq(SymbolicOCP self, std::string const & name) -> SX
        beq(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::beq(const std::string &name) const 
        ------------------------------------------------------------------------

        Get a binding equation by name.

        >  SX casadi::SymbolicOCP::beq(const SX &var) const 
        ------------------------------------------------------------------------

        Get a binding equation by non-differentiated expression.


        """
        return _casadi_core.SymbolicOCP_beq(self, *args)


    def setBeq(self, *args):
        """
        setBeq(SymbolicOCP self, std::string const & name, SX val)
        setBeq(SymbolicOCP self, SX var, SX val)



        >  void casadi::SymbolicOCP::setBeq(const std::string &name, const SX &val)
        ------------------------------------------------------------------------

        Set a binding equation by name.

        >  void casadi::SymbolicOCP::setBeq(const SX &var, const SX &val)
        ------------------------------------------------------------------------

        Set an binding expression by non-differentiated expression.


        """
        return _casadi_core.SymbolicOCP_setBeq(self, *args)


    def ode(self, *args):
        """
        ode(SymbolicOCP self, std::string const & name) -> SX
        ode(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::ode(const std::string &name) const 
        ------------------------------------------------------------------------

        Get a derivative binding equation (i.e. ordinary differential equation, ODE)
        by name.

        Returns variable expression if unknown.

        >  SX casadi::SymbolicOCP::ode(const SX &var) const 
        ------------------------------------------------------------------------

        Get a derivative binding expression (i.e. ordinary differential equation,
        ODE) by non-differentiated expression.

        Returns derivative expression if unknown.


        """
        return _casadi_core.SymbolicOCP_ode(self, *args)


    def setOde(self, *args):
        """
        setOde(SymbolicOCP self, std::string const & name, SX val)
        setOde(SymbolicOCP self, SX var, SX val)



        >  void casadi::SymbolicOCP::setOde(const std::string &name, const SX &val)
        ------------------------------------------------------------------------

        Set a derivative binding equation by name.

        >  void casadi::SymbolicOCP::setOde(const SX &var, const SX &val)
        ------------------------------------------------------------------------

        Set an derivative binding expression by non-differentiated expression.


        """
        return _casadi_core.SymbolicOCP_setOde(self, *args)


    def nominal(self, *args):
        """
        nominal(SymbolicOCP self, std::string const & name) -> double
        nominal(SymbolicOCP self, SX var) -> DVector



        >  double casadi::SymbolicOCP::nominal(const std::string &name) const 
        ------------------------------------------------------------------------

        Get the nominal value by name.

        >  std::vector< double > casadi::SymbolicOCP::nominal(const SX &var) const 
        ------------------------------------------------------------------------

        Get the nominal value(s) by expression.


        """
        return _casadi_core.SymbolicOCP_nominal(self, *args)


    def setNominal(self, *args):
        """
        setNominal(SymbolicOCP self, std::string const & name, double val)
        setNominal(SymbolicOCP self, SX var, DVector val)



        >  void casadi::SymbolicOCP::setNominal(const std::string &name, double val)
        ------------------------------------------------------------------------

        Set the nominal value by name.

        >  void casadi::SymbolicOCP::setNominal(const SX &var, const std::vector< double > &val)
        ------------------------------------------------------------------------

        Set the nominal value(s) by expression.


        """
        return _casadi_core.SymbolicOCP_setNominal(self, *args)


    def min(self, *args):
        """
        min(SymbolicOCP self, std::string const & name) -> SX
        min(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::min(const std::string &name) const 
        ------------------------------------------------------------------------

        Get the lower bound by name.

        >  SX casadi::SymbolicOCP::min(const SX &var) const 
        ------------------------------------------------------------------------

        Get the lower bound(s) by expression.


        """
        return _casadi_core.SymbolicOCP_min(self, *args)


    def setMin(self, *args):
        """
        setMin(SymbolicOCP self, std::string const & name, SX val)
        setMin(SymbolicOCP self, SX var, SX val)



        >  void casadi::SymbolicOCP::setMin(const std::string &name, const SX &val)
        ------------------------------------------------------------------------

        Set the lower bound by name.

        >  void casadi::SymbolicOCP::setMin(const SX &var, const SX &val)
        ------------------------------------------------------------------------

        Set the lower bound(s) by expression.


        """
        return _casadi_core.SymbolicOCP_setMin(self, *args)


    def max(self, *args):
        """
        max(SymbolicOCP self, std::string const & name) -> SX
        max(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::max(const std::string &name) const 
        ------------------------------------------------------------------------

        Get the upper bound by name.

        >  SX casadi::SymbolicOCP::max(const SX &var) const 
        ------------------------------------------------------------------------

        Get the upper bound(s) by expression.


        """
        return _casadi_core.SymbolicOCP_max(self, *args)


    def setMax(self, *args):
        """
        setMax(SymbolicOCP self, std::string const & name, SX val)
        setMax(SymbolicOCP self, SX var, SX val)



        >  void casadi::SymbolicOCP::setMax(const std::string &name, const SX &val)
        ------------------------------------------------------------------------

        Set the upper bound by name.

        >  void casadi::SymbolicOCP::setMax(const SX &var, const SX &val)
        ------------------------------------------------------------------------

        Set the upper bound(s) by expression.


        """
        return _casadi_core.SymbolicOCP_setMax(self, *args)


    def initialGuess(self, *args):
        """
        initialGuess(SymbolicOCP self, std::string const & name) -> SX
        initialGuess(SymbolicOCP self, SX var) -> SX



        >  SX casadi::SymbolicOCP::initialGuess(const std::string &name) const 
        ------------------------------------------------------------------------

        Get the initial guess by name.

        >  SX casadi::SymbolicOCP::initialGuess(const SX &var) const 
        ------------------------------------------------------------------------

        Get the initial guess(es) by expression.


        """
        return _casadi_core.SymbolicOCP_initialGuess(self, *args)


    def setInitialGuess(self, *args):
        """
        setInitialGuess(SymbolicOCP self, std::string const & name, SX val)
        setInitialGuess(SymbolicOCP self, SX var, SX val)



        >  void casadi::SymbolicOCP::setInitialGuess(const std::string &name, const SX &val)
        ------------------------------------------------------------------------

        Set the initial guess by name.

        >  void casadi::SymbolicOCP::setInitialGuess(const SX &var, const SX &val)
        ------------------------------------------------------------------------

        Set the initial guess(es) by expression.


        """
        return _casadi_core.SymbolicOCP_setInitialGuess(self, *args)


    def start(self, *args):
        """
        start(SymbolicOCP self, std::string const & name, bool normalized=False) -> double
        start(SymbolicOCP self, SX var, bool normalized=False) -> DVector



        >  double casadi::SymbolicOCP::start(const std::string &name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) value at time 0 by name.

        >  std::vector< double > casadi::SymbolicOCP::start(const SX &var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) value(s) at time 0 by expression.


        """
        return _casadi_core.SymbolicOCP_start(self, *args)


    def setStart(self, *args):
        """
        setStart(SymbolicOCP self, std::string const & name, double val, bool normalized=False)
        setStart(SymbolicOCP self, SX var, DVector val, bool normalized=False)



        >  void casadi::SymbolicOCP::setStart(const std::string &name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) value at time 0 by name.

        >  void casadi::SymbolicOCP::setStart(const SX &var, const std::vector< double > &val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) value(s) at time 0 by expression.


        """
        return _casadi_core.SymbolicOCP_setStart(self, *args)


    def derivativeStart(self, *args):
        """
        derivativeStart(SymbolicOCP self, std::string const & name, bool normalized=False) -> double
        derivativeStart(SymbolicOCP self, SX var, bool normalized=False) -> DVector



        >  double casadi::SymbolicOCP::derivativeStart(const std::string &name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) derivative value at time 0 by name.

        >  std::vector< double > casadi::SymbolicOCP::derivativeStart(const SX &var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) derivative value(s) at time 0 by expression.


        """
        return _casadi_core.SymbolicOCP_derivativeStart(self, *args)


    def setDerivativeStart(self, *args):
        """
        setDerivativeStart(SymbolicOCP self, std::string const & name, double val, bool normalized=False)
        setDerivativeStart(SymbolicOCP self, SX var, DVector val, bool normalized=False)



        >  void casadi::SymbolicOCP::setDerivativeStart(const std::string &name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) derivative value at time 0 by name.

        >  void casadi::SymbolicOCP::setDerivativeStart(const SX &var, const std::vector< double > &val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) derivative value(s) at time 0 by expression.


        """
        return _casadi_core.SymbolicOCP_setDerivativeStart(self, *args)


    def unit(self, *args):
        """
        unit(SymbolicOCP self, std::string const & name) -> std::string
        unit(SymbolicOCP self, SX var) -> std::string



        >  std::string casadi::SymbolicOCP::unit(const std::string &name) const 
        ------------------------------------------------------------------------

        Get the unit for a component.

        >  std::string casadi::SymbolicOCP::unit(const SX &var) const 
        ------------------------------------------------------------------------

        Get the unit given a vector of symbolic variables (all units must be
        identical)


        """
        return _casadi_core.SymbolicOCP_unit(self, *args)


    def setUnit(self, *args):
        """
        setUnit(SymbolicOCP self, std::string const & name, std::string const & val)



        Set the unit for a component.


        """
        return _casadi_core.SymbolicOCP_setUnit(self, *args)


    def atTime(self, *args):
        """
        atTime(SymbolicOCP self, std::string const & name, double t, bool allocate=False) -> SX
        atTime(SymbolicOCP self, std::string const & name, double t, bool allocate=False) -> SX



        >  SX casadi::SymbolicOCP::atTime(const std::string &name, double t, bool allocate=false) const 
        ------------------------------------------------------------------------

        Timed variable (never allocate)

        >  SX casadi::SymbolicOCP::atTime(const std::string &name, double t, bool allocate=false)
        ------------------------------------------------------------------------

        Timed variable (allocate if necessary)


        """
        return _casadi_core.SymbolicOCP_atTime(self, *args)


    def __init__(self, *args):
        """
        __init__(casadi::SymbolicOCP self, bool ignore_timed_variables=True) -> SymbolicOCP
        __init__(casadi::SymbolicOCP self, SymbolicOCP other) -> SymbolicOCP



        Default constructor.


        """
        this = _casadi_core.new_SymbolicOCP(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _casadi_core.delete_SymbolicOCP
SymbolicOCP_swigregister = _casadi_core.SymbolicOCP_swigregister
SymbolicOCP_swigregister(SymbolicOCP)

class XmlFile(OptionsFunctionality):
    """


    XML parser Can be used for parsing XML files into CasADi data structures.

    Joel Andersson

    C++ includes: xml_file.hpp 
    """

    __swig_setmethods__ = {}
    for _s in [OptionsFunctionality]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlFile, name, value)
    __swig_getmethods__ = {}
    for _s in [OptionsFunctionality]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XmlFile, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi_core.delete_XmlFile

    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi_core.XmlFile_loadPlugin(*args)

    if _newclass:
        loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin

    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi_core.XmlFile_doc(*args)

    if _newclass:
        doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc

    def __init__(self, *args):
        """
        __init__(casadi::XmlFile self) -> XmlFile
        __init__(casadi::XmlFile self, std::string const & name) -> XmlFile
        __init__(casadi::XmlFile self, XmlFile other) -> XmlFile
        """
        this = _casadi_core.new_XmlFile(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
XmlFile_swigregister = _casadi_core.XmlFile_swigregister
XmlFile_swigregister(XmlFile)

def XmlFile_loadPlugin(*args):
    """XmlFile_loadPlugin(std::string const & name)"""
    return _casadi_core.XmlFile_loadPlugin(*args)

def XmlFile_doc(*args):
    """XmlFile_doc(std::string const & name) -> std::string"""
    return _casadi_core.XmlFile_doc(*args)

# This file is compatible with both classic and new-style classes.


